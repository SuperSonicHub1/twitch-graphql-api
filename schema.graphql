input AcceptFriendRequestInput {
  """
  The authenticated user will accept the friend request sent by the user with an ID equal to targetID.
  """
  targetID: ID!
}

type AcceptFriendRequestPayload {
  """The user whose friend request was just accepted."""
  user: User
}

"""Error associated with mutation AcceptOrganizationInvite."""
type AcceptOrganizationInviteError {
  """Error code."""
  code: AcceptOrganizationInviteErrorCode!
}

"""Client error code."""
enum AcceptOrganizationInviteErrorCode {
  """Internal error."""
  INTERNAL_ERROR

  """Invalid Argument."""
  INVALID_ARGUMENT

  """Invitation not found."""
  NOT_FOUND

  """The requesting user does not permission to accept invite."""
  PERMISSION_DENIED

  """
  The user doesn't meet the requirements to have this role. For example, when trying to assign the
  "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  """
  MEMBER_INELIGIBLE

  """Organization Member already exists."""
  ALREADY_EXISTS

  """
  User is exceeds the the limit of organization they can be a member for.
  """
  EXCEEDS_MEMBERSHIP_LIMIT
}

"""Input to the AcceptOrganiztaionInvite mutation."""
input AcceptOrganizationInviteInput {
  """First name to the user accepting the invite."""
  firstName: String!

  """Last name of the user accepting the invite."""
  lastName: String!

  """ID of the invite to accept."""
  organizationInviteID: ID!

  """Job title the user has in the inviting organization."""
  title: String!
}

"""Output from the AcceptOrganizationInvite mutation."""
type AcceptOrganizationInvitePayload {
  """The possible error returned from service."""
  error: AcceptOrganizationInviteError
}

"""Enumerates possible errors when accepting a program agreement."""
enum AcceptProgramAgreementError {
  """Must have auth credentials to agree to a program agreement."""
  UNAUTHENTICATED

  """
  User does not have permission to agree to the program agreement for the targeted user.
  """
  FORBIDDEN

  """Version of the agreement provided in the input is not valid."""
  INVALID_AGREEMENT_VERSION

  """An internal error has occurred."""
  INTERNAL_ERROR
}

"""
AcceptProgramAgreementInput is the input required when accepting a program agreement.
"""
input AcceptProgramAgreementInput {
  """
  TargetUserID is the ID of the user whose program agreement will be accepted.
  """
  targetUserID: ID!

  """Agreement type being accepted for payout onboarding."""
  type: PayoutOnboardingCategory!

  """Version of agreement (e.g. "v1")."""
  version: String!
}

"""
AcceptProgramAgreementPayload is the payload returned after accepting a program agreement.
"""
type AcceptProgramAgreementPayload {
  """Describes error that occured while accepting a program agreement."""
  error: AcceptProgramAgreementError

  """New workflow state."""
  workflow: PayoutOnboardingWorkflow
}

"""Errors from acceptSquadStreamInvitation mutation."""
type AcceptSquadStreamInvitationError {
  """Error from request to accept invitation."""
  code: AcceptSquadStreamInvitationErrorCode!
}

"""Possible errors from this mutation."""
enum AcceptSquadStreamInvitationErrorCode {
  """Invitation to be accepted does not exist."""
  INVITATION_NOT_FOUND

  """Squad associated with the invitation does not exist."""
  SQUAD_NOT_FOUND

  """User does not have permissions to accept invitation."""
  UNAUTHORIZED

  """Invitation not in pending state cannot be accepted."""
  INVITATION_CANNOT_BE_ACCEPTED

  """The recipient does not have access to squad streams."""
  USER_CANNOT_ACCESS_SQUADS
}

"""Inputs to the acceptSquadStreamInvitation mutation."""
input AcceptSquadStreamInvitationInput {
  """ID of the invitation to be accepted."""
  invitationID: ID!
}

"""Outputs from the acceptSquadStreamInvitation mutation."""
type AcceptSquadStreamInvitationPayload {
  """Error from mutation if exists."""
  error: AcceptSquadStreamInvitationError

  """The accepted invitation."""
  invitation: SquadStreamInvitation
}

"""The information about all of a user's connected accounts."""
type AccountConnectionSet {
  """Connection information about a user's Blizzard account."""
  blizzard: UserBlizzardConnectionLink

  """Connection infromation about a user's Facebook account."""
  facebook: UserFacebookConnectionLink

  """Whether or not the user has a linked amazon account."""
  hasConnectedAmazon: Boolean

  """Connection information about a user's Riot account."""
  riot: UserRiotConnectionLink

  """Connection information about a user's Steam account."""
  steam: UserSteamConnectionLink

  """Connection information about a user's Twitter account."""
  twitter: UserTwitterConnectionLink

  """Connection information about a user's Youtube account."""
  youtube: UserYoutubeConnectionLink
}

"""An error returned from the acknowledgePredictionResult mutation."""
type AcknowledgePredictionResultError {
  """Code describing the error."""
  code: AcknowledgePredictionResultErrorCode!
}

"""Possible error codes from the acknowledgePredictionResult mutation."""
enum AcknowledgePredictionResultErrorCode {
  """
  The authorized user is forbidden from acknowledging this Prediction result.
  """
  FORBIDDEN

  """The specified Prediction ID was not found."""
  NOT_FOUND

  """The specified Prediction ID has not been resolved yet."""
  NOT_RESOLVED

  """An unknown error occurred."""
  UNKNOWN
}

"""Acknowledge the results of a Prediction."""
input AcknowledgePredictionResultInput {
  """The Prediction ID."""
  id: ID!
}

"""Payload for acknowledging the results of a Prediction."""
type AcknowledgePredictionResultPayload {
  """If present, there was an error with the request."""
  error: AcknowledgePredictionResultError

  """The acknowledgged Prediction."""
  prediction: Prediction
}

"""
AcknowledgeSubscriptionStateInput updates the state of the given subscription to aknowledged.
"""
input AcknowledgeSubscriptionStateInput {
  """ID of the subscription being updated."""
  subscriptionID: ID!
}

"""
AcknowledgeSubscriptionStatePayload returns the state of the subscription.
"""
type AcknowledgeSubscriptionStatePayload {
  """
  The current state of the subscription. One of "active", "will_not_renew", or "canceled".
  """
  state: UnacknowledgedSubscriptionEventState
}

"""Required input to acknowledge an unban request on a channel."""
input AcknowledgeUnbanRequestInput {
  """ID of the unban request to be acknowledged."""
  id: ID!
}

"""Result of acknowledging an unban request."""
type AcknowledgeUnbanRequestPayload {
  """Used for errors arising from acknowledging the unban request."""
  error: UnbanRequestError

  """The acknowledged unban request."""
  unbanRequest: UnbanRequest
}

"""The input to be provided to the activateExtension mutation."""
input ActivateExtensionInput {
  """The anchor the extension is getting activated into."""
  anchor: ExtensionAnchor!

  """
  The composite ID of an extension installation <extensionID:version:channelID>.
  """
  extensionInstallationID: ID!

  """The slot the extension is getting activated into."""
  slot: String!
}

"""The result of an activateExtension mutation."""
type ActivateExtensionPayload {
  """The resulting list of installed extensions after the activation."""
  installedExtensions: [ExtensionInstallation!]!
}

"""
ActivationState contains possible activation states found in the ActivationConfig.
"""
enum ActivationState {
  """The extension is activated into a slot on the channel."""
  ACTIVE

  """
  The extension has not been activated into a slot or required permsissions/config
  is not set up yet.
  """
  INACTIVE

  """
  The user rejected the permissions required for the extension to be activated.
  """
  REJECTED_PERMISSIONS
}

"""
An action (and metadata about the action) which a user or session is performing.
"""
interface Activity {
  """The type of activity."""
  type: ActivityType
}

"""
ActivityInput represents what the user is doing right now.

If type is WATCHING, userID must be supplied.

If type is PLAYING, gameID must be supplied.
"""
input ActivityInput {
  gameID: String
  type: ActivityType
  userID: String
}

"""The categories of activities which users can engage in."""
enum ActivityType {
  PLAYING
  STREAMING
  WATCHING
}

"""Amazon Digital Ad Service Properties."""
type ADASProperties {
  """The media partner that should be used for the ad break."""
  partner: String @deprecated(reason: "No longer needed.")

  """The id for selecting the amazon ad campaign or program."""
  programID: ID @deprecated(reason: "No longer needed.")
}

"""The context returned for the current ad request."""
type AdContext {
  """The decline status for this ad request."""
  declineState: AdContextDeclineState!

  """The id of the ad session this context applies to."""
  id: ID!

  """The RAd service token used to validate subsequent ad event mutations."""
  radToken: String!
}

"""The decline state for the context."""
type AdContextDeclineState {
  """The reason the ad request was declined if it was declined."""
  reason: String

  """Whether or not the client will request an ad."""
  shouldDecline: Boolean!
}

"""Advertising creative."""
type AdCreative {
  """The AdCreative's unique identifier."""
  id: ID!

  """Integrated loudness value for this AdCreative."""
  integratedLoudness: Float
}

"""
AddAutohostChannelsInput append channelIDs to a user's list to autohost.
"""
input AddAutohostChannelsInput {
  """ChannelIDs that will be added to the list to autohost."""
  channelIDs: [ID!]!

  """UserID to update autohost list for."""
  userID: ID!
}

"""
AddAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
"""
type AddAutohostChannelsPayload {
  """User whose autohostChannels field had been updated."""
  user: User
}

input AddBrowserPushSubscriptionInput {
  """An authentication secret. It must be a non-blank string."""
  auth: String!

  """
  A custom URL pointing to a push server, which can be used to send a push message to the
  particular service worker instance that subscribed to the push service. It must be a
  non-blank string.
  """
  endpoint: String!

  """
  An Elliptic curve Diffie–Hellman public key on the P-256 curve. It must be a non-blank string.
  """
  p256DH: String!
}

type AddBrowserPushSubscriptionPayload {
  """
  The opaque ID of the push subscription. The entire push subscription is not returned because
  there is no product use for it. Also, there is no existing query or mutation that can use this ID,
  but it could be used for future functionality.
  """
  browserPushSubscriptionID: ID
}

"""Possible errors that this resolver returns."""
enum AddChannelBlockedTermError {
  """User does not have permission to add blocked term in channel."""
  NO_PERMISSIONS

  """Duration provided was invalid."""
  DURATION_INVALID
}

"""
AddChannelBlockedTermInput takes in the channel, phrases, and if the term should be editable by mods.
"""
input AddChannelBlockedTermInput {
  """channelID is the channelID owner of terms."""
  channelID: ID!

  """isModEditable is if the term is viewable or editable by mods."""
  isModEditable: Boolean!

  """phrase defines the string that is to be blocked."""
  phrase: String

  """phrases is the strings that are blocked."""
  phrases: [String!]!
}

"""The returned data from the mutation."""
type AddChannelBlockedTermPayload {
  """The time term was added."""
  addedAt: Time

  """Mutation error caused by the user input."""
  error: AddChannelBlockedTermError

  """The phrases that were added."""
  phrases: [String!]!
}

"""Possible errors that this resolver returns."""
enum AddChannelPermittedTermError {
  """User does not have permission to add Permitted term in channel."""
  NO_PERMISSIONS

  """Duration provided was invalid."""
  DURATION_INVALID
}

"""
AddChannelPermittedTermInput takes in the channel, phrases, and if the term should be editable by mods.
"""
input AddChannelPermittedTermInput {
  """channelID is the owner of the permitted terms."""
  channelID: ID!

  """phrase defines the string that is to be permitted."""
  phrase: String

  """phrases are the strings that are permitted in a channel."""
  phrases: [String!]!
}

"""The returned payload from the mutation."""
type AddChannelPermittedTermPayload {
  """The time term was added."""
  addedAt: Time

  """Mutation error caused by the user input."""
  error: AddChannelPermittedTermError

  """The phrases that were added."""
  phrases: [String!]!
}

"""
AddCollectionItemInput accepts a collectionID and item ID and parameters to add the item to a collection.
"""
input AddCollectionItemInput {
  """The id of the collection."""
  collectionID: ID!

  """The id of the item of which will be added to the collection."""
  itemID: ID!

  """The type of item ie. video."""
  itemType: String!
}

"""The response from adding an item to a collection."""
type AddCollectionItemPayload {
  """The newly updated collection."""
  collection: Collection
}

"""Add a Phase to a Competition."""
input AddCompetitionPhaseInput {
  """Unique Competition ID."""
  competitionID: ID!
}

"""Data that was mutated after the Phase was created."""
type AddCompetitionPhasePayload {
  """
  The competition is returned with any side effects adding a phase has caused.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Add a User as a player to a Competition."""
input AddCompetitionPlayerInput {
  """Unique Competition ID."""
  competitionID: ID!

  """The player's Discord username."""
  discordUsername: String

  """The player's in-game username."""
  inGameUsername: String

  """The state the player in. Defaults to INVITED if not specified."""
  state: CompetitionPlayerState

  """Twitch user id of the player."""
  userID: ID!
}

"""Data that was mutated after the player was created."""
type AddCompetitionPlayerPayload {
  """
  The new state of competition after adding a competition player to the competition.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Inputs adding a competition team to a competition."""
input AddCompetitionTeamInput {
  """ID of the competition team captain."""
  captainID: ID

  """ID of the competition."""
  competitionID: ID!

  """The user ids of the team members."""
  members: [ID!]

  """The name of the team."""
  name: String!
}

"""
AddCompetitionTeamPayload is the success response adding a competition team to the competition.
"""
type AddCompetitionTeamPayload {
  """
  The new state of competition after adding a competition team to the competition.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""
AddDeviceTokenInput accepts a token and other parameters to add a device token to a given user.
"""
input AddDeviceTokenInput {
  """App build number of the current device."""
  appBuild: String

  """
  Unique identifier of the current device.
  Note: deprecated field -- the deviceID now comess of the X-Device-Id header...
  """
  deviceID: ID

  """Arbitrary name associated with the device."""
  deviceName: String

  """The ID of the new token."""
  deviceToken: ID!

  """Notification capabilities of the current device."""
  notificationCapabilitiesTypes: [String!]

  """Onsite notification capabilities of the current device."""
  onsiteCapabilitiesTypes: [String!]

  """The platform the token is associated with, i.e. 'android' or 'ios'."""
  platform: String!

  """
  ID for the user associated with the new device token.
  Note: deprecated field -- the userID now comes off the authenticated user.
  """
  userID: ID
}

"""The response from adding a push notification token to a user."""
type AddDeviceTokenPayload {
  """The ID of the new token."""
  deviceToken: ID!
}

"""
AddDropToCampaignInput has fields required to create a drop within a campaign.
"""
input AddDropToCampaignInput {
  """The campaign this drop belongs to."""
  campaignID: ID!

  """The type of rule defining what needs to happen to trigger this drop."""
  dropRuleType: DropRuleType!

  """
  The date at which this drop can no longer occur. Default to campaign endDate if not provided.
  """
  endAt: Time

  """The friendly name of this drop."""
  name: String!

  """
  The date at which this drop can start to occur. Default to campaign startDate if not provided.
  """
  startAt: Time
}

"""AddDropToCampaignPayload returns the result of the creation."""
type AddDropToCampaignPayload {
  """Returns the newly created drop."""
  drop: DropType

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""AddEditorError contains details about a client error that occurred."""
type AddEditorError {
  """The type of error that occurred when adding an editor."""
  code: AddEditorErrorCode!
}

"""
AddEditorErrorCode defines a client error that occurred while adding an editor.
"""
enum AddEditorErrorCode {
  """The channel does not exist."""
  CHANNEL_NOT_FOUND

  """The user who is to become an editor is already an editor."""
  TARGET_USER_ALREADY_EDITOR

  """The user who is to become an editor does not exist."""
  TARGET_USER_NOT_FOUND
}

"""AddEditorInput contains the parameters to add an editor."""
input AddEditorInput {
  """The channel for which the target user will become an editor."""
  channelID: ID!

  """
  The ID of the user who will become an editor.
  Either targetUserID or targetUserLogin must be provided.
  """
  targetUserID: ID

  """
  The login of the user who will become an editor.
  Either targetUserID or targetUserLogin must be provided.
  """
  targetUserLogin: String
}

"""AddEditorPayload is the response after attemping to add an editor."""
type AddEditorPayload {
  """The channel for which the target user will become an editor."""
  channel: User

  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: AddEditorError

  """The user who became an editor."""
  targetUser: User
}

"""Error from a failed recent play mutation."""
type AddRadioRecentlyPlayedError {
  """Mutation error code."""
  code: AddRadioRecentlyPlayedErrorCode!
}

"""Recently played error codes."""
enum AddRadioRecentlyPlayedErrorCode {
  """The ID provided was malformed."""
  INVALID_ID

  """Permission denied to add/update a recently played item."""
  PERMISSION_DENIED
}

"""
AddRadioRecentlyPlayedInput contains the parameters to register a play start.
"""
input AddRadioRecentlyPlayedInput {
  """The type of content the ID maps to."""
  contentType: RadioRecentlyPlayedType!

  """The ID of the recently played item."""
  id: ID!
}

"""Response from registering a recent play."""
type AddRadioRecentlyPlayedPayload {
  """Error code."""
  error: AddRadioRecentlyPlayedError

  """The added/updated recently played item."""
  recent: RadioRecentlyPlayed
}

input AddReactionInput {
  emoteID: ID!
  entityID: ID!
}

type AddReactionPayload {
  content: ReactableContent!
}

"""Data required to add recommendation feedback."""
input AddRecommendationFeedbackInput {
  """Reason for the feedback (ie. Not interested, offensive, etc)."""
  category: RecommendationFeedbackCategory!

  """The id of the item (channelID, gameID, etc)."""
  itemID: ID!

  """One of CHANNEL, GAME, SHELF, VOD."""
  itemType: RecommendationFeedbackType!

  """The page this event was fired from."""
  sourceItemPage: String!

  """The unique id given to this request."""
  sourceItemRequestID: ID!

  """The tracking id of the shelf / shelf card."""
  sourceItemTrackingID: ID!
}

"""Returns the created feedback item back to the client."""
type AddRecommendationFeedbackPayload {
  """Feedback item."""
  recommendationFeedback: RecommendationFeedback
}

"""Error that may be returned by the AddStreamAuthorizedUser mutation."""
type AddStreamAuthorizedUserError {
  """Type of mutation error."""
  code: AddStreamAuthorizedUserErrorCode!
}

"""
AddStreamAuthorizedUserErrorCode is the client error type that occurred during the AddStreamAuthorizedUser mutation.
"""
enum AddStreamAuthorizedUserErrorCode {
  """
  Unable to assign the Targeted user to stream on behalf of the broadcaster.
  """
  TARGET_USER_UNRETURNABLE

  """The broadcaster is not found."""
  CHANNEL_NOT_FOUND

  """Maximum limit for adding authorized user is reached."""
  MAX_ACCOUNT_LIMIT

  """Permission denied to add an authorized user."""
  PERMISSION_DENIED

  """Invalid argument to add an authorized user."""
  INVALID_ARGUMENT
}

"""
AddStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID.
"""
input AddStreamAuthorizedUserInput {
  """
  authorizedUserID for an authorized user who is allow to stream on behalf of broadcaster.
  """
  authorizedUserID: ID!

  """channelID of the broadcaster."""
  channelID: ID!
}

"""
AddStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users.
"""
type AddStreamAuthorizedUserPayload {
  """The updated channel of broadcaster."""
  channel: Channel

  """Error code."""
  error: AddStreamAuthorizedUserError
}

"""AdPlatform describes the type of device."""
enum AdPlatform {
  """Ios iphone app."""
  IOS_PHONE

  """Ios tablet app."""
  IOS_TABLET

  """Android phone app."""
  ANDROID_PHONE

  """Android tablet app."""
  ANDROID_TABLET
}

"""A vote an ad poll and associated information."""
type AdPollVote {
  """Id of the choice that was voted for."""
  choiceID: ID!

  """id of the vote in the poll."""
  id: ID!

  """Id of the poll this voter voted in."""
  pollID: ID!

  """Id of the voter in the poll."""
  userID: ID!
}

"""Ad Properties is an object that defines ad properties for a channel."""
type AdProperties {
  """Deprecated."""
  adServer: String @deprecated(reason: "Should use adServerDefault instead")

  """Which adserver to send requests to."""
  adServerDefault: String

  """
  Amazon Digital Ad Service (ADAS) specific Properties for this channel.
  Properties should only be nested if it is ADAS specific.
  """
  adasProperties: ADASProperties

  """Which ids are costreamers for this channel."""
  costreamers: [User]

  """Contains ad density information for channel ads management."""
  density: Density

  """Contains properties used by channel's disable prerolls feature."""
  disablePrerollsAbility: DisablePrerollsAbility

  """
  Get the ad experiment treatment group for a specified experiment bucket.
  """
  experimentTreatment(bucket: String!): String

  """How often ad breaks can be run on this channel."""
  frequency: Int

  """If postrolls are disabled on this channel."""
  hasPostrollsDisabled: Boolean

  """If prerolls are disabled on this channel."""
  hasPrerollsDisabled: Boolean

  """If Turbo benefit is disabled on this channel."""
  hasTurboDisabled: Boolean

  """If vod ads are enabled on this channel."""
  hasVodAdsEnabled: Boolean

  """If multiplayer ads are enabled for subscribers on this channel."""
  isMultiplayerAdsForSubsEnabled: Boolean

  """
  A bool that represents a streamer's eligibility to run a picture by picture ad.
  """
  isPictureByPictureAdEligible: Boolean

  """Maximum length for an ad break on this channel."""
  maxAdBreakLength: Int

  """Current multiplayer ad offers on the channel."""
  multiplayerAdOffers: [MultiplayerAdOffer!]

  """The stream has the required age gate enabled if greater than 0."""
  requiredAge: Int

  """Tracking pixels that channel pages should fire at certain intervals."""
  trackingPixels(consent: GDPRConsent): [TrackingPixel!]

  """
  Setting for vod archive midrolls on this channel. Can be 'broadcaster', 'inserted', or 'off'.
  """
  vodArchiveMidrolls: String

  """Ad break length for VOD archive midrolls on this channel."""
  vodArchiveMidrollsBreakLength: Int

  """Frequency for VOD archive midrolls on this channel."""
  vodArchiveMidrollsFrequency: Int
}

"""The context of the Client when the ad request is about to be made."""
input AdRequestClientContext {
  """If the client is in audio only mode."""
  isAudioOnly: Boolean!

  """If the client is in mini theater mode."""
  isMiniTheater: Boolean!

  """If the client is in Picture in Picture mode."""
  isPIP: Boolean!

  """
  If the client is broadcasting to an external device (i.e. Chromecast, Airplay).
  """
  isUsingExternalPlayback: Boolean!

  """App that the client is using."""
  clientApp: String

  """Version of the app."""
  appVersion: String
}

"""The type of content playing when the ad was requested."""
enum AdRequestContentType {
  """Live streams."""
  LIVE

  """VOD playback."""
  VOD
}

"""The context of an upcoming ad request."""
input AdRequestContext {
  """The ID generated for the ad Session."""
  adSessionID: ID!

  """The context of the client at the time the ad is requested."""
  clientContext: AdRequestClientContext!

  """The commercial break ID of a channel wide midroll."""
  commercialID: ID

  """The duration of the ad break in seconds."""
  duration: Int!

  """If the requested ad is a viewer level midroll."""
  isVLM: Boolean

  """The context of the player at the time the ad is requested."""
  playerContext: AdRequestPlayerContext!

  """The type of ad request being made."""
  rollType: AdrollType!

  """The game played on the channel."""
  game: String

  """The twitch correlator."""
  twitchCorrelator: String

  """Format of the Ad being requested."""
  adFormat: String
}

"""The context of the Player when the ad request is about to be made."""
input AdRequestPlayerContext {
  """The type of content being watched."""
  contentType: AdRequestContentType!

  """If the session was initiated by playing automatically."""
  isAutoPlay: Boolean!

  """The signature for the access token for the current video session."""
  nauthSig: String!

  """The access token for the current video session."""
  nauthToken: String!

  """The ID for the current video session."""
  videoSessionID: ID

  """PlayerSizeMode of the incoming request."""
  playerSizeMode: String
}

"""The type of ad break being requested."""
enum AdrollType {
  """Ad that runs prior to seeing a stream/vod."""
  PREROLL

  """Ad that runs in the middle of a stream/vod."""
  MIDROLL

  """Ad that runs after a stream/vod."""
  POSTROLL
}

"""AdSession is the response object from an Ad Request."""
type AdSession {
  """id is the id of the ad."""
  id: ID!

  """lengthSeconds is the length of the ad being requested in seconds."""
  lengthSeconds: Int!

  """
  retryAfterSeconds is the amount of time in seconds remaining for a user to run another ad.
  """
  retryAfterSeconds: Int!
}

"""Defines ads management attributes for channel."""
type AdSlot {
  """Duration of Ads that will run."""
  durationSeconds: Int!

  """Time when Ad will run."""
  runAtTime: Time!
}

"""Status of a user's invitation to the Affiliate program."""
enum AffiliateInvitationStatus {
  """Invitation cannot be sent, pending a user action."""
  INCOMPLETE_WORKFLOW

  """Invitation is scheduled to be sent."""
  PENDING_INVITE

  """Invitation has been sent."""
  SENT
}

"""Grouping of referral sources with name and count -- e.g. ("UK", 1437)."""
type AggregatedReferrals {
  """Count of the referrals from the named source (1437)."""
  count: Int!

  """Name of the referral source ("UK")."""
  name: String!
}

"""Error from the mutation."""
type AllocateKeysForBountyError {
  """Error code from the mutation."""
  code: AllocateKeysForBountyErrorCode!
}

"""Possible errors from the mutation."""
enum AllocateKeysForBountyErrorCode {
  """The provided input is invalid."""
  INVALID_ARGUMENT

  """The bounty or required key metadata was not found."""
  NOT_FOUND

  """Unknown error being returned from service."""
  UNKNOWN_ERROR
}

"""Input required to allocate keys for the bounty."""
input AllocateKeysForBountyInput {
  """Unique Identifier for the bounty."""
  bountyID: ID!

  """UserID that is allocating keys for the bounty."""
  userID: ID!
}

"""Payload from the mutation."""
type AllocateKeysForBountyPayload {
  """The bounty with allocated keys."""
  bounty: Bounty

  """The possible error returned from the service."""
  error: AllocateKeysForBountyError
}

input AllowRejectedChatMessageInput {
  id: ID!
}

type AllowRejectedChatMessagePayload {
  message: RejectedChatMessage
}

"""Input to the allowRejectedCheer mutation."""
input AllowRejectedCheerInput {
  """
  Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  The server will reject any request with an ID that has already been used.
  """
  id: ID!

  """ID of the user whose message is automodded."""
  targetUserID: ID!
}

"""Payload from the allowRejectedCheer mutation."""
type AllowRejectedCheerPayload {
  """
  Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  The server will reject any request with an ID that has already been used.
  """
  id: ID!
}

"""
Units defines how many price units is equivalent to 1 unit of currency.
"""
enum AndroidCurrencyUnits {
  """
  Default units is ISO-4217 format (e.g. 100 JPY units is 100 JPY, 100 USD units is 1.00 USD).
  """
  NORMAL_UNITS

  """Micro units (1,000,000 micro-units = 1 unit of currency)."""
  MICRO_UNITS
}

"""
AndroidPaymentTrackingDataInput contains fields to pass in tracking data.
"""
input AndroidPaymentTrackingDataInput {
  """The user's device ID."""
  deviceID: ID

  """The locale of the user."""
  locale: String
}

"""
AndroidReceiptDataInput contains the necessary fields to pass in Android purchase receipt data.
"""
input AndroidReceiptDataInput {
  """The currency the user was charged in."""
  currency: String!

  """The amount user was charged."""
  price: String!

  """The raw receipt of the purchase."""
  rawReceipt: String!

  """The receipt signature for the purchase."""
  signedReceipt: String!

  """The unit the user was charged in."""
  units: AndroidCurrencyUnits!
}

"""The available animated emote generation presets."""
enum AnimatedEmotePreset {
  """Shake makes the source image shake."""
  SHAKE

  """Roll makes the source image roll across."""
  ROLL

  """Spin makes the source image spin around in place."""
  SPIN

  """Rave makes the source image change colors."""
  RAVE

  """Slide in makes the source image slide in from the left."""
  SLIDE_IN

  """Slide out makes the source image slide out to the right."""
  SLIDE_OUT
}

"""An animated image asset."""
type AnimatedImageAsset {
  """Image ID generated by Mako for image."""
  id: ID!

  """Size of the image."""
  size: EmoteImageSize!
}

"""A mapping of extension type to list of activation configs."""
input ApplyExtensionActivationsInput {
  """A list of activations to apply to the given channelID."""
  activations: [ExtensionActivationInput!]!

  """The ID of the channel the activations are being performed on."""
  channelID: ID!
}

"""
A list of all installed extensions on the channel after an applyExtensionActivations mutation.
"""
type ApplyExtensionActivationsPayload {
  """
  The list of all installed extensions on the channel after an applyExtensionActivations mutation
  with their new activation state.
  """
  installedExtensions: [ExtensionInstallation!]!
}

"""Required input to approve an unban request on a channel."""
input ApproveUnbanRequestInput {
  """ID of the unban request to be resolved."""
  id: ID!

  """Optional message from the resolver to be shown to the unban requester."""
  resolverMessage: String
}

"""Result of approving an unban request."""
type ApproveUnbanRequestPayload {
  """Used for errors arising from resolving unban request."""
  error: UnbanRequestError

  """The resolved unban request."""
  unbanRequest: UnbanRequest
}

"""ArchiveChanletInput archives a chanlet by chanlet ID."""
input ArchiveChanletInput {
  """The ID of the chanlet being archived."""
  chanletID: ID!
}

"""ArchiveChanletPayload returns the Chanlet that was archived."""
type ArchiveChanletPayload {
  """The chanlet archived."""
  chanlet: Channel!
}

"""Archive community goal error."""
type ArchiveCommunityPointsCommunityGoalError {
  """The error code."""
  code: ArchiveCommunityPointsCommunityGoalErrorCode!
}

"""Archive community goal error code."""
enum ArchiveCommunityPointsCommunityGoalErrorCode {
  """The goal was not found."""
  NOT_FOUND

  """
  The current user is not allowed to archive community goals for this channel.
  """
  FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""Archive community goal input."""
input ArchiveCommunityPointsCommunityGoalInput {
  """The channel."""
  channelID: ID!

  """The community goal."""
  goalID: ID!
}

"""Archive community goal payload."""
type ArchiveCommunityPointsCommunityGoalPayload {
  """The error, if any."""
  error: ArchiveCommunityPointsCommunityGoalError

  """The community goal that was archived."""
  goal: CommunityPointsCommunityGoal
}

"""Inputs for archiving a poll."""
input ArchivePollInChannelInput {
  """The id of the channel that contains the poll to archive."""
  channelID: ID!
}

"""Outputs from the archive poll mutation."""
type ArchivePollInChannelPayload {
  """The archived poll."""
  poll: Poll
}

"""Inputs for archiving a poll."""
input ArchivePollInput {
  """The id of the poll to archive."""
  pollID: ID!
}

"""Outputs from the create poll mutation."""
type ArchivePollPayload {
  """The created poll."""
  poll: Poll
}

"""Possible errors from the mutation."""
enum ArkoseEndpointVersion {
  """Version 1 endpoint."""
  V1

  """Version 2 endpoint."""
  V2
}

"""Error returned after attempting to assign an emote to a bits tier."""
type AssignEmoteToBitsTierError {
  """The error code associated with this error."""
  code: AssignEmoteToBitsTierErrorCode!
}

"""Possible error codes for AssignEmoteToBitsTierError."""
enum AssignEmoteToBitsTierErrorCode {
  """The specified emote does not exist."""
  EMOTE_NOT_FOUND

  """The user is not allowed to assign this emote."""
  PERMISSION_DENIED

  """The bits tier has no available empty emote slots."""
  EMOTE_LIMIT_REACHED

  """The emote is not in a valid state to be assigned."""
  INVALID_EMOTE_STATE

  """An active or pending emote is already using this emote's code."""
  EMOTE_CODE_ALREADY_EXISTS

  """Emotes are not allowed in the specified bits tier."""
  EMOTES_NOT_ALLOWED_IN_TIER

  """Unknown error."""
  UNKNOWN
}

"""The input for assign emote to bits tier."""
input AssignEmoteToBitsTierInput {
  """ID of the channel that owns the bits tier."""
  channelID: ID!

  """ID of the emote to be assigned."""
  emoteID: ID!

  """Threshold of the bits tier to assign the emote to."""
  tierThreshold: Int!
}

"""Result of assign emote to bits tier."""
type AssignEmoteToBitsTierPayload {
  """The updated emote if successful."""
  emote: Emote

  """Error returned after attempting to assign an emote to a bits tier."""
  error: AssignEmoteToBitsTierError
}

"""
Error returned after attempting to assign an emote to a subscription product.
"""
type AssignEmoteToSubscriptionProductError {
  """The error code associated with this error."""
  code: AssignEmoteToSubscriptionProductErrorCode!
}

"""Possible error codes for AssignEmoteToSubscriptionProductError."""
enum AssignEmoteToSubscriptionProductErrorCode {
  """The specified emote does not exist."""
  EMOTE_NOT_FOUND

  """The user is not allowed to assign this emote."""
  PERMISSION_DENIED

  """The product has no available empty emote slots."""
  EMOTE_LIMIT_REACHED

  """The emote is not in a valid state to be assigned."""
  INVALID_EMOTE_STATE

  """An active or pending emote is already using this emote's code."""
  EMOTE_CODE_ALREADY_EXISTS

  """Unknown error."""
  UNKNOWN
}

"""The input for assign emote to subscription product."""
input AssignEmoteToSubscriptionProductInput {
  """ID of the emote to be assigned."""
  emoteID: ID!

  """ID of the subscription product to assign the emote to."""
  productID: ID!
}

"""Result of assign emote to subscription product."""
type AssignEmoteToSubscriptionProductPayload {
  """The updated emote if successful."""
  emote: Emote

  """
  Error returned after attempting to assign an emote to a subscription product.
  """
  error: AssignEmoteToSubscriptionProductError
}

"""
AssignExtensionBillingManagerError is the error associated with AssignExtensionBillingManager.
"""
type AssignExtensionBillingManagerError {
  """The associated error code."""
  code: AssignExtensionBillingManagerErrorCode!
}

"""Enums for the difference error codes which can be returned."""
enum AssignExtensionBillingManagerErrorCode {
  """
  Extension does not belong to the same organization as the assigned billing manager member.
  """
  FAILED_PRECONDITION

  """
  The user doesn't meet the requirements to be the assigned billing manager.
  For example, doesn't have a valid role or did not complete Extension Monetization (TIMs).
  """
  MEMBER_INELIGIBLE

  """User does not have permission to perform action."""
  PERMISSION_DENIED
}

"""Inputs to the SetExtensionBillingManager mutation."""
input AssignExtensionBillingManagerInput {
  """The ID of the extensions."""
  extensionID: ID!

  """The twitch ID of the organization member."""
  userID: ID!
}

"""Payload retuned from the mutation."""
type AssignExtensionBillingManagerPayload {
  """The possible error returned from the service."""
  error: AssignExtensionBillingManagerError

  """The updated extension."""
  extensionClient: ExtensionClient
}

"""Information regarding an Amazon Associates store."""
type AssociatesStore {
  ID: ID!

  """Whether the owner of this store is enabled to recieve payments."""
  isPayoutEnabled: Boolean

  """The store ID tag."""
  storeID: String
}

"""Authenticated Twitch session."""
type AuthenticatedSession {
  """ID of the client the user authenticated from."""
  clientID: ID!

  """Creation date of the session."""
  createdAt: Time

  """
  Date of invalidation of the session.
  Can be null if the session hasn't been deleted.
  """
  deletedAt: Time

  """Geolocation during authentication, determined by IP."""
  location: String

  """User agent used during authentication."""
  userAgent: String

  """Twitch User ID."""
  userID: ID!
}

"""
A list of configured autohost channels

A relay connection type that does not yet support pagination.
"""
type AutohostChannelConnection {
  """The channels."""
  nodes: [User!]
}

"""
A list of channels that are autohosting the channel

A relay connection type that does not yet support pagination.
"""
type AutohostedByChannelConnection {
  """The channels."""
  nodes: [User!]
}

"""A user's autohosting settings."""
type AutohostSettings {
  """True if this channels prefers autohost over vodcast."""
  deprioritizeVodcast: Boolean!

  """True if this channel has the autohost feature turned on."""
  enabled: Boolean!

  """Determines what other channels can raid this channel."""
  incomingRaidsPolicy: AutohostSettingsIncomingRaidsPolicy! @deprecated(reason: "Use User.raidSettings.incomingRaidsPolicy instead.")

  """The strategy to use when choosing channels to autohost."""
  strategy: AutohostSettingsStrategy!

  """True if this user autohosts their team members."""
  teamHost: Boolean!
}

"""
DEPRECATED: to be replaced by IncomingRaidsPolicy.
Determines what other channels can raid this channel.
"""
enum AutohostSettingsIncomingRaidsPolicy {
  """This user cannot be radied by anyone."""
  NONE

  """This user can be raided by other people in their network."""
  NETWORK

  """This user can be raded by anyone."""
  ALL
}

"""The strategy to use when choosing channels to autohost."""
enum AutohostSettingsStrategy {
  """Picks channels in the order defined by the user."""
  ORDERED

  """Picks channels at random."""
  RANDOM
}

"""
An automod fragment type, which is text that is flagged by AutoModeration.
It contains a list of topics which contain reasons why AutoModeration flagged the text.
"""
type AutoMod {
  """The topics that were flagged by AutoModeration."""
  topics: [AutoModTopic!]!
}

"""A message rejected by automod."""
type AutoModCaughtMessage {
  """Reason why the message was flagged and/or rejected."""
  category: AutoModCaughtMessageCategory!

  """id contains the UUID of the AutoModCaughtMessage."""
  id: ID!

  """
  The contents of the message itself, including its content, sender, sentAt timestamp, etc.
  """
  modLogsMessage: ModLogsMessage!

  """Time when a moderator allowed or denied a flagged message."""
  resolvedAt: Time

  """The user (mod) who approve/denied the flagged message."""
  resolver: User

  """The approval status of the caught message."""
  status: AutoModCaughtMessageStatus!
}

"""Reason why a message is flagged and/or rejected."""
enum AutoModCaughtMessageCategory {
  """Message contained words that were aggressive."""
  AGGRESSIVE

  """Message contained identity details."""
  IDENTITY

  """Message contained words that were vulgar."""
  PROFANITY

  """Message contained words that were sexual."""
  SEXUAL
}

"""Describes a flagged message's posting status."""
enum AutoModCaughtMessageStatus {
  """The message has not received a decision from a mod."""
  PENDING

  """
  Deprecated. The message was approved by a channel moderator or the broadcaster.
  """
  APPROVED

  """
  The message was allowed to be sent to chat by a channel moderator or the broadcaster.
  """
  ALLOWED

  """The message was denied by a channel moderator or the broadcaster."""
  DENIED

  """The message status is invalid (something unexpected)."""
  INVALID

  """
  The message expired before being acted upon by a channel moderator or the broadcaster.
  """
  EXPIRED
}

"""
Defines all AutoMod level settings for a channel, either may be not be set.
"""
type AutoModConfiguration {
  """This field represents the detailed AutoMod category settings."""
  detailedLevels: DetailedAutoModConfiguration

  """This field will be a value between 0 and 4, inclusive."""
  overallLevel: Int
}

"""AutomodContent is the automod response for the text evaulated."""
type AutoModContent {
  """
  failureReasons are pieces of the reasons why the text is inappropriate analyzed by automod.
  """
  failureReasons: [AutoModFailureReason!]

  """text is the original raw string evaluated by automod."""
  text: String!

  """canPass is the result whether the text passed automod enforcement."""
  canPass: Boolean!

  """id is the ID generated for the test message (used for tracking)."""
  id: ID!

  """error is the error when querying automod content."""
  error: AutoModContentError
}

"""Error associated with query AutoModContent."""
type AutoModContentError {
  """Error code."""
  code: AutoModContentErrorCode!
}

"""Client error code."""
enum AutoModContentErrorCode {
  """Internal error."""
  INTERNAL_ERROR

  """Invalid Argument."""
  INVALID_ARGUMENT

  """Resource Exhausted(rate limited)."""
  RESOURCE_EXHAUSTED
}

"""AutoModContentInput is the input of query AutoModContent."""
input AutoModContentInput {
  """channel ID is where the text enforcement will be tested."""
  channelID: ID!

  """text is the original raw string that needs evaluation by automod."""
  text: String!

  """
  overallLevel is the override overall level that will be passed in (0-4).
  """
  overallLevel: Int

  """
  autoModSettings is the override automod settings that will be passed in.
  """
  autoModSettings: DetailedAutoModLevelsInput
}

"""AutoModFailureReason is the failure reason from AutoMod."""
type AutoModFailureReason {
  """
  normalizedText is the normalized text processed by automod, if you need to get
  the violation words, use startPosition and endPosition to get the substring from raw text.
  """
  normalizedText: String!

  """startPosition is the start position of the inappropriate substring."""
  startPosition: Int!

  """endPosition is the end position of the inappropriate substring."""
  endPosition: Int!

  """topics is the topic and its level of the inappropriate substring."""
  topics: DetailedAutoModConfiguration!
}

type AutoModProperties {
  """These are integers between 0 and 6, inclusive."""
  aggressiveLevel: Int!
  identityLevel: Int!
  profanityLevel: Int!
  sexualLevel: Int!
}

"""An auto moderation topic with value."""
type AutoModTopic {
  """The topic type, defined by Zuma."""
  type: String!

  """The weight assigned to the topic."""
  weight: Int!
}

"""
Contains all auto refill profiles, will have auto refill metadata in the future.
"""
type AutoRefill {
  """Lists actions to execute during an auto refill setup session."""
  actions(paymentProvider: PaymentProvider!): [CheckoutAction!]!

  """The list of auto refill profiles."""
  profiles: [AutoRefillProfile!]!

  """
  A list of active xsolla payment methods that a user has available. This field
  is intended to be replaced by the User.PaymentMethods query.
  """
  xsollaPaymentMethods: [PaymentMethod!]
}

"""Auto Refill profile information."""
type AutoRefillProfile {
  """The charge instrument information for starting a purchase."""
  chargeInstrument: ChargeInstrument

  """Unique ID assigned to this profile."""
  id: ID!

  """Indicates if this profile is active."""
  isEnabled: Boolean!

  """The offerID that maps to the ability to purchase the intended product."""
  offerID: ID

  """The threshold amount a balance must go below to trigger a reload."""
  threshold: Int!
}

"""The possible computed states for a user or session."""
enum Availability {
  AWAY
  BUSY
  IDLE
  OFFLINE
  ONLINE
}

enum AvailabilityInput {
  ONLINE
  IDLE
  OFFLINE
}

"""AVC profiles for streams."""
enum AVCProfile {
  """Low level."""
  BASELINE

  """Regular level."""
  MAIN

  """High level."""
  HIGH
}

"""
BackupIngestSession is session metadata related to broadcaster's backup session.
"""
type BackupIngestSession {
  """The session where the current session was stitched from."""
  stitchedFrom: [BackupStreamSession!]

  """The session where the current session was stitched to."""
  stitchedTo: [BackupStreamSession!]
}

"""BackupStreamSession identifies the backup stream session."""
type BackupStreamSession {
  """Type of live stream."""
  broadcastFormat: BroadcastFormat!

  """The ID of backup session."""
  id: ID!

  """Time when the backup stream was stitched as primary session."""
  stitchedTimeAt: Time!
}

"""Communicates a user's status in chat."""
type Badge {
  """Identifies an action to trigger when this badge is clicked."""
  clickAction: BadgeClickAction @deprecated(reason: "Should use onClickAction instead")

  """The URL to redirect to if the badge's onClickAction is VISIT_URL."""
  clickURL: String

  """
  A localized, human-friendly description of the badge.
  Defaults to English if no translation exists for the requested locale.
  """
  description: String!

  """The badge's unique identifier."""
  id: ID!

  """A URL to the badge's image."""
  imageURL(size: BadgeImageSize = NORMAL): String!

  """Identifies an action to trigger when this badge is clicked."""
  onClickAction: BadgeClickAction

  """Information about the user's relationship to this badge."""
  self: BadgeSelfEdge

  """
  The identifier of the set which this badge belongs (e.g. "subscriber").
  """
  setID: ID!

  """
  A localized, human-friendly title for the badge.
  Defaults to English if no translation exists for the requested locale.
  """
  title: String!

  """
  The badge's associated broadcaster.
  Returns null if this is a global badge.
  """
  user: User

  """The badge's version (e.g. "1mo")."""
  version: String!
}

"""Enumerates possible badge click actions."""
enum BadgeClickAction {
  """Go to the user's subscription page."""
  SUBSCRIBE

  """Go to the Twitch Turbo purchasing page."""
  GET_TURBO

  """Go to the Bits purchasing page."""
  GET_BITS

  """Redirect the user to the badge click URL."""
  VISIT_URL
}

"""Deprecated: Domains that badges belong to."""
enum BadgeDomain {
  """Badges that were granted via Twitch crates."""
  CRATE
}

"""Enumerates valid badge image sizes."""
enum BadgeImageSize {
  """The base badge image size: 18x18."""
  NORMAL

  """Double the normal badge image size: 36x36."""
  DOUBLE

  """Quadruple the normal badge image size: 72x72."""
  QUADRUPLE
}

"""Further details about this object, subject to the user's permissions."""
type BadgeSelfEdge {
  """
  Whether the given badge should be visible publicly in the badge owner's chat card badge carousel.
  """
  isVisibleInChatCard: Boolean!
}

"""A filter for controlling which Bits Badge Tier Emotes to return."""
enum BadgeTierEmotesFilter {
  """Returns all bits badge tier emotes for this channel."""
  ALL

  """
  Returns all locked bits badge tier emotes for this user in this channel.
  """
  LOCKED

  """
  Returns a few of the locked bits badge tier emotes for this user in this channel.
  Which emotes and the exact number are determined by the back-end.
  """
  LOCKED_PREVIEW

  """
  Returns all unlocked bits badge tier emotes for this user in this channel.
  """
  UNLOCKED

  """
  Returns highest currently unlocked bits badge tier emote and next to be unlocked by user.
  """
  HIGHEST_UNLOCKED_AND_NEXT
}

"""
Balance for a Twitch User Account in a FIAT currency. Can be used to purchase
product on the Twitch Platform.
"""
type Balance {
  """Amount in the smallest unit of subcurrency."""
  amount: Int!

  """ISO-4217 currency code of a user's balance."""
  currency: Currency!

  """When the credit amount will expire. Can be non-expirable (null)."""
  expiresAt: Time

  """Number of digits after the decimal separator."""
  exponent: Int!
}

type BanUserFromChatRoomError {
  code: BanUserFromChatRoomErrorCode!

  """
  On DURATION_INVALID, maximum number of seconds a user can be timed out for.
  """
  maxTimeoutDurationSeconds: Int

  """
  On DURATION_INVALID, minimum number of seconds a user can be timed out for.
  """
  minTimeoutDurationSeconds: Int
}

enum BanUserFromChatRoomErrorCode {
  """User does not have permission to ban in channel."""
  FORBIDDEN

  """Target does not exist."""
  TARGET_NOT_FOUND

  """User tried to ban themselves."""
  TARGET_IS_SELF

  """User tried to ban anonymous user."""
  TARGET_IS_ANONYMOUS

  """User tried to ban a moderator without permission."""
  TARGET_IS_MOD

  """DEPRECATED: no longer returned."""
  TARGET_IS_VIP

  """User tried to ban broadcaster."""
  TARGET_IS_BROADCASTER

  """User tried to ban staff."""
  TARGET_IS_STAFF

  """User tried to ban admin."""
  TARGET_IS_ADMIN

  """User tried to ban global mod."""
  TARGET_IS_GLOBAL_MOD

  """User tried to ban already banned user."""
  TARGET_ALREADY_BANNED

  """Duration provided was too short or too long."""
  DURATION_INVALID
}

input BanUserFromChatRoomInput {
  bannedUserLogin: String!
  channelID: ID!

  """
  This argument accepts a string specifying a duration.
  It takes a succession of a number (positive integer) and a time unit, one of:
  s[econd[s]], m[inute[s]], h[our[s]], d[ay[s]], w[eek[s]], mo[nth[s]].
  Number/unit pairs can be contiguous or separated by spaces.
  Valid examples: "3d4h" "11 minutes" "2month", "1s", "12 second"
  If not provided, target is banned permanently.
  """
  expiresIn: String

  """The reason that the user has been banned or timed out."""
  reason: String
}

type BanUserFromChatRoomPayload {
  """The new ban status of this user regarding the specified channel."""
  ban: ChatRoomBanStatus

  """Mutation error caused by the user input."""
  error: BanUserFromChatRoomError
}

input BanVideoCommenterInput {
  """The id of the channel from where to ban commenter from."""
  channelID: ID!

  """The id of the commenter to ban."""
  commenterID: ID!
}

type BanVideoCommenterPayload {
  user: User
}

"""The required input for an BeginUseBitsInExtension mutation."""
input BeginUseBitsInExtensionInput {
  """Channel on which to use the bits."""
  channelID: ID!

  """Extension client ID to spend bits in."""
  extensionClientID: ID!

  """The SKU of the item being bought."""
  sku: String!
}

"""The result of a BeginUseBitsInExtension mutation."""
type BeginUseBitsInExtensionPayload {
  """The user's balance."""
  balance: Int

  """How many bits are required for this."""
  bitsRequired: Int

  """Does the front end need to prompt the user."""
  isPromptRequired: Boolean

  """The new transaction ID for this spend."""
  transactionID: ID
}

"""BillingAuthInfo holds data to facilitate the Fraud analysis."""
input BillingAuthInfo {
  """Fraud Session ID."""
  recurlyFraudSessionID: ID

  """
  Token generated after completing a 3-D Secure device fingerprinting or
  authentication challenge.
  """
  threeDSecureActionResultTokenID: ID
}

"""
BitsAdOffer is an offer to earn bits by watching an ad or interacting with an engagement.
"""
type BitsAdOffer implements BitsOffer {
  """
  bits is the minimum number of bits received from watching an ad.
  Some ads may reward more, but this is the number displayed to the user before choosing to watch an ad for bits.
  """
  bits: Int!
  id: ID!

  """type is `BitsOfferType.AD`."""
  type: BitsOfferType!
}

"""Bits Badges with their associated settings."""
type BitsBadgeTier {
  """The badge for this tier."""
  badge: Badge

  """Whether the broadcaster can upload emoticons for this tier."""
  canUploadEmoticons: Boolean!

  """
  The emoticon configurations for emoticons that are currently in the process of being uploaded for this tier.
  """
  emoticonUploadConfigurations: [EmoteUploadConfiguration]!

  """The emoticons that are associated with this tier."""
  emoticons: [Emote]!

  """Whether the badge is enabled for this threshold."""
  isEnabled: Boolean!

  """Time when this badge tier was last updated."""
  lastUpdated: Time

  """The amount of bits a user must cheer to achieve this tier."""
  threshold: Int!

  """The number of users who have unlocked this badge tier."""
  unlockedUsersCount: Int!
}

"""BadgeTier Emoticon data to modify."""
input BitsBadgeTierEmoticonSetting {
  """
  The text representation that will allow a user to invoke the emoticon in chat.
  Usually consists of: a creator's emoticon prefix + a codeSuffix.
  """
  code: String!

  """
  The creator-defined suffix that differentiates this emoticon from other emoticons in the channel.
  Usually begins with either a capital letter or a number.
  """
  codeSuffix: String!

  """
  I'm going to make these new fields nullable and transition them to non-nullable after deprecate the existing flow
  Image ID for the 28x28 emote asset.
  """
  imageID1x: String

  """Image ID for the 56x56 emote asset."""
  imageID2x: String

  """Image ID for the 112x112 emote asset."""
  imageID4x: String
}

"""BadgeTier metadata to modify."""
input BitsBadgeTierInput {
  """Whether to reset the images to the default images."""
  deleteImage: Boolean

  """Wether to reset the badge title to the default title."""
  deleteTitle: Boolean

  """A list of emoticons to modify."""
  emoticonSettings: [BitsBadgeTierEmoticonSetting!]

  """Base64 encoded binary data of the 18x18px badge ("1x") image asset."""
  imageData1x: String

  """Base64 encoded binary data of the 36x36px badge ("2x") image asset."""
  imageData2x: String

  """Base64 encoded binary data of the 72x72px badge ("4x") image asset."""
  imageData4x: String

  """Whether the badge is enabled for this threshold."""
  isEnabled: Boolean

  """The threshold to modify."""
  threshold: Int!

  """Badge title as string."""
  title: String
}

"""
A notification about achieving a new bits badge tier. Used to send a special message.
"""
type BitsBadgeTierNotification {
  """Whether or not the notification can be shared with chat."""
  canShare: Boolean!

  """UUID for notification."""
  id: ID!

  """
  Represents the badge tier threshold reached by the user on a channel (e.g. 100, 1000, etc).
  """
  threshold: Int!

  """
  The list of bits badge tier emoticons that were obtained as part of achieving this notification's bits badge tier.
  """
  unlockedEmoticons: [Emote]!
}

"""Represents the state of the notification."""
enum BitsBadgeTierNotificationState {
  """User dismissed the notification."""
  SKIPPED

  """User shared the notification with chat."""
  SHARED

  """Notification should be shown to user."""
  SHOW
}

"""
BitsBundleOffer is an offer to purchase a number of bits for a certain price.
"""
type BitsBundleOffer implements BitsOffer {
  """amount is the numerical cost of this offer (ex: 20.00)."""
  amount: Float!

  """asin is the Amazon Standard Identification Number for this offer."""
  asin: ID!

  """bits is the number of bits this offer provides."""
  bits: Int!

  """
  Currency code that the price and amount are displayed in (USD, CAD, etc.).
  """
  currencyCode: String!

  """
  discount is the bulk discount this offer provides compared to the base offer [0.0-1.0).
  """
  discount: Float!
  id: ID!

  """
  includesVAT is a boolean flag to indicate that the Value Added Tax (VAT)
  is included in the price of a Bits product. This is important for Bits prices
  in EU.
  """
  includesVAT: Boolean!

  """
  isPromo is a flag that signifies if the offer is a promotional offer. This is for clients that
  need to display promotional offers differently.
  """
  isPromo: Boolean!

  """
  price is the formatted currency cost of this offer to be displayed to the user.
  """
  price: String! @deprecated(reason: "Use the 'amount' field and localize it yourself in conjunction with the 'currencyCode' field")

  """
  promotion contains information about this bits offer if it is a promotional
  offer. Is null if the offer is not promotional.
  """
  promotion: BitsPromotion

  """type is `BitsOfferType.BUNDLE`."""
  type: BitsOfferType!

  """
  url is the purchase URL to use for this offer.
  The url contains a `{channelID}` token which should be replaced by the
  `User.id` of the channel bits are being purchased from.
  """
  url: String!
}

"""
BitsChallengeConditionPoolRecipientWeightedShare represents the weighted share of the total bits pool
that a recipient user is entitled to upon condition satisfaction.
"""
input BitsChallengeConditionPoolRecipientWeightedShare {
  """TUID of the bits recipient."""
  recipientUserID: ID!

  """
  The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
  dictates the proportion that a particular recipient receives from the pool
  (shareWeight/totalShareWeight * totalBitsAmountInPool).
  """
  weight: Int!
}

"""An event that captures a single bits transaction."""
type BitsEvent {
  """Amount of bits used."""
  amount: Int!

  """Channel bits were used on."""
  channel: User

  """Event ID."""
  id: ID!

  """What type of event the bits were used on."""
  type: BitsEventType!

  """Time the bits were used at."""
  usedAt: Time!
}

"""A paginated list of bits events, and its metadata."""
type BitsEventConnection {
  """The list of bits events on this page."""
  edges: [BitsEventEdge!]!

  """Information about this page of bits."""
  pageInfo: PageInfo!

  """The total number of bits events in the overall collection."""
  totalCount: Int!
}

"""
Filter and sorting options for querying all bits events for a Twitch user.
"""
input BitsEventConnectionCriteriaInput {
  """Sort bits events by... defaults to date."""
  sortBy: BitsEventSort = DATE

  """Sort bits events direction, defaults to descending."""
  sortDirection: BitsEventSortDirection = DESC

  """
  Only show bits events of a certain type, defaults to returning all types.
  """
  type: BitsEventType

  """Only show bits events after this date."""
  usedAfter: Time

  """Only show bits events before this date."""
  usedBefore: Time
}

"""An element in a paginated list of bits events, and its metadata."""
type BitsEventEdge {
  """Offset acting as a cursor."""
  cursor: Cursor!

  """The element node."""
  node: BitsEvent!
}

"""Possible sort orders for lists of bits events."""
enum BitsEventSort {
  """Sort the bits events by amount."""
  AMOUNT

  """Sort the bits events by date."""
  DATE
}

"""Possible sort directions for lists of bits events."""
enum BitsEventSortDirection {
  """Sort in descending order."""
  DESC

  """Sort in ascending order."""
  ASC
}

"""Bits event type."""
enum BitsEventType {
  """Event for giving bits to broadcaster."""
  GIVE_BITS_TO_BROADCASTER

  """Event for using bits on extension."""
  USE_BITS_ON_EXTENSION

  """Event for using bits on poll."""
  USE_BITS_ON_POLL

  """Unknown event type."""
  UNKNOWN
}

"""A list of hashtags to use in chat while using bits."""
type BitsHashtagConnection {
  """The list of BitsHashtagEdges."""
  edges: [BitsHashtagEdge!]
}

"""BitsHashtagEdge contains."""
type BitsHashtagEdge {
  """The cursor of the record. This will be the BitsHashtagEdge ID."""
  cursor: Cursor!

  """The node of the edge contains all information about the hashtag."""
  node: BitsHashtagEntry!
}

"""
BitsHashtagEntry contains information about a hashtag, sucn as the description and image URL for display.
"""
type BitsHashtagEntry {
  """description text."""
  description: String

  """The ID, which would be the hashtag value."""
  id: ID!

  """An image to display in autocomplete."""
  imageURL: String
}

"""The Bits Key Code that can be claimed to add bits to a user's account."""
type BitsKeyCode implements Claimable {
  """A description of what is claimable for the bits key code."""
  description: String!

  """The ID of the bits key code."""
  id: ID!

  """The field that gives us claim information for the logged in user."""
  self: SelfClaimEdge

  """The type is `ClaimableType.BITS_KEY_CODE`."""
  type: ClaimableType!
}

"""User edge relating the key's status to the user."""
type BitsKeyCodeSelfClaimEdge implements SelfClaimEdge {
  """If the user is eligible to claim the key code."""
  canClaim: Boolean!

  """Nullable field for the country where the user redeemed the claimable."""
  countryOfResidence: String

  """The user ID that is claiming the code."""
  id: ID!

  """Nullable status code for if the user cannot claim the key code."""
  statusCode: String
}

"""BitsLeaderboard contains the leaderboard for a specified channel."""
type BitsLeaderboard {
  """
  entries is the list of users in the leaderboard ordered by the number of bits cheered.
  """
  entries: BitsLeaderboardConnection! @deprecated(reason: "the ID field is not unique between leaderboards on leaderboard entries. Use leaderboard item.")

  """id is the id of this leaderboard."""
  id: ID!

  """
  items is the list of users in the leaderboard ordered by the number of bits cheered.
  """
  items: BitsLeaderboardItemConnection!

  """
  SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time).
  """
  secondsRemaining: Int!
}

"""
Bits leaderboard connection is used to show the various leaderboard entries.
"""
type BitsLeaderboardConnection {
  edges: [BitsLeaderboardEdge]!
}

"""BitsLeaderboardEdge describes an edge in a bits leaderboard."""
type BitsLeaderboardEdge {
  """The cursor for this leaderboard edge."""
  cursor: String!

  """The leaderboard entry at this edge."""
  node: BitsLeaderboardEntry
}

"""Leaderboard entry at a specific node in a leaderboard connection."""
type BitsLeaderboardEntry {
  """id the id of this leaderboard entry."""
  id: ID!

  """rank the ordinal rank of this leaderboard entry."""
  rank: Int!

  """score the number of bits cheered by this leaderboard entry."""
  score: Int!
}

"""Leaderboard item at a specific node in a leaderboard connection."""
type BitsLeaderboardItem {
  """entryKey the key of this leaderboard item."""
  entryKey: String!

  """id the id of this leaderboard item."""
  id: ID!

  """rank the ordinal rank of this leaderboard item."""
  rank: Int!

  """score the number of bits cheered by this leaderboard entry."""
  score: Int!
}

"""
Bits leaderboard connection is used to show the various leaderboard items.
"""
type BitsLeaderboardItemConnection {
  """edges ..."""
  edges: [BitsLeaderboardItemEdge]

  """pageInfo ..."""
  pageInfo: PageInfo!

  """totalCount ..."""
  totalCount: Int
}

"""BitsLeaderboardItemEdge describes an edge in a bits leaderboard."""
type BitsLeaderboardItemEdge {
  """The cursor for this leaderboard edge."""
  cursor: Cursor!

  """The leaderboard entry at this edge."""
  node: BitsLeaderboardItem
}

"""
BitsLeaderboardSettings are channel-specific settings related to Bits Leaderboards.
"""
type BitsLeaderboardSettings {
  """isEnabled indicates if the Bits leaderboard is pinned in this channel."""
  isEnabled: Boolean!

  """
  timePeriodType indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc.
  """
  timePeriodType: LeaderboardTimePeriodType
}

"""BitsOffer is a way to obtain more bits."""
interface BitsOffer {
  """bits is the number of bits this offer grants."""
  bits: Int!
  id: ID!

  """type is the kind of offer object."""
  type: BitsOfferType!
}

"""BitsOfferType is the kind of offer."""
enum BitsOfferType {
  """
  AD is an advertisement or other engagement that can be watched to earn bits.
  """
  AD

  """
  BUNDLE is a standard package of bits that can be purchased for a price.
  """
  BUNDLE
}

"""The type used when checking which payment methods a user can use."""
type BitsPaymentMethods {
  """A list of the valid bits payment methods for a user."""
  paymentMethods: [BitsPaymentMethodType!]
}

"""Enum of payment method types."""
enum BitsPaymentMethodType {
  """Paypal."""
  PAYPAL

  """Amazon Pay."""
  AMAZON_PAY

  """Xsolla."""
  XSOLLA
}

"""
A product for bits that contains all information about a product, except for the pricing.
"""
type BitsProduct {
  """The amount of bits the product is for."""
  amount: Int!

  """The product ID."""
  id: ID!

  """The maximum quantity a user can purchase at once."""
  maxQuantity: Int!

  """The offer id associated with this product's id (if available)."""
  offerID: ID

  """A field that contains promotional information about the product."""
  promo: BitsProductPromotion

  """The relation of the product to the user."""
  self: BitsProductSelfEdge

  """The product type, which right now is only "purchase"."""
  type: BitsProductType!
}

"""The type used when checking bits product eligibility for a user."""
type BitsProductEligibility {
  """A boolean that is true when the user is eligible for the product."""
  canPurchase: Boolean!

  """
  If the user is ineligible for the product, then this code is set
  as the reason why the user is ineligible for the product.
  """
  reasonCode: String
}

"""Promotional information about bits products."""
type BitsProductPromotion {
  """The unique ID of the bits product promo."""
  id: ID!

  """The localized title of the promo product."""
  title: String!

  """
  The type of promotion the product is associated with. This type is not enumerable since it is very dynamic.
  """
  type: String!
}

"""
An enumerable that identifies the checkout provider the customer is using.
"""
enum BitsProductProvider {
  """Amazon checkout."""
  AMAZON

  """Android IAP."""
  ANDROID

  """iOS IAP."""
  IOS

  """Paypal checkout."""
  PAYPAL

  """Xsolla checkout."""
  XSOLLA
}

"""
Contains the Bits product's preview price and tax info for a Bits purchase, and error if a preview cannot be created.
"""
type BitsProductPurchaseInfo {
  """Lists any additional actions for a bits checkout session."""
  actions: [CheckoutAction!]!

  """The error is present if purchase info failed to be retrieved."""
  error: BitsProductPurchaseInfoError

  """Gets the preview price and tax info for the Bits purchase."""
  previewPriceInfo: PriceInfo
}

"""
Error information shown when priceInfo could not be retrieved for Bits Product.
"""
type BitsProductPurchaseInfoError {
  """The descriptive error code."""
  code: BitsProductPurchaseInfoErrorCode!
}

"""Possible errors when retrieving bits product purchase info."""
enum BitsProductPurchaseInfoErrorCode {
  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """The user is unauthorized to view purchase info."""
  USER_UNAUTHORIZED

  """The Pricing ID is not found (404)."""
  PRICING_ID_NOT_FOUND

  """
  Cannot determine User Residence. Either billing address and IP doesn't match or
  user doesn't have country of resident declared (409).
  """
  UNKNOWN_USER_RESIDENCE

  """The billing info could not be found for the user and provider (410)."""
  BILLING_INFO_NOT_FOUND

  """User is not eligible to purchase bits in this region (422)."""
  PURCHASE_INELIGIBLE
}

"""The relation of a Bits product to a user."""
type BitsProductSelfEdge {
  """
  Holds configuration necessary to start bits purchase checkout flow for this product for current user.
  """
  checkoutConfiguration: CheckoutConfiguration

  """Is the user eligible to claim the product at the given quantity."""
  eligibility(quantity: Int!): BitsProductEligibility!

  """
  Gets the preview price and tax info for the Bits purchase, or error if that failed.
  """
  purchaseInfo(quantity: Int!, paymentSession: PaymentSession): BitsProductPurchaseInfo!
}

"""An enumerable that identifies bits product types."""
enum BitsProductType {
  """A product that has to be purchased."""
  PURCHASED_PRODUCT

  """An unknown product type."""
  UNKNOWN
}

type BitsPromotion {
  """id indicates the particular promo that this offer is associated with."""
  id: ID!

  """
  PromoType indicates the type of promo that the offer represents i.e First time purchase, single purchase, etc...
  """
  type: String!
}

"""Settings tied to a bits user."""
type BitsUserSettings {
  """Settings specific to the first cheer tutorial."""
  firstCheerTutorial: FirstCheerTutorial
}

"""An enumerable that dictates user's Bits usage state."""
enum BitsUserState {
  """The user has never used or acquired Bits."""
  NEW_USER

  """
  The user has acquired Bits (purchased, watched ads, etc.) but has never used it.
  """
  ACQUIRED

  """
  The user has never used or acquired Bits, but clicked "Skip" button to skip the first user experience.
  """
  SKIPPED

  """The user has cheered before."""
  CHEERED

  """The user state is unknown."""
  UNKNOWN
}

"""Information regarding a Blizzard account that is linked to Twitch."""
type BlizzardUser {
  """The BattleTag that is stored for the user."""
  battleTag: String!

  """The Blizzard ID that is stored for the user."""
  id: ID!

  """The region the Blizzard account is from."""
  region: String!
}

"""
Location from where the current user blocked target user.
NOTE: it is onlyl used from the block_user mutation, this enum should have been
named BlockUserContext and be placed in the same mutation file.
"""
enum BlockContext {
  WHISPER
  CHAT
}

input BlockUserInput {
  """Reason the user is being blocked."""
  reason: String

  """Feature from which the user is being blocked."""
  sourceContext: BlockContext

  """ID of user to block."""
  targetUserID: ID!
}

type BlockUserPayload {
  """User that was blocked."""
  targetUser: User!
}

"""
A BoostSettings is a set of preferences set by a creator regarding Community Boosts for their channel.
"""
type BoostSettings {
  """
  If Boosts earned through community challenges are enabled on this channel.
  """
  isEarnedEnabled: Boolean

  """If the channel is eligible to recieve boosts."""
  isEligible: Boolean!

  """If Boosts are enabled on this channel."""
  isEnabled: Boolean

  """If Boosts paid for by the community are enabled on this channel."""
  isPaidEnabled: Boolean
}

"""A bounty is a task that a user can complete for a payout."""
type Bounty {
  """The campaign that this bounty belongs to."""
  campaign: BountyCampaign!

  """The chat Call to Action that will be display during the bounty."""
  chatCTA: BountyChatCTA

  """When the bounty was claimed by the user."""
  claimTime: Time @deprecated(reason: "Replacing with 'claimedAt' for consistency with 'At' suffix")

  """When the bounty was claimed by the user."""
  claimedAt: Time

  """When the bounty expires."""
  endAt: Time @deprecated(reason: "Replacing with 'expiresAt' as that is a more descriptive property name for the value.")

  """When the the user stops tracking."""
  endTime: Time @deprecated(reason: "Replacing with 'trackingStoppedAt' as that is a more descriptive property name for the value.")

  """When the bounty expires."""
  expiresAt: Time

  """The bounty's unique identifier."""
  id: ID!

  """The product keys for the bounty."""
  keys: [BountyProductKey!]

  """When the bounty was last modified."""
  lastModifiedAt: Time

  """
  The number of concurrent users (CCU) required to hit the maximum payout for the bounty.
  """
  maximumPayoutCCU: Int

  """The maximum payout for completing this bounty in USD cents."""
  maximumPayoutCents: Int!

  """
  The number of concurrent users (CCU) required to earn a payout for the bounty.
  """
  minimumPayoutCCU: Int

  """The node includes all bounty moderation metadata."""
  moderationMetadata: BountyModerationMetadata

  """The moderation status of the bounty."""
  moderationStatus: BountyModerationStatus @deprecated(reason: "Replacing with 'status' within moderationMetadata.")

  """The actual payout for completing this bounty in USD cents."""
  payoutCents: Int

  """
  The platform on which the user will play the game for this bounty (ie. PC).
  """
  platform: String

  """
  The region that the broadcaster has selected for this bounty (as defined by BountyCampaignKeyDescriptor).
  """
  region: String

  """Restrictions for this bounty."""
  restriction: BountyRestriction

  """When the bounty was claimed by the user."""
  startAt: Time @deprecated(reason: "Replacing with 'claimTime' as that is a more descriptive property name for the value.")

  """When the bounty was started by the user."""
  startTime: Time @deprecated(reason: "Replacing with 'trackingStartedAt' as that is a more descriptive property name for the value.")

  """The status of the bounty."""
  status: BountyStatus!

  """When the user starts tracking the bounty."""
  trackingStartedAt: Time

  """When the user stops tracking the bounty."""
  trackingStoppedAt: Time

  """The videos for this bounty."""
  videos: [BountyVideo!]
}

"""
Bounty board settings configure how a user can interact with the Bounty Boards feature.
"""
type BountyBoardSettings {
  """This determines whether or not a user has a bounty board notification."""
  hasNotification: Boolean!

  """
  This determines whether the user has the Bounty Boards feature enabled.
  """
  isEnabled: Boolean! @deprecated(reason: "Use 'status' instead.")

  """The user's status on Bounty Board."""
  status: BountyBoardUserStatus!
}

"""Represents the user's status on Bounty Board."""
enum BountyBoardUserStatus {
  """
  The user has been invited to join the Bounty Board program but cannot participate in bounties yet.
  """
  INVITED

  """
  The user has been accepted into the Bounty Board program and can participate in bounties.
  """
  ACCEPTED

  """The user has been banned from the Bounty Board program."""
  BANNED

  """The user is not part of the Bounty Board program."""
  NONE
}

"""
A campaign defines the requirements and parameters for a set of bounties.
"""
type BountyCampaign {
  """
  The list of games that if isAllowAllGames is false, the bounty must use.
  """
  allowedGames: [Game!]

  """
  The platforms on which users can play this campaign's game (ie. PC, PS4, Switch).
  """
  availablePlatforms: [String!]

  """The length of this campaign's bounties (in days)."""
  bountyLengthDays: Int!

  """
  Override Box Art URL only for campaign shown on Bounty Board Dashboard, unrelated to game.
  """
  boxArtURL: String

  """Details about the campaign that only the sponsoring brand should see."""
  brandDetails: BountyCampaignBrandDetails

  """
  Override Cover URL only for campaign shown on Bounty Board Dashboard, unrelated to game.
  """
  coverURL: String

  """Details for this campaign."""
  details: String!

  """
  Override Display name only for campaign shown on Bounty Board Dashboard, unrelated to game.
  """
  displayName: String

  """When the campaign expires."""
  endAt: Time! @deprecated(reason: "Replacing with 'endTime' as that is a more descriptive property name for the value.")

  """When the campaign expires."""
  endTime: Time!

  """The game identifier that is related to this campaign."""
  game: Game @deprecated(reason: "Replacing with 'allowedGames' as this provides a set of available games instead of a single game")

  """The campaign's unique identifier."""
  id: ID!

  """If the campaing is a promotional campaign."""
  isPromotionEligible: Boolean

  """The information about keys for the campaigns."""
  keyDescriptors: [BountyCampaignKeyDescriptor!]

  """Why the campaign was rejected."""
  rejectionReason: String @deprecated(reason: "Use 'rejectionReason' in 'brandDetails' instead.")

  """If a campaign allows any game to be played."""
  shouldAllowAllGames: Boolean

  """The sponsor that is funding this campaign (ie. Amazon Game Studios)."""
  sponsor: String!

  """When the campaign starts."""
  startAt: Time! @deprecated(reason: "Replacing with 'startTime' as that is a more descriptive property name for the value.")

  """When the campaign starts."""
  startTime: Time!

  """The status of the campaign."""
  status: BountyCampaignStatus @deprecated(reason: "Use 'status' in 'brandDetails' instead.")

  """
  How many seconds a bounty for this campaign must be streamed to complete the bounty.
  """
  streamLengthSeconds: Int

  """The click target of the campaign if it is a promotional campaign."""
  targetPromotionalVideoClicks: Int

  """The URL for the terms and conditions page."""
  termsAndConditionsURL: String

  """The title of the campaign (ie. Stream Breakaway for 1 hour)."""
  title: String!

  """The tracking URLs for this campaign."""
  trackingPixels: [TrackingPixel!]

  """The type of the campaign (ie. PAY_TO_STREAM)."""
  type: BountyCampaignType!

  """The URL of the video for this campaign."""
  videoURL: String @deprecated(reason: "Use 'videos' instead.")

  """The video URLS for the campaign."""
  videos: [BountyCampaignVideo!]
}

"""
Details about a bounty campaign that only the sponsoring brand should see.
"""
type BountyCampaignBrandDetails {
  """
  The list of users (if any) blacklisted for the campaign.
  Limited to 40 users - use totalBlockedBroadcasters for the total count.
  """
  blacklistedBroadcasters: [User!]

  """The multiplier for the broadcaster payout rate."""
  broadcasterMultiplier: Float

  """Reporting data for the campaign."""
  campaignReporting: BountyCampaignReporting

  """The chat Calls to Action for the campaign."""
  chatCTAs: [BountyChatCTA!]

  """The total number of broadcasters who have claimed the bounty."""
  claimedBountyCount: Int @deprecated(reason: "Use 'claimedBountyCount' in 'campaignReporting' instead.")

  """How much of the budget has been claimed (in cents)."""
  claimedBudgetCents: Int @deprecated(reason: "Use 'claimedBudgetCents' in 'campaignReporting' instead.")

  """The total number of broadcasters who have completed the bounty."""
  completedBountyCount: Int @deprecated(reason: "Use 'completedBountyCount' in 'campaignReporting' instead.")

  """The total number of broadcasters who have expanded the bounty."""
  expandedBountyCount: Int @deprecated(reason: "Use 'expandedBountyCount' in 'campaignReporting' instead.")

  """If all broadcasters are targeted for the campaign."""
  includesAllBroadcasters: Boolean

  """If all countries are targeted for the campaign."""
  includesAllCountries: Boolean!

  """If all games are targeted for the campaign."""
  includesAllGames: Boolean!

  """If variety broadcasters are targeted for the campaign."""
  includesVarietyBroadcasters: Boolean!

  """Detailed performance metrics for this campaign."""
  performanceMetrics: [BountyCampaignPerformanceMetric!] @deprecated(reason: "Use 'performanceMetrics' in 'campaignReporting' instead.")

  """Why the campaign was rejected."""
  rejectionReason: String

  """How much of the budget has been spent (completed bounties) (in cents)."""
  spentBudgetCents: Int

  """The status of the campaign."""
  status: BountyCampaignStatus

  """
  Targeted countries for the campaign (represented by ISO 3166-1 alpha-2).
  """
  targetedCountries: [String!]

  """Targeted Games for the campaign."""
  targetedGames: [Game!]

  """The total length of the blacklistedBroadcasters list."""
  totalBlockedBroadcasters: Int

  """The total budget for the campaign (in cents)."""
  totalBudgetCents: Int

  """The number of broadcasters who have viewed the bounty."""
  viewedBountyCount: Int @deprecated(reason: "Use 'viewedBountyCount' in 'campaignReporting' instead.")
}

"""
The chat Call to Action (CTA) that will be created as part of this campaign.
"""
input BountyCampaignChatCTAInput {
  """
  The country that the chat CTA is targeted for (represented by ISO 3166-1 alpha-2).
  """
  countryCode: String!

  """The title for the chat CTA."""
  title: String!

  """The URL for the chat CTA."""
  url: String!
}

"""A list of bounty campaigns related to the subject."""
type BountyCampaignConnection {
  """The campaigns."""
  edges: [BountyCampaignEdge]

  """Information about pagination in this connection."""
  pageInfo: PageInfo!
}

"""
Information about the relationship to the bounty campaign and the subject.
Also includes the campaign itself.
"""
type BountyCampaignEdge {
  """Uniquely identifies this campaign's position in a connection."""
  cursor: Cursor!

  """The campaign."""
  node: BountyCampaign
}

"""A descriptor for a product key."""
type BountyCampaignKeyDescriptor {
  """The platform for the key."""
  platform: String!

  """The region for the key."""
  region: String!
}

"""
Metric containing details about how a campaign performed over a time period.
"""
type BountyCampaignPerformanceMetric {
  """The number of click-throughs from the Chat CTAs of the campaign."""
  chatCTAClickThroughCount: Int

  """The total number of bounties that were completed."""
  completedBountyCount: Int!

  """The end time of this metric."""
  endTime: Time!

  """The total number of minutes watched."""
  minutesWatched: Int!

  """The start time of this metric."""
  startTime: Time!

  """
  The number of viewers that watched at least thirty seconds of the campaign's content.
  """
  thirtySecondViewerCount: Int!

  """The total number of viewers that watched the campaign's content."""
  totalViewerCount: Int!

  """
  The number of viewers that watched at least two minutes of the campaign's content.
  """
  twoMinuteViewerCount: Int!
}

"""
Details about a bounty campaign reporting that only the sponsoring brand should see.
"""
type BountyCampaignReporting {
  """The total number of clicks from chat CTAs from every bounty."""
  chatCTAsClicks: Int

  """The total number of impressions from chat CTAs from every bounty."""
  chatCTAsImpressions: Int

  """The total number of broadcasters who have claimed the bounty."""
  claimedBountyCount: Int

  """How much of the budget has been claimed (live bounties) (in cents)."""
  claimedBudgetCents: Int

  """The total number of broadcasters who have completed the bounty."""
  completedBountyCount: Int

  """The total number of broadcasters who have expanded the bounty."""
  expandedBountyCount: Int

  """Detailed performance metrics for this campaign."""
  performanceMetrics: [BountyCampaignPerformanceMetric!]

  """How much of the budget has been spent (completed bounties) (in cents)."""
  spentBudgetCents: Int

  """The number of broadcasters who have viewed the bounty."""
  viewedBountyCount: Int
}

"""The status of a bounty campaign."""
enum BountyCampaignStatus {
  """The campaign is pending approval."""
  PENDING

  """The campaign has been approved."""
  APPROVED

  """The campaign has been rejected."""
  REJECTED

  """The campaign is live."""
  LIVE

  """The campaign is done."""
  COMPLETED
}

"""Represents the type of the campaign."""
enum BountyCampaignType {
  """A user is paid to stream themselves playing a game."""
  PAY_TO_STREAM

  """A user is paid to stream a game trailer."""
  GAME_TRAILER

  """A user is paid to stream a non-game trailer (ie. a movie trailer)."""
  MISC_TRAILER

  """Invalid campaign type."""
  UNKNOWN
}

"""Possible upload types for bounty campaigns."""
enum BountyCampaignUploadType {
  """Upload type related to the box art image."""
  BOX_ART

  """Upload type related to the cover image."""
  COVER
}

"""A video for a bounty board campaign."""
type BountyCampaignVideo {
  """
  The country that the video is targeted for (represented by ISO 3166-1 alpha-2).
  """
  country: String!

  """The title of the video."""
  title: String!

  """The URL of the video."""
  url: String!
}

"""The video that will be created as part of this campaign."""
input BountyCampaignVideoInput {
  """
  The country that the video is targeted for (represented by ISO 3166-1 alpha-2).
  """
  country: String!

  """The title of the video."""
  title: String!

  """The URL of the video."""
  url: String!
}

"""
A chat Call to Action (CTA) that will be trigger in the broadcaster chat while doing the bounty.
"""
type BountyChatCTA {
  """
  The country targeted for the chat CTA (represented by ISO 3166-1 alpha-2).
  """
  countryCode: String!

  """The time (in seconds) between each appearance of the chat CTA."""
  frequencySeconds: Int!

  """The initial delay (in seconds) before the first chat CTA."""
  initialDelaySeconds: Int!

  """The title of the chat CTA."""
  title: String!

  """The URL of the chat CTA."""
  url: String!
}

"""A list of bounty related to the subject."""
type BountyConnection {
  """The bounties."""
  edges: [BountyEdge!]

  """Information about pagination in this connection."""
  pageInfo: PageInfo!
}

"""
Information about the relationship to the bounty and the subject.
Also includes the bounty itself.
"""
type BountyEdge {
  """Uniquely identifies this bounty's position in a connection."""
  cursor: Cursor!

  """The bounty."""
  node: Bounty
}

"""Represents all the currently possible key product types."""
enum BountyKeyProductType {
  """The key is a coupon code."""
  COUPON

  """The key is for downloadable content or a game expansion."""
  DLC

  """The key is a game code."""
  GAME

  """The key is for a gift card."""
  GIFTCARD

  """The key is a code for a giveaway."""
  GIVEAWAY

  """The key is for in game content - character skins, customization, etc."""
  IGC

  """The key is for something else."""
  OTHER
}

"""The reason why bounty failed moderation."""
enum BountyModerationFailReason {
  """
  Moderation failed because broadcast does not meet minimal stream length requirement.
  """
  MINIMUM_TIME_NOT_MET

  """Moderation failed because broadcast is not with required content."""
  INCORRECT_CONTENT

  """Moderation failed because broadcaster did badmouthing during stream."""
  BADMOUTHING

  """
  Moderation failed because other content layered over/under required content.
  """
  OTHER_CONTENT_VISIBLE

  """
  Moderation failed because broadcaster had exessive idle time during sponsored stream.
  """
  IDLE

  """Moderation failed because missing sponsored stream VOD."""
  NO_VOD

  """Other reason caused moderation failed."""
  OTHER
}

"""
Bounty Moderation metadata includes moderation metadata for a specific bounty.
"""
type BountyModerationMetadata {
  """The moderation fail reason of the bounty."""
  reason: BountyModerationFailReason

  """The moderation status of the bounty."""
  status: BountyModerationStatus

  """When the bounty was last moderated."""
  updatedAt: Time
}

"""The moderation status of the bounty."""
enum BountyModerationStatus {
  """The bounty has passed the moderation check."""
  PASS

  """The bounty is waiting for moderation check."""
  PENDING_REVIEW

  """The bounty has failed the moderation check."""
  FAIL
}

"""A key that can be redeemed for a product."""
type BountyProductKey {
  """The code that is used to redeem the product."""
  code: String!

  """The platform where the code is redeemed."""
  platform: String

  """The product type of the key - GAME, DLC, GIVEAWAY, GIFTCARD, etc."""
  productType: BountyKeyProductType

  """
  The region where the code can be redeemed. The format and granularity of this field varies
  depending on the product key vendor.
  """
  region: String
}

"""Defines the restrictions that are placed on a bounty."""
type BountyRestriction {
  """
  The days of the week that a bounty can be completed on. The values are from 0
  to 6, representing day of the week from Monday to Sunday.
  """
  days: [Int!]

  """
  The end of the time period that a bounty can be completed in. This is in 24-hour clock notation, so 2100 means 9 PM UTC.
  """
  endTime: Int

  """
  The start of the time period that a bounty can be completed in. This is in
  24-hour clock notation, so 1000 means 10 AM UTC.
  """
  startTime: Int
}

"""Represents all the possible bounty statuses."""
enum BountyStatus {
  """The bounty can be claimed by the user."""
  AVAILABLE

  """The bounty has been claimed by the user and is in progress."""
  LIVE

  """The bounty was completed successfully."""
  COMPLETED

  """The bounty was cancelled before it was completed."""
  CANCELLED
}

"""
A video that the broadcaster must play on stream to complete the bounty.
"""
type BountyVideo {
  """The title of the video."""
  title: String!

  """The URL of the video."""
  url: String!
}

"""
Brand portal settings configure how a company can interact with the brand portal.
"""
type BrandPortalSettings {
  """
  This determines whether or not a company can access all games in brand portal.
  """
  canAccessAllGames: Boolean!

  """This determines whether or not a company can access the Brand Portal."""
  isEnabled: Boolean!
}

"""A historical representation of a live stream."""
type Broadcast {
  """The game which was last streamed during the broadcast."""
  game: Game

  """The broadcast's unique identifier."""
  id: ID

  """When the broadcast started."""
  startedAt: Time

  """The title of the broadcast."""
  title: String
}

"""An indicator of the viewer reach for a pool of a broadcasters."""
type BroadcasterViewerReach {
  """Range of the number of broadcasters in the pool."""
  broadcasterPool: Range!

  """Range of minutes watched for this bounty campaign."""
  minutesWatched: Range!

  """Range of total viewers across the broadcaster pool."""
  viewerPool: Range!
}

"""BroadcastFormat is type of ingest live sessions."""
enum BroadcastFormat {
  """
  Default live stream. Primary session for the backup session will be shown as live.
  """
  LIVE

  """Stream with intentional delays requested by the broadcaster."""
  DELAY

  """Primary session which backup session was stitched back to."""
  BACKUP_000

  """First backup session."""
  BACKUP_001

  """Second backup session."""
  BACKUP_002

  """Third backup session."""
  BACKUP_003
}

"""Settings for a User's broadcast that persist between streams."""
type BroadcastSettings {
  """
  The game that the user has set as their current game. This will influence what
  the game field on a Streams object is when the User starts streaming.
  """
  game: Game

  """
  The broadcast setting's unique identifier.
  This happens to be the same as the User's ID, but should not be assumed to have any meaning.
  """
  id: ID!

  """
  A flag indicating if the user's broadcast is intended for mature audiences only.
  """
  isMature: Boolean!

  """
  The primary language that the user has configured for their broadcasts. The
  default value is "", when the user has not indicated a primary language.
  """
  language: Language!

  """
  The text that will be in the notification that sends when the user starts broadcasting.
  The default value is "<user> went live!", when the user has not set a custom value.
  """
  liveUpNotification: String @deprecated(reason: "Use liveUpNotificationInfo instead.")

  """The information about the live up notification of a user."""
  liveUpNotificationInfo: LiveUpNotificationInfo

  """
  The title of the user's broadcast. The default value is "", when the user has not indicated a title.
  """
  title: String!
}

"""
Describes from which source the video originated.
NOTE: Should have been named VideoBroadcastType.
"""
enum BroadcastType {
  """If the video is of a past broadcast, it's an ARCHIVE."""
  ARCHIVE

  """When the video is a subsection of a past broadcast, it's a HIGHLIGHT."""
  HIGHLIGHT

  """
  (Legacy) When the video is directly uploaded to Twitch via the upload tool, it's an UPLOAD.
  """
  UPLOAD

  """
  When the video is directly uploaded to Twitch via the video manager, it's an PREMIERE_UPLOAD.
  """
  PREMIERE_UPLOAD

  """
  When a video has been premiered on Twitch and is saved, it's a PAST_PREMIERE.
  """
  PAST_PREMIERE
}

"""Associated metrics for the "Build a Community" quest."""
type BuildACommunity {
  """Image URL for the quest's badge."""
  badgeURL: String

  """Time that this quest was completed."""
  completedAt: Time

  """Number of followers needed to complete the quest."""
  followers: QuestGoalInt

  """Number of Unique Chatters needed to complete the quest."""
  uniqueChatters: QuestGoalInt
}

"""Required input to bulk approve a list of unban requests on a channel."""
input BulkApproveUnbanRequestInput {
  """IDs of the unban requests to be approved."""
  ids: [ID!]!
}

"""Result of bulk approving unban requests."""
type BulkApproveUnbanRequestPayload {
  """Used for errors arising from bulk approving unban requests."""
  error: UnbanRequestError

  """The approved unban requests."""
  unbanRequests: [UnbanRequest!]
}

"""Required input to deny a list of unban requests on a channel."""
input BulkDenyUnbanRequestInput {
  """IDs of the unban requests to be denied."""
  ids: [ID!]!
}

"""Result of bulk denying unban requests."""
type BulkDenyUnbanRequestPayload {
  """Used for errors arising from bulk denying unban requests."""
  error: UnbanRequestError

  """The denied unban requests."""
  unbanRequests: [UnbanRequest!]
}

"""A visible campaign on a given user's channel."""
type Campaign {
  """The domain that campaign belongs to."""
  domain: String!

  """The time the campaign ends being active."""
  endDate: Time!

  """Unique identifier for the campaign."""
  id: ID!

  """The objectives users can progress in within this campaign."""
  objectives: [CampaignObjective!]!

  """The time the campaign becomes active."""
  startDate: Time!
}

"""
This type holds the information about the grouping of objectives. Each group has
a list of cheermotes that progress objectives in this particular group.
"""
type CampaignCheergroup {
  """
  A list of upper cased cheermotes that can advance objectives belonging to this group.
  """
  cheerCodes: [String!]!

  """An a parent group this cheer group belongs to (e.g. "North America")."""
  division: String

  """
  A url to the image representing this group (e.g. team icon in esports context).
  """
  imageUrl: String!

  """A name representing this group (e.g. team name in esports context)."""
  name: String!
}

"""
CampaignDiscoveryEventType contains the different types of discovery events that campaign objectives can track.
"""
enum CampaignDiscoveryEventType {
  """An event describing a user's interaction with the command center."""
  ENGAGE_COMMAND_CENTER

  """An event describing a user's interaction with a stream."""
  ENGAGE_STREAM
}

"""
This type holds information about a campaign objective, which belongs to a campaign.
An objective can hold multiple milestones which users can hit and get rewards.
An objective can hold a cheer group.
"""
type CampaignObjective {
  """Cheergroup this objective might belong to."""
  cheergroup: CampaignCheergroup

  """Short description about the objective."""
  description: String!

  """Unique identifier for the objective."""
  id: ID!

  """If the objective belongs to an active parent campaign."""
  isActive: Boolean!

  """Milestones users can hit by advancing this objective."""
  milestones: [Milestone!]

  """User's participation towards the objective."""
  participation: Int!

  """Global progress for the objective."""
  progress: Int!

  """
  The type of objective this is for. It can be either INDIVIDUAL or GLOBAL (TEAM is deprecated).
  """
  tag: String!

  """Short title for the objective."""
  title: String!
}

"""All Campaign properties that are running for a given user."""
type CampaignProperties {
  """All the current active campaigns for a given user."""
  activeCampaigns: [String!]

  """All the current domains a user is participating in."""
  domains: [String!]

  """
  Determines whether or not a user has a pass they can sell on their channel.
  """
  hasPass: Boolean!

  """
  Objectives users can progress within all the active campaigns for the first domain.
  """
  objectives: [CampaignObjective!]

  """
  Triggers users can activate to get / give rewards within this campaign.
  """
  triggers: [CampaignTrigger!]
}

"""
Metadata for the reward that only impacts how the rewards are rendered on the front end apps.
"""
type CampaignRewardMetadata {
  """Whether the reward is initially unavailable upon redeeming."""
  isPending: Boolean! @deprecated

  """
  Reward subtype usually specific to the game the campaign belongs to (e.g. skin, spray, etc).
  """
  subType: String @deprecated
}

"""
This type holds information about a campaign trigger, which belongs to a campaign.
A trigger has a list of rewards that can be earned by various one time events.
"""
type CampaignTrigger {
  """Short description about the trigger."""
  description: String!

  """Unique identifier for the trigger."""
  id: ID!

  """Whether the trigger is currently active."""
  isActive: Boolean!

  """List of rewards attached to this trigger."""
  rewards: [TournamentReward!]

  """Short title for the trigger."""
  title: String!

  """
  Maximum amount of trigger quantity required for the trigger (e.g. # of bits in cheer).
  """
  triggerAmountMax: Int!

  """
  Minimum amount of trigger quantity required for the trigger (e.g. # of bits in cheer).
  """
  triggerAmountMin: Int!

  """String defining the trigger type (e.g. CHEER)."""
  triggerType: TriggerType!
}

"""The type of the campaign."""
enum CampaignType {
  """
  The default campaign type that allows all drop types but manual_triggers.
  """
  DEFAULT

  """
  The manual trigger campaign type only allows for manual trigger type drops.
  """
  MANUAL_TRIGGER_BASED
}

"""Error code for an error that occurs while canceling the active boosts."""
type CancelActiveBoostOrdersError {
  """Error code for error that occurred while canceling the active boosts."""
  code: CancelActiveBoostOrdersErrorCode!
}

"""Error types recognized."""
enum CancelActiveBoostOrdersErrorCode {
  """Invalid parameter in the request."""
  INVALID_PARAMETER

  """Internal error being returned from service."""
  INTERNAL_ERROR
}

"""The required input for a cancelActiveBoostOrdersInput mutation."""
input CancelActiveBoostOrdersInput {
  """The Id of the channel for which we want to cancel boosts."""
  channelID: ID!
}

"""Data that was mutated after canceling the active boosts."""
type CancelActiveBoostOrdersPayload {
  """The possible error returned from the service."""
  error: CancelActiveBoostOrdersError
}

"""Error code for an error that occurs while canceling the bounty."""
type CancelBountyError {
  """Error code for error that occurred while canceling the bounty."""
  code: CancelBountyErrorCode!
}

"""Error types recognized."""
enum CancelBountyErrorCode {
  """Invalid parameter in the request."""
  INVALID_PARAMETER

  """Bounty isn't live, thus cannot be canceled."""
  BOUNTY_NOT_LIVE

  """Unknown error being returned from service."""
  UNKNOWN_ERROR
}

"""CancelBountyInput includes the bounty a user is trying to cancel."""
input CancelBountyInput {
  """Unique Identifier for the bounty."""
  bountyID: ID!

  """Reason that the user canceled the bounty."""
  reason: String

  """UserID of the user that will cancel the bounty."""
  userID: ID!
}

"""Data that was mutated after canceling the bounty."""
type CancelBountyPayload {
  """The canceled bounty with the updated status."""
  bounty: Bounty

  """The possible error returned from the service."""
  error: CancelBountyError

  """The user that now has the canceled bounty."""
  user: User
}

input CancelFriendRequestInput {
  """
  The authenticated user will cancel the friend request sent to the user with an ID equal to targetID.
  """
  targetID: ID!
}

type CancelFriendRequestPayload {
  """The user whose friend request was just cancelled."""
  user: User
}

"""
Describes the conditions around a user's cancellation of their purchase (e.g. refund policy).
"""
enum CancellationPolicyType {
  """The product is not refundable."""
  NON_REFUNDABLE

  """The product is refundable."""
  REFUNDABLE
}

"""
CancelPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding.
"""
input CancelPayoutOnboardingWorkflowInput {
  """TargetUserID is the ID of the user whose workflow will be started."""
  targetUserID: ID!
}

"""
CancelPayoutOnboardingWorkflowPayload is the payload returned after canceling a payout onboarding workflow.
"""
type CancelPayoutOnboardingWorkflowPayload {
  """A new workflow status."""
  workflow: PayoutOnboardingWorkflow
}

"""An error returned from the cancelPredictionEvent mutation."""
type CancelPredictionEventError {
  """Code describing the error."""
  code: CancelPredictionEventErrorCode!
}

"""Possible error codes from the cancelPredictionEvent mutation."""
enum CancelPredictionEventErrorCode {
  """The current user is forbidden from cancelling this Prediction Event."""
  FORBIDDEN

  """
  This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken.
  """
  EVENT_ENDED

  """An unknown error occurred."""
  UNKNOWN
}

"""
Input for canceling a Prediction Event (and refunding all users who have contributed).
"""
input CancelPredictionEventInput {
  """The unique identifier of the Prediction Event to cancel."""
  id: ID!
}

"""Payload for canceling a Prediction Evnet."""
type CancelPredictionEventPayload {
  """If present, there was an error with the request."""
  error: CancelPredictionEventError

  """The canceled Prediction Event."""
  predictionEvent: PredictionEvent
}

"""CancelRaidError is the error associated with a cancelRaid."""
type CancelRaidError {
  """The associated error code."""
  code: CancelRaidErrorCode!
}

"""
CancelRaidErrorCode are the possible errors that this mutation returns.
"""
enum CancelRaidErrorCode {
  """The a raid does not exist."""
  RAID_DOES_NOT_EXIST

  """The request is missing valid channel parameters."""
  INVALID_CHANNEL

  """The user tries to unraid without an active raid."""
  NO_ACTIVE_RAID
}

"""Inputs to the cancelRaid mutation."""
input CancelRaidInput {
  """Source ID."""
  sourceID: ID!
}

"""Outputs from the cancelRaid mutation."""
type CancelRaidPayload {
  """The possible error returned from the service."""
  error: CancelRaidError

  """The cancelled raid."""
  raid: Raid
}

"""
Inputs for the mutation. Gift to be canceled by productID and originID.
"""
input CancelSubscriptionGiftInput {
  """originID is the origin id created during the gift purchase."""
  originID: ID!

  """productID is the ticket product id for this gift."""
  productID: ID!
}

"""
The returned payload from the mutation for canceling a Subscription Gift.
"""
type CancelSubscriptionGiftPayload {
  """SubscriptionGift object that was deleted."""
  gift: SubscriptionGift
}

"""Required input to cancel an unban request."""
input CancelUnbanRequestInput {
  """ID of the unban request to be canceled."""
  id: ID!
}

"""Result of canceling an unban request."""
type CancelUnbanRequestPayload {
  """Used for errors arising from canceling the unban request."""
  error: UnbanRequestError

  """The canceled unban request."""
  unbanRequest: UnbanRequest
}

"""The status of a chat message."""
enum CaughtMessageStatus {
  """INVALID status."""
  INVALID

  """The caught message is approved by a mod."""
  ALLOWED

  """The caught message is denied by a mod."""
  DENIED

  """The caught message is pending for a while and now it's expired."""
  EXPIRED

  """The caught message is pending review."""
  PENDING
}

"""CCPA cookie vendor for a user."""
type CCPACookieVendor {
  """User content status for each vendor."""
  consentStatus: ConsentStatus!

  """
  A flag that shows if the consent is given by the user or by consent service as default value.
  """
  hasUserSetConsent: Boolean!

  """A flag that shows if the vendor should be visible to management page."""
  isVisible: Boolean!

  """Vendor name."""
  name: VendorName!
}

"""List of CCPA cookie vendors."""
type CCPAVendorConsent {
  """status for vendors."""
  status: [CCPACookieVendor!]!
}

"""
Celebration is a configuration that denotes when a celebration is triggerd and
when sort of celebration will show when it triggers.
"""
type Celebration {
  """Area of the channel page in which the celebration will appear."""
  area: CelebrationArea!

  """Duration which the celebration will play."""
  durationMilliseconds: Int!

  """Effect which will be shown when then celebration is triggered."""
  effect: CelebrationEffect!

  """
  Amount that needs to be met in order to trigger this celebration.
  For example, when the event type is subscription gift, this value will
  determine how many gifts must be given at a single time to trigger the
  celebration.
  """
  eventThreshold: Int!

  """Type of event which will trigger this celebration."""
  eventType: CelebrationEventType!

  """Unique identifier for the celebration."""
  id: ID!

  """
  Intensity of the celebration.
  Should be bounded (TBA) value which will determine the spectacle of the celebration.
  """
  intensity: Int!

  """If true, the celebration is enabled."""
  isEnabled: Boolean!
}

"""Area in which the celebration will show."""
enum CelebrationArea {
  """Celebration will show everywhere over the channel page."""
  EVERYWHERE

  """Celebration will show only over the video."""
  VIDEO_ONLY

  """Celebration will show over the video and panel."""
  VIDEO_AND_PANEL

  """Unknown celebration area."""
  UNKNOWN
}

"""The channels configuration of celebrations."""
type CelebrationConfig {
  """List of celebrations for this channel."""
  celebrations: [Celebration!]!

  """The identifier for the celebration config."""
  id: ID!

  """If celebrations are enabled on this channel."""
  isEnabled: Boolean!
}

"""Type of effect that can show during a celebration."""
enum CelebrationEffect {
  """Will show fireworks when the celebration triggers."""
  FIREWORKS

  """Will show an emote rain when the celebration triggers."""
  RAIN

  """Will show an flamethrowers when the celebration triggers."""
  FLAMETHROWERS

  """Unknown effect."""
  UNKNOWN
}

"""Celebration error."""
type CelebrationError {
  """Code describing the error."""
  code: CelebrationErrorCode!
}

"""Vote in celebration error code."""
enum CelebrationErrorCode {
  """Attempted to preform operation on celebration that does not exist."""
  CELEBRATION_NOT_FOUND

  """A celebration with that same event type and threshold already exists."""
  CELEBRATION_ALREADY_EXISTS

  """Requesting user does not have permission."""
  PERMISSION_DENIED

  """The user has reached the limit (20) of celebrations they can have."""
  OVER_CELEBRATION_LIMIT

  """An unknown error occurred."""
  UNKNOWN
}

"""Type of event that can trigger a celebration."""
enum CelebrationEventType {
  """Cheering with bits."""
  BITS_CHEER

  """Gifting subscriptions to other users."""
  SUBSCRIPTION_GIFT

  """Unknown event type."""
  UNKNOWN
}

"""Type of intensity of a celebration."""
enum CelebrationIntensity {
  """A small intensity celebration."""
  SMALL

  """A medium intensity celebration."""
  MEDIUM

  """A large intensity celebration."""
  LARGE

  """Unknown intensity."""
  UNKNOWN
}

"""A celebration product that a user may purchase."""
type CelebrationProduct implements ProductCatalogItem {
  """
  A list of benefits the user will receive when purchasing the celebration product.
  """
  benefits: [ProductCatalogBenefit!]

  """A description of the product."""
  description: String

  """The identifier of the celebration product."""
  id: ID!

  """The intensity of the celebration product."""
  intensity: CelebrationIntensity!

  """
  Indicates if the celebration product is enabled for purchase in the channel.
  """
  isEnabled: Boolean!

  """A list of offers available for purchasing this celbration product."""
  offers: [Offer!]

  """The owner (ex: channel) of the celebration product."""
  owner: ID!

  """
  A list of potential offers that a broadcaster could set for purchasing this celebration product.
  """
  potentialOffers: [Offer!]

  """The title of the product."""
  title: String!
}

"""
A celebration product benefit the user will receive when purchasing the celebration product.
"""
type CelebrationProductBenefit implements ProductCatalogBenefit {
  """The identifier of the celebration product benefit."""
  id: ID!
}

"""Configuration settings to change for a celebration product."""
input CelebrationProductConfigInput {
  """The intensity of the celebration product."""
  intensity: CelebrationIntensity!

  """If the celebration product is enabled for purchase in the channel."""
  isEnabled: Boolean

  """
  ID of the offer (i.e. price) through which the celebration can be purchased in the channel.
  """
  offerID: ID
}

"""A container for celebration settings for the logged in user."""
type CelebrationUserSettings {
  """
  A boolean flag that denotes if the user has opted out of seeing celebrations.
  """
  isOptedOut: Boolean!
}

"""A condition to be satisfied by a specific owner."""
type ChallengeCondition {
  """When the condition was created."""
  createdAt: Time

  """
  Settings that define how the effects of the condition participants associated with this condition will be processed.
  """
  effectSettings: [ChallengeEffectSettings!]

  """Unique ID of the condition."""
  id: ID!

  """The name of the condition."""
  name: String!

  """The user who creates and owns the condition."""
  owner: User

  """A summary of condition participants attached to the condition."""
  participantSummary: ChallengeConditionParticipantSummaryByState

  """The current state of the condition."""
  state: ChallengeConditionState!

  """The list of effect types supported by this condition."""
  supportedEffects: [ChallengeEffectType!]!

  """When the condition times out."""
  timeoutAt: Time

  """When the condition was last modified."""
  updatedAt: Time

  """Whether the condition becomes inactive once it has been satisfied."""
  willDisableWhenSatisfied: Boolean!
}

"""
A condition participant action that will be taken if an associated condition is satisfied.
"""
type ChallengeConditionParticipant {
  """The associated condition."""
  condition: ChallengeCondition

  """The effect that will occur if the condition participant is satisfied."""
  effect: ChallengeEffect!

  """Final state of the condition participant."""
  endState: ChallengeConditionParticipantEndState!

  """Unique ID of the condition participant."""
  id: ID!

  """The user who creates and owns the condition participant."""
  owner: User

  """
  Whether or not the condition participant was successfully processed upon condition completion.
  """
  processingState: ChallengeConditionParticipantProcessingState!
}

"""Final state of the condition participant."""
enum ChallengeConditionParticipantEndState {
  """Pending completion of associated condition."""
  PENDING

  """Associated condition expired."""
  CONDITION_EXPIRED

  """Associated condition was canceled."""
  CONDITION_CANCELED

  """Associated condition was satisfied."""
  CONDITION_SATISFIED

  """
  Condition participant expired before associated condition could be satisfied.
  """
  EXPIRED

  """Condition participant was canceled."""
  CANCELED

  """Condition participant failed validation prior to being processed."""
  FAILED_VALIDATION

  """Unknown state."""
  UNKNOWN
}

"""
Whether or not the condition participant was successfully processed upon condition completion.
"""
enum ChallengeConditionParticipantProcessingState {
  """Pending completion of associated condition."""
  PENDING

  """Condition participant processed successfully."""
  SUCCESS

  """Error processing condition participant."""
  ERROR

  """Unknown state."""
  UNKNOWN
}

"""
A summary of participants attached to a particular condition in a particular state.
"""
type ChallengeConditionParticipantSummary {
  """
  Summary of participant effects attached to a particular condition in a particular state.
  """
  effects: ChallengeEffectSummary

  """
  Total count of participants attached to a particular condition in a particular state.
  """
  total: Int!
}

"""
A summary of condition participants attached to a particular condition, grouped by state.
"""
type ChallengeConditionParticipantSummaryByState {
  """
  Summary of participants attached to a particular condition in the CANCELED state.
  """
  canceled: ChallengeConditionParticipantSummary

  """
  Summary of participants attached to a particular condition in the CONDITION_CANCELED state.
  """
  conditionCanceled: ChallengeConditionParticipantSummary

  """
  Summary of participants attached to a particular condition in the CONDITION_TIMEOUT state.
  """
  conditionTimeout: ChallengeConditionParticipantSummary

  """
  Summary of participants attached to a particular condition in the FAILED_VALIDATION state.
  """
  failedValidation: ChallengeConditionParticipantSummary

  """
  Summary of participants attached to a particular condition in the PENDING state.
  """
  pending: ChallengeConditionParticipantSummary

  """
  Summary of participants attached to a particular condition in the SATISFIED state.
  """
  satisfied: ChallengeConditionParticipantSummary

  """
  Summary of participants attached to a particular condition in the TIMEOUT state.
  """
  timeout: ChallengeConditionParticipantSummary

  """Total count of participants attached to a particular condition."""
  total: Int!
}

"""The current state of the condition."""
enum ChallengeConditionState {
  """New condition participants can be associated with this condition."""
  ACTIVE

  """
  Condition was manually terminated. New condition participants cannot be associated.
  """
  CANCELED

  """
  Condition was satisfied for the final time. New condition participants cannot be associated with this condition.
  """
  INACTIVE

  """
  Condition was automatically terminated. New condition participants cannot be associated.
  """
  EXPIRED

  """Unknown state."""
  UNKNOWN
}

"""
An effect that will occur if a challenge condition participant is satisfied.
"""
type ChallengeEffect {
  """Details of the effect."""
  details: ChallengeEffectDetails!

  """The type of effect."""
  type: ChallengeEffectType!
}

"""Details of the effect."""
union ChallengeEffectDetails = ChallengeUseBitsEffectDetails

"""
Settings that define how effects will be processed when a condition is satisfied.
"""
type ChallengeEffectSettings {
  """Details of the effect settings."""
  details: ChallengeEffectSettingsDetails!

  """The type of effect."""
  type: ChallengeEffectType!
}

"""Details of the effect settings."""
union ChallengeEffectSettingsDetails = ChallengeUseBitsEffectSettingsDetails

"""
A summary of effects attached to a particular condition in a particular state. Keys correspond to ChallengeEffectType enum.
"""
type ChallengeEffectSummary {
  """USE_BITS effects."""
  useBits: ChallengeUseBitsEffectSummary
}

"""The type of effect."""
enum ChallengeEffectType {
  """Type of effect that results in using a user's bits."""
  USE_BITS

  """Unknown type."""
  UNKNOWN
}

"""Details of the UseBits effect."""
type ChallengeUseBitsEffectDetails {
  """The user who uses the bits."""
  benefactor: User

  """The amount of bits to be used."""
  bitsAmount: Int!
}

"""Details of the UseBits effect settings."""
type ChallengeUseBitsEffectSettingsDetails {
  """
  A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
  """
  bitsRecipientWeightedShares: [ChallengeUseBitsPoolRecipientWeightedShare!]!
}

"""
A summary of USE_BITS effects attached to a particular condition in a particular state.
"""
type ChallengeUseBitsEffectSummary {
  """
  Sum of Bits rolling up to a particular condition in a particular state.
  """
  totalBitsAmount: Int!

  """
  Total count of USE_BITS effects rolling up to a particular condition in a particular state.
  """
  totalEffects: Int!
}

"""
ChallengeUseBitsPoolRecipientWeightedShare represents the weighted share of the total bits pool
that a recipient user is entitled to upon condition satisfaction.
"""
type ChallengeUseBitsPoolRecipientWeightedShare {
  """The bits recipient user."""
  recipient: User

  """
  The weight of the recipient's share from the total bits pool. The sum of all the recipients' weights
  dictates the proportion that a particular recipient receives from the pool
  (shareWeight/totalShareWeight * totalBitsAmountInPool).
  """
  weight: Int!
}

"""
ChangelogEntry is an entry that displays new items and notifications in the creator homepage changelog.
"""
type ChangelogEntry {
  """content is localized text content for the changelog entry."""
  content: String!

  """iconURL is the url for the entry's icon image."""
  iconURL: String!

  """id is a unique human readable slug for the entry e.g. "squad-stream"."""
  id: ID!

  """linkText is the text that the linkURL should display."""
  linkText: String

  """linkURL is an optional link for more content for this changelog entry."""
  linkURL: String

  """
  position is where entry should be located within changelog entries of the same date.
  """
  position: Int!

  """publishedAt is the timestamp that the changelog entry was published."""
  publishedAt: Time

  """title is the localized title of the changelog entry."""
  title: String!
}

"""Error returned during an invalid change username request."""
type ChangeUsernameCodeError {
  """Error code returned by the backend."""
  code: ChangeUsernameErrorCode!
}

"""Possible error codes returned from a change username."""
enum ChangeUsernameErrorCode {
  """Sudo token expired, prompt the user to log in again."""
  REAUTH_NEEDED

  """Too many attempts to update login."""
  REQUESTS_THROTTLED

  """Login was changed recently (last 60 days)."""
  LOGIN_CHANGE_COOLDOWN

  """Login is not available."""
  LOGIN_UNAVAILABLE

  """Login is too short."""
  LOGIN_TOO_SHORT

  """Login is too long."""
  LOGIN_TOO_LONG

  """Login contains characters that are not allowed."""
  LOGIN_CONTAINS_INVALID_CHARACTERS

  """Login change requires a verified email."""
  LOGIN_CHANGE_EMAIL_VERIFIED

  """Unrecognized error returned from the backend service."""
  UNKNOWN_ERROR
}

"""Input for a change username."""
input ChangeUsernameInput {
  """The new login for the user."""
  login: String!

  """User id of the user being updated."""
  userID: ID!
}

"""The result of a change username."""
type ChangeUsernamePayload {
  """Error code for error returned from change username."""
  error: ChangeUsernameCodeError

  """The modified user."""
  user: User
}

"""
ChanletSort indicates the desired order of chanlets in the list returned by LoadChanletsByUserID.
"""
enum ChanletSort {
  """
  ChanletSortNone indicates that the order of chanlets returned is insignificant
  to the client and is allowed to be arbitrary.
  """
  NONE

  """
  ChanletSortViewerCount indicates chanlets should return sorted by viewer counts, descending.
  """
  VIEWER_COUNT
}

"""A User's place on Twitch."""
type Channel {
  """All Prediction Events that are actively accepting new predictions."""
  activePredictionEvents: [PredictionEvent!]

  """A mapping of AutoMod categories to levels."""
  autoModConfiguration: AutoModConfiguration

  """
  A list of content attributes created for the channel, that can be associated
  with the chanlets, to augment the multi-view experience.
  """
  availableContentAttributes: [MultiviewContentAttribute!]

  """
  A list of available Drops that viewers of this channel can claim when certain game events are met.
  """
  availableDrops: [DropObject] @deprecated(reason: "use channel.viewerDropCampaigns")

  """A paginated list of users who are banned from this channel."""
  bannedUsers(after: Cursor, first: Int = 25): ChannelBannedUserConnection

  """The boost settings for the channel."""
  boostSettings: BoostSettings

  """The language the broadcaster has chosen to stream in."""
  broadcasterLanguage: String! @deprecated(reason: "Use stream.language instead.")

  """
  The celebration configuration for the channel, which contains if celebrations
  are enabled and a list of configured celebrations.
  """
  celebrations: CelebrationConfig

  """
  The stream key for this channel if it is a multi-view chanlet. The requesting
  user must "own" this chanlet to be authorized to see this.
  """
  chanletStreamKey: String

  """
  A list of the channel's chanlets (sub-channels) in a multi-view experience.
  """
  chanlets(sort: ChanletSort = NONE, bypassDisableFlag: Boolean = false): [Channel!]

  """Get the chatters on this channel."""
  chatters: ChattersInfo

  """The clip settings for a channel, includes settings on clip creation."""
  clipsSettings: ChannelClipsSettings

  """Get a single community points custom reward redemption by its ID."""
  communityPointsCustomRewardRedemption(id: ID!): CommunityPointsCustomRewardRedemption

  """
  The queue of community points custom reward redemptions in this channel.
  """
  communityPointsRedemptionQueue(first: Int = 10, after: Cursor, options: CommunityPointsRedemptionQueueOptions): CommunityPointsCustomRewardRedemptionConnection

  """Details about community points in the channel."""
  communityPointsSettings: CommunityPointsChannelSettings

  """
  For a multi-view chanlet, this is the list of content attributes that have been associated with the given chanlet.
  """
  contentAttributes: [MultiviewContentAttribute!]

  """
  The channel's badge flair setting and assets that are available to eligible subscribers.
  """
  creatorBadgeFlair: CreatorBadgeFlair

  """Fetch the requesting user's currently playing radio content."""
  currentRadioTrack: RadioCurrentlyPlaying

  """
  Returns configurations for a dashboard view in different parts of Twitch, such as Stream Manager
  or Twitch Studio. Includes configurations for things like layout and other features.
  """
  dashboardView(type: ChannelDashboardViewType!): ChannelDashboardView!

  """The channel's name, with user-specified formatting."""
  displayName: String

  """
  A drop 2.0 campaign including personal settings (e.g. account connection status). (Streamer dashboard individual item).
  """
  dropCampaign(id: ID!): DropCampaign

  """
  A list of all available Drops 2.0 campaigns that a channel is eligible to participate in. (Streamer dashboard list).
  """
  dropCampaigns: [DropCampaign!]

  """
  founderBadgeAvailability is a number of available slots for Founder Badge entitlement.
  """
  founderBadgeAvailability: Int!

  """The name of the last game played on this channel."""
  game: String! @deprecated(reason: "Use user.lastBroadcast.game.name instead.")

  """The Home of a channel."""
  home: ChannelHome

  """
  The structure that contains information about the channel's Hype Train execution and config.
  """
  hypeTrain: HypeTrain!

  """The channel's unique identfier."""
  id: ID!

  """
  A setting which states whether or not users can create Clips on this channel.
  By default, clipping on a channel is enabled.
  """
  isClipsEnabled: Boolean! @deprecated(reason: "Use channel.clipsSettings instead.")

  """
  Whether or not the channel is a hidden multi-view chanlet that is only meant
  to be accessible through another channel and not exist as a completely
  independent channel.
  """
  isHiddenChanlet: Boolean!

  """
  Whether the broadcaster has designated the channel's broadcast for mature audiences only.
  """
  isMature: Boolean! @deprecated(reason: "Use stream.isMature instead.")

  """Whether the channel has opted out of drops."""
  isOptedOutOfDrops: Boolean

  """Whether the channel is using the new AutoMod vendor for enforcement."""
  isMemberOfAutoModRollout: Boolean

  """
  leaderboardSet contains the set of leaderboards that are active on this channel.
  """
  leaderboardSet(first: Int = 10): LeaderboardSet

  """
  leaderboardTimePeriod indicates whether the leaderboard type is of WEEKLY, ALL-TIME, etc.
  """
  leaderboardTimePeriod: LeaderboardTimePeriodType

  """
  All Prediction Events that are no longer accepting new predictions, and are awaiting resolution.
  """
  lockedPredictionEvents: [PredictionEvent!]

  """
  Retrieves video manager videos for the channel, this requires owner or editor permissions.
  """
  managedVideos(first: Int = 10, after: Cursor, statuses: [VideoStatus!], types: [BroadcastType!], sort: VideoSort = TIME): VideoConnection

  """Returns a resolver to query moderation logs."""
  moderationLogs: ModerationLogs

  """The channel's name."""
  name: String!

  """The number of VIP roles a user can assign in their channel."""
  numberOfVIPsAllowed: Int

  """The user who owns this channel."""
  owner: User

  """Configurations for chanlets this channel owns."""
  ownerChanletAttributes: OwnerChanletAttributes

  """Settings dictating how Prediction Events are run on this channel."""
  predictionSettings: ChannelPredictionSettings

  """Fetches most recent chat messages sent for the given channel."""
  recentChatMessages: [Message!]!

  """A single page of Prediction Events that have been resolved."""
  resolvedPredictionEvents(first: Int = 10, after: Cursor): PredictionEventConnection

  """
  The restriction that is currently active on the channel for restricting a user's access to it.
  """
  restriction: ResourceRestriction

  """
  The stream schedule of the user.
  Returns null when the user has not set a schedule.
  """
  schedule: Schedule

  """The requesting user's relationship with the channel."""
  self: ChannelSelfEdge

  """
  Extension information pertaining to the active user. Note that this is not
  part of the `self` property as this still returns data for anonymous users.
  """
  selfInstalledExtensions(isMobile: Boolean = false): [ExtensionInstallationSelfEdge!]

  """The channel's social media links and favicons."""
  socialMedias: [SocialMedia!]

  """A user-defined status message."""
  status: String! @deprecated(reason: "Use user.lastBroadcast.title instead.")

  """
  The live broadcast associated with this channel, if currently broadcasting.
  """
  stream: Stream @deprecated(reason: "Use user.stream instead.")

  """A list of streams for a given channel for multi-view."""
  streams: [Stream!]

  """Channel trailer for this channel."""
  trailer: Trailer

  """
  Requests from channel-banned users to be unbanned submitted on the channel.
  Accessible by users with moderator role or higher.
  """
  unbanRequests(after: Cursor, first: Int = 25, options: UnbanRequestsOptions): UnbanRequestConnection

  """Settings for users creating unban requests on the channel."""
  unbanRequestsSettings: UnbanRequestsSettings

  """The URL to view the channel in a browser."""
  url: String!

  """
  Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
  """
  videoStreamSettings: VideoStreamSettings

  """
  A list of available Drop 2.0 Campaigns of which drops viewers of this channel
  can claim when certain game events or minutes watched events are met. (Channel
  highlight card).
  """
  viewerDropCampaigns: [DropCampaign!]
}

"""Channel Analytics in Creator Dashboard."""
type ChannelAnalytics {
  """
  SubCountSeries in Channel Analytics that shows a user's sub count over time.
  """
  subCountSeries: SubCountSeries
}

"""Analytics around what other content my viewers watch."""
type ChannelAnalyticsContentOverlap {
  """Other channels that my viewers like to watch."""
  channels: [ChannelOverlap!]

  """Games that my viewers like to watch."""
  games: [GameOverlap!]
}

"""
ChannelBannedUser is an object that defines metadata about a channel ban.
"""
type ChannelBannedUser {
  """When the ban was created."""
  bannedAt: Time!

  """Representation of the banned user."""
  bannedUser: User

  """Representation of the mod that banned the user."""
  modUser: User
}

"""Paginated list of users banned from a channel."""
type ChannelBannedUserConnection {
  """The elements of the list."""
  edges: [ChannelBannedUserEdge!]

  """Information about this page of banned users."""
  pageInfo: PageInfo!
}

"""Element in a list of users banned from a channel."""
type ChannelBannedUserEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A ban record for a user banned from a channel."""
  node: ChannelBannedUser
}

"""
ChannelBlockedTerm is an object that defines things that automod should permit in a channel.
"""
type ChannelBlockedTerm {
  """If the term is permitted or banned type."""
  category: String!

  """When the term was created."""
  createdAt: Time

  """When the term expires at."""
  expiresAt: Time

  """If mods should be able to see and edit this term."""
  isModEditable: Boolean!

  """phrases are the string representation of a term."""
  phrases: [String!]!

  """Where the term came from, usually a mod user ID."""
  source: String

  """When the term was last updated."""
  updatedAt: Time
}

"""A challenge to which users can contribute bits."""
interface ChannelChallenge {
  """Total bits amount contributed."""
  bitsAmount: Int!

  """Time when challenge was created."""
  createdAt: Time!

  """User that created the challenge."""
  createdBy: User

  """Amount of seconds from when the challenge starts to when it ends."""
  durationSeconds: Int!

  """ID of challenge."""
  id: ID!

  """
  User who owns this challenge. The challenge will appear on their channel.
  """
  ownedBy: User

  """
  Amount of milliseconds before the challenge times out.
  0 when the challenge has timed out.
  """
  remainingDurationMilliseconds: Int!

  """
  The authenticated user's relationship with this challenge.
  Main use case is to connect the user to a challenge to allow bit contributions.
  Null if un-authenticated user is making this query.
  """
  self: ChannelChallengeSelfEdge

  """The status of the challenge."""
  status: ChannelChallengeStatus!

  """Time when challenge was updated."""
  updatedAt: Time!
}

"""A connection between the challenge and metadata."""
type ChannelChallengeConnection {
  """The list of challenges for the user."""
  edges: [ChannelChallengeEdge!]

  """Information about pagination in this connection."""
  pageInfo: PageInfo!
}

"""
A page entry, that contains the Challenge item and a cursor to return from the query to allow pagination.
"""
type ChannelChallengeEdge {
  """Cursor used for next query."""
  cursor: Cursor!

  """The underlying challenge."""
  node: ChannelChallenge!
}

"""A participant contributing to a challenge and associated information."""
type ChannelChallengeParticipant {
  """The bits this participant has contributed to a challenge."""
  bits: Int!

  """The Challenge this participant contributed to."""
  challenge: ChannelChallenge

  """Time when participant first contributed to the challenge."""
  firstContributedAt: Time!

  """id of the participant in the challenge."""
  id: ID!

  """Time when participant last contributed to the challenge."""
  lastContributedAt: Time!
}

"""A connection between a challenge and the authenticated user."""
type ChannelChallengeSelfEdge {
  """The participant object pertaining to the authenticated user."""
  participant: ChannelChallengeParticipant
}

"""Possible sort orders for lists of challenges."""
enum ChannelChallengeSort {
  """Sort the challenges by time."""
  START_TIME

  """Sort the challenges by time."""
  END_TIME
}

"""The status of the challenge."""
enum ChannelChallengeStatus {
  """Encountered some challenge status that we do not know how to handle."""
  UNKNOWN

  """
  Challenge is active. Users can contribute bits, with the challenge information publicly visible.
  """
  ACTIVE

  """
  Challenge was manually ended by a user and marked as "completed". Users cannot
  contribute bits. Challenge information publicly visible.
  """
  COMPLETED

  """
  Challenge was manually ended by a user and marked as "failed". Users cannot
  contribute bits. Challenge information publicly visible.
  """
  FAILED

  """
  Challenge has ended and is no longer publicly visible. Users cannot contribute
  bits. Challenge information publicly visible.
  """
  TIMED_OUT
}

"""
ChannelClipsCreationAuthRestrictionOptionsInput are the additional options for the auth restrictions.
"""
input ChannelClipsCreationAuthRestrictionOptionsInput {
  """
  The time requirement in minutes, of how long a follower needs to be following to create clips.
  """
  followingLengthMinutes: Int
}

"""
ChannelClipsCreationRestrictedTo contains the roles that are allowed to create Clips on a channel
that has isClipsEnabled set to true.
"""
type ChannelClipsCreationRestrictedTo {
  """Clip creation is restricted to users that are followers."""
  isFollower: Boolean!

  """Clip creation is restricted to users that are subscribers."""
  isSubscriber: Boolean!
}

"""
ChannelClipsCreationRestrictedToInput contains the roles that are allowed to create Clips on a channel
that has isClipsEnabled set to true.
"""
input ChannelClipsCreationRestrictedToInput {
  """Allow channel followers to create Clips."""
  followers: Boolean!

  """Allow channel subscribers to create Clips."""
  subscribers: Boolean!
}

"""
ChannelClipsCreationRestrictionOptions are the additional options for the auth restrictions.
"""
type ChannelClipsCreationRestrictionOptions {
  """
  The time requirement in minutes, of how long a follower needs to be following to create clips.
  """
  followingLengthMinutes: Int
}

"""
ChannelClipsSettings are the clips setting for the channel, including restriction settings for clip creation.
"""
type ChannelClipsSettings {
  """
  If isClipsEnabled is true, allow the following roles to create Clips on the channel.
  """
  creationRestrictedTo: ChannelClipsCreationRestrictedTo

  """
  If there are clip creation restrictions, use the following to add options to those restrictions.
  """
  creationRestrictionOptions: ChannelClipsCreationRestrictionOptions

  """Set whether or not users can create Clips on this channel."""
  isClipsCreationEnabled: Boolean!
}

"""
Data about a single configured Mosaic layout. This layout
specifies a configuration of panel dimensions and positions
in a grid, as defined by the Mosaic algorithm.
"""
interface ChannelDashboardLayout {
  """A unique identifier to uniquely reference this layout."""
  id: ID!

  """The display name for the layout shown to the user."""
  name: String!

  """
  A version to identify how the layout was generated,
  such as for deprecation purposes.
  """
  version: String!

  """When the layout was last updated"""
  lastUpdated: Time
}

"""
A view for editing a channel, including panels, layouts, options, etc.
Includes views like Stream Manager, Twitch Studio, etc.
"""
type ChannelDashboardView {
  """Panel layout configurations for this view type."""
  layouts: [ChannelDashboardLayout!]

  """
  Information about the view pertaining to the current channel for the
  current user, such as how many custom layouts have been used.
  """
  options: ChannelDashboardViewOptions!
}

"""
Details about the specific data of a layout type for
a channel, such as the number of custom layouts available
for use by the current user.
"""
type ChannelDashboardViewOptions {
  """
  Total (maximum) number of custom layouts the user can use for the channel
  for the specific dashboard view type.
  """
  customLayoutsTotal: Int

  """
  Amount of layouts the user has used for the channel for a specific dashboard view type.
  """
  customLayoutsUsed: Int
}

"""What channel feature the dashboard view is for."""
enum ChannelDashboardViewType {
  """Views for Stream Manager layout panels and other components."""
  STREAM_MANAGER

  """Views for Twitch Studio layout panels."""
  TWITCH_STUDIO
}

"""The Home of a channel."""
type ChannelHome {
  """The preferences that power a channel's home page."""
  preferences: ChannelHomePreferences

  """The shelves that are shown on a channel's home page."""
  shelves: ChannelHomeShelves
}

"""A list of categories displayed on a channel home's Category Shelf."""
type ChannelHomeCategoryShelf {
  """The list of categories to display in the shelf."""
  edges: [ChannelHomeCategoryShelfEdge!]!
}

"""The edges of the channel home category shelf."""
type ChannelHomeCategoryShelfEdge {
  """The category to display in the shelf."""
  node: Game
}

"""A list of categories displayed on a channel home's Category Shelf."""
type ChannelHomeCategorySuggestionsShelf {
  """The list of categories to display in the shelf."""
  edges: [ChannelHomeCategorySuggestionsShelfEdge!]!
}

"""
Contains a category and a boolean to denote whether the user has chosen to hide
that category from their channel home page's category shelf.
"""
type ChannelHomeCategorySuggestionsShelfEdge {
  """
  This is true if the user has chosen to hide this category from their category shelf.
  """
  isHidden: Boolean!

  """The category."""
  node: Game
}

"""The streamer's channel home preferences."""
type ChannelHomePreferences {
  """The hero preset."""
  heroPreset: HeroPreset!

  """The type of streamer shelf to display."""
  streamerShelfType: StreamerShelfType!
}

"""The shelves that are shown on a channel's home page."""
type ChannelHomeShelves {
  """A list of categories displayed on a channel home's Category Shelf."""
  categoryShelf(first: Int = 20): ChannelHomeCategoryShelf

  """
  A list of suggested categories to display on a channel home's Category Shelf.
  """
  categoryShelfSuggestions(first: Int = 20): ChannelHomeCategorySuggestionsShelf

  """
  The type and, if applicable, the list of users displayed in a channel home's Streamer Shelf.
  """
  streamerShelf(first: Int = 20): ChannelHomeStreamerShelf
}

"""The list of users displayed in a channel home's Streamer Shelf."""
type ChannelHomeStreamerShelf {
  """The list of users to display in the shelf."""
  edges: [ChannelHomeStreamerShelfEdge!]!

  """The type of streamer shelf to display (Autohost, Team, or Disabled)."""
  type: StreamerShelfType!
}

"""The edges of the channel home streamer shelf."""
type ChannelHomeStreamerShelfEdge {
  """The user to display in the shelf."""
  node: User
}

"""Paginated list of moderation actions on a channel."""
type ChannelModerationActionConnection {
  """List of moderation actions."""
  edges: [ChannelModerationActionEdge!]

  """Information about page."""
  pageInfo: PageInfo!
}

"""Element in a list of moderation actions of a user on a channel."""
type ChannelModerationActionEdge {
  """A cursor for the current node."""
  cursor: Cursor!

  """A moderation action."""
  node: ChannelModerationActionEntry
}

"""An entry of a moderation action performed on a channel."""
interface ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """The moderator who took the action."""
  moderator: User
}

"""
Moderation Actions relating to automod levels.
ex: automod level change.
"""
type ChannelModerationActionOnAutomodLevelEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """
  New automod level properties (based on Sift categories, to be deprecated).
  """
  automodNewProperties: AutoModProperties

  """
  Previous automod level properties (based on Sift categories, to be deprecated).
  """
  automodOldProperties: AutoModProperties

  """Previous automod level properties."""
  automodPreviousLevels: AutoModConfiguration

  """The newly updated automod level properties."""
  automodUpdatedLevels: AutoModConfiguration

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """The moderator who took the action."""
  moderator: User
}

"""
Moderation Actions relating to automod terms.
ex: add permitted term, remove permitted term, add banned term, remove banned term.
"""
type ChannelModerationActionOnAutomodTermEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """If the action originated from a message caught by Automod."""
  isFromAutomod: Boolean!

  """The moderator who took the action."""
  moderator: User

  """Strings that were add/deleted from permitted/blocked lists."""
  terms: [String!]
}

"""
Moderation Actions relating to another channel.
ex: host, unhost, raid, unraid.
"""
type ChannelModerationActionOnChannelEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """Is auto hosted."""
  isAutoHosted: Boolean!

  """Is hosted after raiding."""
  isHostedAfterRaiding: Boolean!

  """The moderator who took the action."""
  moderator: User

  """Should the viewer count for host or raids should be shown."""
  shouldRevealViewerCount: Boolean!

  """Target channel for hosting and raiding."""
  target: User

  """How many users participated in a host or raid."""
  viewerCount: Int
}

"""
Moderation Actions relating to chat messages.
ex: delete message.
"""
type ChannelModerationActionOnChatMessageEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """The message contents of the message deleted."""
  messageBody: String

  """The id of the message deleted."""
  messageID: ID

  """The sender of the message."""
  messageSender: User

  """The moderator who took the action."""
  moderator: User
}

"""
Moderation Actions realting to chat modes.
ex: slow on, followers only on, emotes only, sub only, clear chat.
"""
type ChannelModerationActionOnChatModeEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """Duration of the chat time in seconds."""
  durationSeconds: Int

  """UUID of the moderation action."""
  id: ID!

  """The moderator who took the action."""
  moderator: User
}

"""
Moderation Actions relating to unban requests.
ex: approve, deny.
"""
type ChannelModerationActionOnUnbanRequestsEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """The moderator who took the action."""
  moderator: User

  """Reason for action."""
  reason: String!

  """The user which the action targets if any."""
  target: User
}

"""
Moderation Actions relating to a user.
ex: ban, unban, timeout, untimeout, mod, unmod, vip, unvip.
"""
type ChannelModerationActionOnUserEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """Duration of the chat time in seconds for timeouts."""
  durationSeconds: Int

  """UUID of the moderation action."""
  id: ID!

  """The moderator who took the action."""
  moderator: User

  """Reason for action."""
  reason: String!

  """The user which the action targets if any."""
  target: User
}

"""Moderation Actions that are unused, invalid or deprecated."""
type ChannelModerationActionOtherEntry implements ChannelModerationActionEntry {
  """The action that was taken."""
  action: ModerationAction!

  """Timestamp when action was taken."""
  createdAt: Time!

  """UUID of the moderation action."""
  id: ID!

  """The moderator who took the action."""
  moderator: User
}

type ChannelNotificationSetting {
  """The setting category."""
  category: String!

  """Whether this setting is on or off for the given event."""
  isEnabled: Boolean!

  """The exact state of the setting. ("on", "off", "friends_only", etc)."""
  settingState: String!
}

"""Data about notification settings for a follow relationship."""
type ChannelNotificationSettings {
  """
  If true, enabled notifications will be send. If false, all notifications are
  disabled, even if their individual setting is enabled.
  """
  isEnabled: Boolean!

  """A list of channel notification settings."""
  nodes: [ChannelNotificationSetting!]!
}

"""Channel that my viewers also like to watch."""
type ChannelOverlap {
  """How much my viewers like to watch this channel."""
  score: Float!

  """Channel that my viewers also like to watch."""
  viewersAlsoWatch: User
}

"""An enumeration of permissions a user can have on a channel."""
enum ChannelPermission {
  """
  Permission to manage Chanlets, which represent sub-streams in a multiview mode.
  """
  MULTIVIEW_ADMIN

  """Permission to create restrictions on the channel."""
  SET_CHANNEL_RESTRICTION
}

"""
ChannelPermittedTerm is an object that defines things that automod should permit in a channel.
"""
type ChannelPermittedTerm {
  """If the term is permitted or banned type."""
  category: String!

  """When the term was created."""
  createdAt: Time

  """When the term expires at."""
  expiresAt: Time

  """If mods should be able to see and edit this term."""
  isModEditable: Boolean!

  """phrases are the string representation of a term."""
  phrases: [String!]!

  """Where the term came from, usually a mod user ID."""
  source: String

  """When the term was last updated."""
  updatedAt: Time
}

"""Settings dictating how Prediction Events are run on a channel."""
type ChannelPredictionSettings {
  """
  Whether channel moderators are allowed to create and resolve Prediction Events.
  """
  canModeratorsManagePredictions: Boolean!

  """Whether the channel is allowed to run Prediction Events at all."""
  isEligibleForPredictions: Boolean!
}

"""A restriction for a specific channel."""
type ChannelRestriction {
  """The time that the restriction is no longer active."""
  endsAt: Time

  """Information about being exempt from the restriction."""
  exemptionInfo: ChannelRestrictionExemptionInfo! @deprecated(reason: "Use resourceRestriction.exemptions instead.")

  """The ID of the channel restriction."""
  id: ID!

  """The time that the restriction becomes active."""
  startsAt: Time

  """The type of restriction on this channel."""
  type: ChannelRestrictionType!
}

"""Exemption information for a specific channel restriction."""
type ChannelRestrictionExemptionInfo {
  """The type of exemption."""
  exemptionType: String! @deprecated(reason: "Use channelRestriction.type instead.")
}

"""An enumeration of the different restriction types."""
enum ChannelRestrictionType {
  """The resource is restricted for an unknown reason."""
  UNKNOWN

  """The channel is restricted by a subscription."""
  SUB_ONLY_LIVE

  """The channel is restricted by the All-Access Pass."""
  ALL_ACCESS_PASS
}

"""Information about the requesting user with respect to a channel."""
type ChannelSelfEdge {
  """
  Whether or not the requesting user can request an unban on the channel.
  """
  canRequestUnban: Boolean

  """
  Properties relating to the authenticated user's community points in a channel.
  Null if community points are not enabled in the channel.
  """
  communityPoints: CommunityPointsProperties

  """
  Whether or not the requesting user is authorized to view the channel's content in a channel restrictions context.
  """
  isAuthorized: Boolean!

  """Whether or not the resource is restricted for the requesting user."""
  isResourceRestricted: Boolean!

  """Returns the user's last unban request on the channel."""
  lastUnbanRequest: UnbanRequest

  """Chat messages sent in a channel that are relevant to moderators."""
  modChatLogs(first: Int = 100, after: Cursor, order: SortOrder = DESC, includeMessageCount: Boolean = false, includeTargetedActions: Boolean = false, includeAutoModCaughtMessages: Boolean = true): ModLogsMessageConnection

  """
  List of channel feature permissions the logged in user has on the channel.
  """
  permissions: [ChannelPermission!]!

  """
  List of recent (either still active or recently resolved) Predictions made by this user on this Channel.
  """
  recentPredictions: [Prediction!]

  """If restricted, how the resource is restricted."""
  restrictionType: ResourceRestrictionType

  """Reason why user cannot request an unban on the channel."""
  unbanRequestRestriction: UnbanRequestRestrictionReason
}

"""The possible user roles within a channel."""
enum ChannelUserRole {
  """The channel owner."""
  BROADCASTER

  """An editor for the channel."""
  EDITOR

  """A moderator for the channel."""
  MODERATOR

  """A subscriber of the channel."""
  SUBSCRIBER

  """A user with no roles."""
  REGULAR
}

"""Channel/Viewer pair."""
type ChannelViewer {
  """ID of the form userID:channelID."""
  id: ID!

  """
  Fetches global badges and channel badges earned by the User on a channel.
  The returned list of badges will exclude badges that userID has elected to hide.
  If the user is the authenticated user, Badge.self.isVisibleInChatCard will reflect
  the user's stored preference, which can be editted on a per-badge basis with the
  setBadgePublicVisiblity mutation.
  """
  earnedBadges: [Badge!]
}

"""
Information about the intended device for making a refill purchase for a user.
"""
type ChargeInstrument {
  """A charge instrument Id."""
  id: ID!
}

"""Input charge instrument information."""
input ChargeInstrumentInput {
  """A charge instrument Id."""
  id: ID!
}

"""
ChargeModel describes the model used for charging the user. Will only contain
one credit model, one external model, or one internal model.
"""
type ChargeModel {
  """
  A charge model in which a user is charged using credits purchased or earned on Twitch.
  """
  credit: CreditChargeModel

  """
  A charge model in which a user is charged via a third-party in a fiat currency.
  """
  external: ExternalChargeModel

  """
  A charge model in which a user is charged by Twitch in a fiat currency.
  """
  internal: InternalChargeModel
}

"""ChargeModelPlan defines the payment plan of the charge model."""
type ChargeModelPlan {
  """The time interval for the charge model."""
  interval: ChargeModelPlanInterval!

  """The renewal policy for the charge model."""
  renewalPolicy: RenewalPolicy!
}

"""ChargeModelPlanInterval is the time interval for the charge model."""
type ChargeModelPlanInterval {
  """The duration of the charge model interval (used with the unit)."""
  duration: Int!

  """The unit of the charge model interval."""
  unit: ChargeModelPlanIntervalUnit!
}

"""
ChargeModelPlanIntervalUnit defines the unit of the charge model interval.
"""
enum ChargeModelPlanIntervalUnit {
  """Interval unit of Days."""
  DAYS

  """Interval unit of Months."""
  MONTHS

  """Unknown interval unit."""
  UNKNOWN
}

"""
ChatPauseSetting represents the possible settings for the user's preferred way to pause chat when moderating.
"""
enum ChatPauseSetting {
  """
  SCROLL_ONLY is the default behavior and pauses chat every time the users scrolls over the chat list.
  """
  SCROLL_ONLY

  """
  MOUSEOVER pauses chat whenever a user's mouse hovers over the list, unpauses
  automatically after 5 seconds if no scroll is performed.
  """
  MOUSEOVER

  """
  ALTKEY pauses chat when the user presses the alt key (option for mac users). It unpauses when the key is released.
  """
  ALTKEY

  """MOUSEOVER_ALTKEY pauses chat on mouse hover and hitting the alt key."""
  MOUSEOVER_ALTKEY
}

"""
Reasons that a user might not be allowed to chat in a specific channel.
"""
enum ChatRestrictedReason {
  """
  The user is prevented from chatting without a verified phone number.
  They will be prompted to verify one upon chatting.
  """
  REQUIRE_VERIFIED_PHONE_NUMBER

  """
  The user is prevented from chatting by subscribers-only mode. They should
  subscribe to the channel to chat.
  """
  SUBSCRIBERS_ONLY

  """
  The user is prevented from chatting by followers-only mode. They should
  either follow the channel, or wait longer to satisfy the required time.
  See user.self.follower.followedAt for when the user followed, and
  user.self.chatSettings.followersOnlyDurationMinutes for the minimum
  required follow time.
  """
  FOLLOWERS_ONLY

  """
  The user is prevented from chatting by verified-only mode. They should
  verify their account to chat.
  """
  VERIFIED_ONLY

  """
  The user can't chat because they've chatted too recently. See
  user.self.lastRecentChatMessageAt to calculate how much time is remaining
  before they can chat again.
  """
  SLOW_MODE
}

type ChatRoomBanStatus {
  """The user being banned of this chat."""
  bannedUser: User

  """The time the ban was imposed."""
  createdAt: Time!

  """The time at which the ban will automatically expire."""
  expiresAt: Time

  """The time in ms at which the ban will expire."""
  expiresInMs: Int

  """Conveys if the ban is permanent."""
  isPermanent: Boolean!

  """The moderator that carried out the action."""
  moderator: User

  """The reason the user was banned."""
  reason: String

  """The entity representing the users channel or chat room."""
  roomOwner: User
}

"""ChatSettings are settings and rules for chatting in a channel."""
type ChatSettings {
  """
  autoModLevel is an integer from 0-4 representing the level of automoderation of chat
  0 is off, 4 is the highest level of moderation.
  """
  autoModLevel: Int! @deprecated(reason: "No longer used.")

  """blockLinks indicates if links should be deleted from non-mod messages."""
  blockLinks: Boolean!

  """chatDelayMs is the delay before non-mods see a message."""
  chatDelayMs: Int!

  """
  The number of minutes a user must be following the broadcaster in order to chat
  If value is null, followers only mode is not enabled.
  """
  followersOnlyDurationMinutes: Int

  """
  isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
  match their language.
  """
  isBroadcasterLanguageModeEnabled: Boolean! @deprecated(reason: "No longer used.")

  """
  Indicates whether chat is currently enforcing that messages may only contain emotes.
  """
  isEmoteOnlyModeEnabled: Boolean!

  """Indicates whether subscribers are allowed to bypass slowmode."""
  isFastSubsModeEnabled: Boolean!

  """
  If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
  be inserted into automod if the channel has automod enabled.
  """
  isOptedOutOfGlobalBannedWordsList: Boolean! @deprecated(reason: "No longer used.")

  """Indicates whether chat is currently restricted to subscribers only."""
  isSubscribersOnlyModeEnabled: Boolean!

  """
  Indicates whether chat is currently enforcing that messages must be reasonably unique
  from recent messages. Previously known as "r9k mode".
  """
  isUniqueChatModeEnabled: Boolean!

  """requireVerifiedAccount indicates if users must be verified to chat."""
  requireVerifiedAccount: Boolean!

  """
  rules is a list of rules to display to users when joining a chat channel.
  """
  rules: [String!]!

  """
  The number of seconds a user must wait in between sending chat messages
  If value is null, slow mode is not enabled.
  """
  slowModeDurationSeconds: Int
}

"""User info about the chatter."""
type Chatter {
  """User login of the chatter."""
  login: String!
}

"""Information about the active chatters on a channel."""
type ChattersInfo {
  """List with the broadcaster."""
  broadcasters: [Chatter!]!

  """Number of active chatters."""
  count: Int!

  """List of active moderators."""
  moderators: [Chatter!]!

  """List of active staff members."""
  staff: [Chatter!]!

  """List of active viewers."""
  viewers: [Chatter!]!

  """List of active VIPs."""
  vips: [Chatter!]!
}

"""
ChatTheme is a client-side UI theme.
It can be used to provide different images based on the dominant background color they are designed to display on.
"""
enum ChatTheme {
  DARK
  LIGHT
}

"""Various user specific settings on how to render chat."""
type ChatUISettings {
  """
  Setting to store the user's preferred way to pause chat when moderating.
  """
  chatPauseSetting: ChatPauseSetting

  """
  Setting for how deleted messages should be displayed for channel broadcaster or moderator.
  """
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting

  """Whether emote animations are enabled."""
  isEmoteAnimationsEnabled: Boolean

  """Whether readable chat colors are enabled."""
  isReadableChatColorsEnabled: Boolean

  """Whether the emote animations setting callout has been dismissed."""
  isEmoteAnimationsSettingCalloutDismissed: Boolean
}

"""Actions required when initiating a checkout flow."""
enum CheckoutAction {
  """Action to block saved payment methods."""
  BLOCK_SAVED_PAYMENT_METHOD

  """Action to show velocity limit CTA."""
  EXCEEDED_VELOCITY_LIMITS

  """
  Action to show the user enabled 2FA before saving their payment method.
  """
  VERIFIED_SAVED_PAYMENT_METHOD

  """Action to disable new credit cards from being added on purchases."""
  DISABLE_NEW_CREDIT_CARD

  """Action to disable new credit cards from being added on purchases."""
  DISABLE_NEW_DIRECT_DEBIT

  """Action to indicate this user is authorized to make purchases."""
  AUTHORIZED_USER

  """Action to indicate xsolla should be prioritized."""
  PRIORITIZE_XSOLLA
}

"""Configs that help initiate the bits checkout flow."""
type CheckoutConfiguration {
  """
  Contains configuration (e.g. iFrameURL) to enable completing purchases via Xsolla, a payment provider.
  """
  xsolla(productType: PurchaseableProductType, productID: ID, offerTagBindings: [OfferTagBindingInput!], quantity: Int, giftRecipientIDs: [ID!], tenantTracking: String, paymentSession: PaymentSession, isDarkMode: Boolean): Xsolla
}

"""Inputs for checkoutConfiguration."""
input CheckoutConfigurationInput {
  """Whether the gift is anonymous."""
  isAnonymous: Boolean

  """Whether the purchase is a gift."""
  isGift: Boolean!

  """
  Whether the user is reactivating their subscription with a recurring or non-recurring payment plan.
  """
  isReactivateRecurring: Boolean

  """The number of gifts being purchased."""
  mysteryGiftCount: Int

  """Payment's session tracking."""
  paymentSession: PaymentSession

  """The ID of the gift recipient."""
  recipientID: ID

  """The country code for tax purposes."""
  taxCountryCode: String
}

"""Price information about an item in the checkout process."""
type CheckoutPriceSummary {
  """The currency associated with the price of a subscription product."""
  currency: Currency!

  """The description associated with pricing information."""
  description: String!

  """The discounted total with breakdown by discounted price and tax."""
  discount: DiscountBreakdown

  """The ISO-4217 wording of deriving price."""
  exponent: Int!

  """Identifier used for caching."""
  id: ID!

  """If the tax is already included in price."""
  isTaxInclusive: Boolean!

  """The numerical price of a subscription product."""
  price: Int!

  """Pricing identifier of the item being purchased."""
  pricingIdentifier: String!

  """The tax rate of localized product."""
  tax: Int!

  """The total price given price and tax."""
  total: Int!
}

"""
CheerInfo is the channel-specific bits/cheer settings and current state.
"""
type CheerInfo {
  """Gets the list of available bits badges the user offers."""
  availableBadges: [Badge!]

  """
  Badge tier emotes are the emotes in this channel that are unlocked when a user unlocks a Bits badge tier.
  Filter determines which emotes are returned.
  """
  badgeTierEmotes(filter: BadgeTierEmotesFilter!): [Emote]!

  """
  cheerGroups contain all of the channel-specific Cheermotes, grouped by type.
  """
  cheerGroups: [CheermoteGroup!]!

  """
  emotes are the metadata about the different cheermotes that can be use to cheer in this channel.
  This can optionally be filtered to return only certain cheermotes by either prefix and/or emote types.
  If `prefixes` is null or empty all available cheermotes will be returned, and then `type` filter
  will be applied to the result unless it's null or empty.
  If includeUpperTiers is true, the upper tiers of the cheermotes will be returned.
  """
  emotes(prefixes: [String!], type: [CheermoteType!], includeUpperTiers: Boolean, includeSponsored: Boolean): [Cheermote]! @deprecated(reason: "Scheduled to be removed. Use cheerGroups instead")

  """
  hashtags for augmenting cheering with different actions, such as #charity will donate bits to
  charity, or like #eddie to cheer and support Eddie.
  """
  hashtags(first: Int = 10, after: String): BitsHashtagConnection @deprecated(reason: "Hashtags is no longer a supported feature.")
  id: ID!

  """
  leaderboard contains the top users by number of bits cheered for the channel.
  """
  leaderboard(first: Int!): BitsLeaderboard

  """
  recentTimeoutMs is the remaining duration the recent message will be pinned for.
  This feature is deprecated and will always return 0.
  """
  recentTimeoutMs: Int! @deprecated(reason: "Recent cheer is a a removed feature, this functionality shouldn't be used anymore.")

  """settings are the channel-specific cheer settings."""
  settings: CheerSettings!
}

"""
Cheermote is the metadata about different variations of a single cheermote that can be use to cheer in this channel.
"""
type Cheermote {
  """
  A nullable campaign associated with the cheermote. This would only be attached to
  cheermotes that are of the CheermoteType.SPONSORED.
  """
  campaign: CheermoteCampaign

  """The ID of the cheermote."""
  id: ID!

  """
  prefix for this cheering action (Kappa, cheer, Kreygasm, etc).
  Any case-insensitive match of this prefix directly followed by a number
  (Kappa100, kappa100, kApPa100, etc) is to be considered a cheering message.
  """
  prefix: String!

  """tiers are bits breakpoints for different images for this cheermote."""
  tiers: [CheermoteTier!]!

  """type is the kind of cheermote (custom vs 1st- or 3rd-party global)."""
  type: CheermoteType!
}

"""
A campaign that is in association with a cheermote. Like, Old Spice could have a cheermote with
Terry Crew's head that they will sponsor X Bits that get added on to cheers that use their cheermote.
"""
type CheermoteCampaign {
  """The percentage of remaining bits that can be added to cheers."""
  bitsPercentageRemaining: Float!

  """
  An optional field that shows the user how many bits are being used to sponsor the campaign.
  """
  bitsTotal: Int

  """
  An optional field that shows the user how many bits have been used out of the sponsored pool.
  """
  bitsUsed: Int

  """Image url for the brand image."""
  brandImageURL: String!

  """The name of the brand, used in strings."""
  brandName: String!

  """The cheermote campaign ID. This is unique."""
  id: ID!

  """
  The minimum bits amount to make a cheer add bits from the sponsored campaign.
  """
  minimumBitsAmount: Int!

  """The nullable edge that relates the user to the campaign."""
  self: CheermoteCampaignSelfEdge

  """Thresholds for matching on sponsored cheering."""
  thresholds: [CheermoteCampaignThreshold!]!

  """Amount of bits that an individual user can contribute."""
  userLimit: Int!
}

"""Edge that relates a cheermote campaign to the logged in user."""
type CheermoteCampaignSelfEdge {
  """The total bits used by the user in the campaign."""
  bitsUsed: Int!

  """
  Eligibility for the user to cheer with the sponsored bits in the campaign.
  """
  canBeSponsored: Boolean!

  """The ID is comprised of the campaign ID and the user ID."""
  id: ID!
}

"""Threshold for sponsored cheermote campaign matching."""
type CheermoteCampaignThreshold {
  """
  Id for threshold, generated using the campaign id and the minimum bits field.
  """
  id: ID!

  """Percentage for matching."""
  matchedPercent: Float!

  """Minimum number of bits to get this level of matching."""
  minimumBits: Int!
}

"""The color that should be used to display each cheer amount."""
type CheermoteColorConfig {
  """
  bits is the minimum number of bits that are required to render this tier.
  To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
  """
  bits: Int!

  """
  color is the hex color used to render the number of bits for this tier.
  """
  color: String!
}

"""
The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
This includes things like the possible sizes, colors, backgrounds, and display order.
"""
type CheermoteDisplayConfig {
  """
  A list of the backgrounds that a Cheermote can be rendered at. For example, ["light", "dark"]
  Although this is probably more accurately represented as an emum, these strings are going to have to be used
  when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  same enum -> string mapping, we will just pass these directly as strings.
  """
  backgrounds: [String!]!

  """
  A list of the colors that should be used to display text for each Cheer amount.
  """
  colors: [CheermoteColorConfig!]!

  """A list of the order in which CheermoteTypes should be displayed."""
  order: [CheermoteType!]!

  """
  A list of the scales that a Cheermote can be rendered at. For example,  ["1", "1.5", "2", "3", "4"]
  Although this is probably more accurately represented as an emum, these strings are going to have to be used
  when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  same enum -> string mapping, we will just pass these directly as strings.
  """
  scales: [String!]!

  """A list of the display types available for Cheermotes."""
  types: [CheermoteDisplayType!]!
}

"""Information about the methods to display a Cheermote."""
type CheermoteDisplayType {
  """
  The animation style. For example, "static" or "animated"
  Although this is probably more accurately represented as an emum, these strings are going to have to be used
  when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  same enum -> string mapping, we will just pass these directly as strings.
  """
  animation: String!

  """
  The extension for this animation style. For example, "png" or "gif"
  Although this is probably more accurately represented as an emum, these strings are going to have to be used
  when creating the full URL for a Cheermote from the template URL. Rather than forcing each client to create the
  same enum -> string mapping, we will just pass these directly as strings.
  """
  extension: String!
}

"""
Contains a group of related Cheermotes that share the same CDN template.
"""
type CheermoteGroup {
  """The Cheermotes which belong to this group."""
  nodes: [Cheermote!]!

  """
  The template URL that clients can use to construct the image URL for each cheermote tier.
  The displayConfig field on Query provides values you'll need to fill in this template,
  so don't forget to request that as well.
  """
  templateURL: String!
}

"""CheermoteImage is a single image variation of a `CheermoteTier`."""
type CheermoteImage {
  """
  dpiScale is the scale of the cheermote image.
  Currently available scales are: 1, 1.5, 2, 3, or 4.
  """
  dpiScale: Float! @deprecated(reason: "Scheduled to be removed.")

  """The ID of CheermoteImage."""
  id: ID! @deprecated(reason: "Scheduled to be removed.")

  """isAnimated is true for animated cheermotes and false otherwise."""
  isAnimated: Boolean! @deprecated(reason: "Scheduled to be removed.")

  """theme is the UI theme the cheermote is designed to be rendered on."""
  theme: ChatTheme! @deprecated(reason: "Scheduled to be removed.")

  """url is the URL of the image asset."""
  url: String! @deprecated(reason: "Scheduled to be removed.")
}

"""CheermoteTier has information about a single tier of a cheermote."""
type CheermoteTier {
  """
  bits is the minimum number of bits that are required to render this tier.
  To render at this tier the cheemote must have used >= this minimum but < the next smallest tier.
  """
  bits: Int!

  """Can this cheer tier be used as a cheermote."""
  canCheer: Boolean! @deprecated(reason: "Scheduled to be removed.")

  """Can this cheer tier be shown in the Bits card."""
  canShowInBitsCard: Boolean!

  """
  color is the hex color used to render the number of bits for this tier.
  """
  color: String! @deprecated(reason: "Scheduled to be removed.")

  """The ID of CheermoteTier."""
  id: ID!

  """
  images are urls for the cheermote that match various settings.
  This can optionally be filtered to only certain variations or called without arguments to return all available images.
  """
  images(theme: ChatTheme, isAnimated: Boolean, dpiScale: Float): [CheermoteImage]! @deprecated(reason: "Scheduled to be removed.")

  """
  tierID of this specific cheermote icon. For "Kappa100" this will be "100".
  """
  tierID: ID! @deprecated(reason: "Scheduled to be removed.")
}

"""The supported cheermote tier thresholds."""
enum CheermoteTierThreshold {
  """Cheermote tier threshold requiring at least 1 Bit."""
  TIER_1

  """Cheermote tier threshold requiring at least 100 Bits."""
  TIER_100

  """Cheermote tier threshold requiring at least 1000 Bits."""
  TIER_1000

  """Cheermote tier threshold requiring at least 5000 Bits."""
  TIER_5000

  """Cheermote tier threshold requiring at least 10000 Bits."""
  TIER_10000
}

"""CheermoteToken is used to render a cheermote in a message."""
type CheermoteToken {
  """The number of bits in the cheermote."""
  bitsAmount: Int!

  """The prefix of the cheermote (e.g. cheer in cheer100)."""
  prefix: String!

  """
  The tier of the cheer used to determine which image to show for the cheermote.
  In cheer150, this would be 100.
  """
  tier: Int!
}

"""
CheermoteType is the kind of cheermore (custom vs 1st- or 3rd-party global).
"""
enum CheermoteType {
  """The type for the generic "Cheer" action."""
  DEFAULT

  """Custom Channel Cheermotes."""
  CUSTOM

  """Sponsored Cheermotes."""
  SPONSORED

  """Charity Cheermotes."""
  CHARITY

  """First Party Cheermotes, like Kappa and BibleThump."""
  FIRST_PARTY

  """Third Party Cheermotes, like Muxy and BitBoss."""
  THIRD_PARTY

  """
  Cheermotes for display only. The cannot be cheered, but will be rendered in Chat.
  """
  DISPLAY_ONLY

  """The type for the anonymous cheer action."""
  ANONYMOUS

  """
  Unknown cheermote type, we only return this if we get a bad cheermote,
  we decided this is better than erroring the whole response, the front end should treat this the same as DISPLAY_ONLY.
  """
  UNKNOWN
}

"""Bits partner settings associated with the badges."""
type CheerPartnerBadgeSettings {
  """
  Whether or not the broadcaster is enabled to upload bits badge tier emote rewards.
  """
  canUploadBadgeTierEmoticons: Boolean

  """A list of tiers, starting from 1 bit to as high as 5,000,000 bits."""
  tiers: [BitsBadgeTier!]!
}

"""Bits partner settings associated with the chat message."""
type CheerPartnerChatMessageSettings {
  """
  The setting that controls if the user has project v enabled on their channel.
  """
  isOptedOutOfProjectV: Boolean!

  """
  The minimum setting that controls the minimum bits that must be part of a cheer emote.
  """
  minBitsPerEmote: Int!

  """
  The minimum setting that controls the minimum amount a user must cheer in the channel.
  """
  minBitsToCheer: Int!
}

"""Bits partner dashboard settings for the bits cheer bomb events."""
type CheerPartnerCheerBombSettings {
  """
  Flag that is true if the user has opted out of seasonal cheer bomb events.
  """
  isOptedOut: Boolean!
}

"""Bits partner settings for custom cheermote prefix."""
type CheerPartnerCustomPrefixSettings {
  """Flag that is set if the user has the custom cheermote prefix enabled."""
  isEnabled: Boolean!

  """
  The prefix string that is used in their channel for their custom cheermote.
  """
  prefix: String!

  """The custom prefix images that have been uploaded by the user."""
  tiers: [CheermoteTier!]
}

"""Bits partner dashboard settings for the bits leaderboard."""
type CheerPartnerLeaderboardSettings {
  """Flag that is true if the user has bits leaderboards turned on."""
  isEnabled: Boolean!

  """The time period the user wants the leaderboard to be displayed as."""
  timePeriod: LeaderboardTimePeriodType!
}

"""Bits partner settings associated with recent cheers."""
type CheerPartnerRecentCheerSettings {
  """Flag that when true pins the recent cheer to their channel."""
  canPin: Boolean!

  """
  The minimum bits a user must cheer to show their cheer on the chat header.
  """
  minimumBits: Int!

  """The amount of time a recent cheer is shown before being dismissed."""
  timeoutMilliseconds: Int!
}

"""Cheer settings, configured in their partner dashboard."""
type CheerPartnerSettings {
  """Partner settings related to bit badges."""
  badges: CheerPartnerBadgeSettings

  """Partner settings related to chat messages with bits."""
  chatMessage: CheerPartnerChatMessageSettings!

  """Partner settings related to seasonal cheer bomb events."""
  cheerBomb: CheerPartnerCheerBombSettings!

  """Partner settings related to the custom cheermote prefix."""
  customPrefix: CheerPartnerCustomPrefixSettings!

  """
  Flag that is set when a user has filled out the bits legal ammendement.
  This can be true and isOnboarding false for legacy partners who onboarded before bits.
  """
  hasSignedBitsAmendment: Boolean!

  """An ID used for caching purposes for Apollo."""
  id: ID!

  """Flag that is set when a user has been onboarded for bits usage."""
  isOnboarded: Boolean!

  """Partner settings related to the bits leaderboard."""
  leaderboard: CheerPartnerLeaderboardSettings! @deprecated(reason: "Use leaderboard settings in user settings instead.")

  """Partner settings related to the recent cheer message."""
  recentCheer: CheerPartnerRecentCheerSettings!

  """Partner settings related to sponsored cheermotes."""
  sponsoredCheermotes: CheerPartnerSponsoredCheermoteSettings!
}

"""Partner settings related to sponsored cheermotes."""
type CheerPartnerSponsoredCheermoteSettings {
  """
  The sponsored cheermote channel settings that are associated with the user.
  """
  campaigns: SponsoredCheermoteChannelSettingsConnection
}

"""CheerSettings are the channel-specific cheer settings."""
type CheerSettings {
  """
  cheerMinimumBits is the minimum number of bits per message (sum of all cheermotes) required to cheer in this channel.
  """
  cheerMinimumBits: Int!

  """
  emoteMinimumBits is the smallest number of bits that can be spent on an individual cheermote in this channel.
  """
  emoteMinimumBits: Int!

  """
  event is the name of a special cheering event this channel is currently participating in.
  If there is no current event this will return null.
  """
  event: String
  id: ID!

  """
  Indicates if the bits football cheerbomb event is enabled on the channel.
  """
  isCheerBombEventEnabled: Boolean!

  """Indicates if polls is enabled."""
  isPollsEnabled: Boolean! @deprecated(reason: "Unsupported field. Check partner or affiliate status instead of using this field")

  """
  isRecentEnabled indicates if recent cheers are pinned in this channel.
  This can be used by a client to update `CheerInfo.recent` as new cheers are received.
  """
  isRecentEnabled: Boolean!

  """
  isTopEnabled indicates if top cheers are pinned in this channel.
  This can be used by a client to update `CheerInfo.top` as new cheers are received.
  """
  isTopEnabled: Boolean!

  """
  leaderboard contains all of the Bits settings related to Bits Leaderboards for this channel.
  """
  leaderboard: BitsLeaderboardSettings @deprecated(reason: "Use leaderboard settings in user settings instead.")

  """
  recentMinimumBits is the number of bits required for a cheer to be pinned.
  """
  recentMinimumBits: Int!

  """
  recentTimeoutMs is the amount of time a pinned recent message should be displayed for.
  """
  recentTimeoutMs: Int!
}

"""An interface to represent a claimable thing."""
interface Claimable {
  """A description of what the claimable is."""
  description: String!

  """The ID of the claimable."""
  id: ID!

  """
  A field that is populated with relevant information about claiming the object given a valid logged in user.
  """
  self: SelfClaimEdge

  """The type of claimable."""
  type: ClaimableType!
}

"""The enumerated types of claimables."""
enum ClaimableType {
  """A key code that has a bits amount associated with it."""
  BITS_KEY_CODE

  """A key code that has a subscription to a product associated with it."""
  SUBS_KEY_CODE

  """
  A key code that has a gift card with monetary value associated with it.
  """
  GIFT_CARD_KEY_CODE
}

"""Error code for an error that occurs while claiming the bounty."""
type ClaimBountyError {
  """Error code for error that occurred while claiming the bounty."""
  code: ClaimBountyErrorCode!
}

"""Error types recognized."""
enum ClaimBountyErrorCode {
  """Invalid parameter in the request."""
  INVALID_PARAMETER

  """User reached the maximum number of bounties."""
  BOUNTY_LIMIT_REACHED

  """User already claimed that bounty."""
  BOUNTY_ALREADY_CLAIMED

  """Unknown error being returned from service."""
  UNKNOWN_ERROR
}

"""ClaimBountyInput includes the bounty a user is trying to claim."""
input ClaimBountyInput {
  """Unique Identifier for the bounty campaign."""
  bountyCampaignID: ID!

  """Unique Identifier for the bounty."""
  bountyID: ID!

  """Platform selected by the user to play this bounty's game on."""
  platform: String

  """Region selected by the user for the game key."""
  region: String

  """UserID of the user that will claim the bounty."""
  userID: ID!
}

"""Data that was mutated after claiming the bounty."""
type ClaimBountyPayload {
  """The claimed bounty with the updated status."""
  claimedBounty: Bounty

  """The possible error returned from the service."""
  error: ClaimBountyError

  """The user that now has the claimed bounty."""
  user: User
}

"""An error from claiming community points."""
type ClaimCommunityPointsError {
  """An identifier for the error that occurred."""
  code: ClaimCommunityPointsErrorCode
}

"""The possible reasons a claim could fail."""
enum ClaimCommunityPointsErrorCode {
  """The point claim was not found."""
  NOT_FOUND

  """The current user is not allowed to claim these points."""
  FORBIDDEN
}

"""Input for claiming community points."""
input ClaimCommunityPointsInput {
  """The channel ID the claim is in."""
  channelID: ID!

  """The claim ID."""
  claimID: ID!
}

"""The response from claiming community points."""
type ClaimCommunityPointsPayload {
  """The points claim that was claimed."""
  claim: CommunityPointsClaim

  """The user's point balance in the channel, after the claim."""
  currentPoints: Int

  """
  An error that occurred while claiming. If there is an error, the claim did not go through.
  """
  error: ClaimCommunityPointsError
}

"""ClaimDropRewardsInput has fields required to claim a drop."""
input ClaimDropRewardsInput {
  """dropInstanceID is the unique drop instance to claim."""
  dropInstanceID: ID!
}

"""ClaimDropRewardsPayload returns the state of the claim."""
type ClaimDropRewardsPayload {
  """Summary information for the drop the reward is claimed of."""
  drop: DropObject @deprecated(reason: "No longer supported. Use dropType instead.")

  """dropInstanceID is the same as the provided input."""
  dropInstanceID: ID

  """A single Drop. This could be either an event or time based drop."""
  dropType: DropType

  """
  UserAccountConnected is a boolean specifying if the user has a connected account link to the game the Reward is for.
  """
  isUserAccountConnected: Boolean

  """rewards lists the rewards that were claimed and their statuses."""
  rewards: [DropReward!]!

  """status is an enum specifying the status of the claim request."""
  status: DropInstanceEligibilityStatus
}

"""
Hint describing the current availability state of the claim for the user.
"""
enum ClaimHint {
  """
  We found no existing entitlements for the customer for the offer.
  The offer is ready for claiming.
  """
  AVAILABLE

  """
  We found an existing entitlement for the customer, and the currently linked
  Amazon account is the account on the entitlement.
  This is preventing a future claim by the querying account.
  """
  CLAIMED_NO_CONFLICTS

  """
  We found an existing entitlement for the customer, but the currently linked
  Amazon account is NOT the account on the entitlement.
  This is preventing a future claim by the querying account.
  """
  CLAIMED_AMAZON_LINK_CONFLICT

  """
  We found an existing entitlement for one of the accounts for the customer.
  The existing entitlement is not blocking an additional claim.
  """
  RECLAIMABLE_NO_CONFLICTS

  """
  We found an existing entitlement linked to the household, but the querying account did not claim it themselves.
  This is preventing a future claim by the querying account.
  """
  CLAIMED_BY_MEMBER_OF_HOUSEHOLD

  """
  Customer does not have Twitch Prime.
  The user needs to sign up before claiming.
  """
  NEED_PRIME

  """
  The entitlement we found is for a code offer, and we have run out of codes.
  We may restock codes in the future and will report another claim hint type if so.
  """
  OFFER_FULLY_CLAIMED

  """
  No valid claim hint was provided.
  This will also occur when we implement new claim hints but have not yet updated this repo.
  """
  UNKNOWN
}

"""Error code for an error that occurs while claiming prime offer."""
type ClaimPrimeOfferError {
  """Error code for error that occurred while claiming prime offer."""
  code: ClaimPrimeOfferErrorCode!
}

"""Error types recognized."""
enum ClaimPrimeOfferErrorCode {
  """
  Status when offer is already claimed by the current user or an associated account.
  """
  OFFER_ALREADY_CLAIMED

  """Unknown error being returned from service."""
  UNKNOWN
}

input ClaimPrimeOfferInput {
  """Unique Identifier for an offer."""
  offerID: ID!
}

"""
Data that was mutated after claiming the prime offer, in this case, the entitlement.
"""
type ClaimPrimeOfferPayload {
  """The possible error returned from the service."""
  error: ClaimPrimeOfferError

  """The connection for whether the user is entitled to the offer."""
  self: PrimeOfferSelfConnection
}

"""
ClearUnreadFriendRequestsPaylod is the payload returned by ClearUnreadFriendRequests.
"""
type ClearUnreadFriendRequestsPayload {
  """The modified user."""
  user: User
}

"""The authorization a user has provided to an OAuth client."""
type ClientAuthorization {
  """The ID of the client."""
  clientID: ID!

  """The name of the client."""
  clientName: String

  """The time when the authorization was created."""
  createdAt: Time
}

"""A recorded, replayable part of a live broadcast."""
type Clip {
  """
  The broadcast of the clip. This should only be used to fetch the ID of the broadcast.
  Because not all videos have broadcasts (e.g. uploads), not all clips will have a broadcast.
  """
  broadcast: Broadcast

  """The broadcaster from which the clip originated."""
  broadcaster: User

  """
  The curator's clip champ badge if it has been attained on the broadcaster's channel.
  This has been deprecated and will be always be null.
  """
  champBadge: Badge @deprecated(reason: "Clip Champ Badges are no longer being awarded")

  """The time when the clip was created."""
  createdAt: Time!

  """
  Different video qualities are being created in the background.
  The creation state indicates when the source quality clip is playable
  and transcoding of the clip in other video qualities has begun.
  """
  creationState: ClipCreationState

  """The user who created the clip."""
  curator: User

  """The duration of the clip, in seconds."""
  durationSeconds: Int!

  """The URL used in the embed player."""
  embedURL: String!

  """The game depicted in the clip."""
  game: Game

  """The clip's unique identifier."""
  id: ID!

  """Whether or not the clip has been published."""
  isPublished: Boolean

  """The language of the clip."""
  language: Language!

  """
  The playback access token that determines whether the user can watch the clip.
  Fetched for both authed and unauthed users.
  """
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken

  """Metadata around the raw media."""
  rawMedia: ClipRawMedia!

  """
  The different quality options of this clip's raw media used for editing.
  """
  rawVideoQualities: [ClipVideoQuality!]

  """The reactions associated with this clips."""
  reactions: [Reaction]

  """Lists of related clips based on different algorithms."""
  relatedClips: ClipRelatedClips

  """A URL-friendly identifier."""
  slug: String!

  """
  A URL to a thumbnail image.
  Valid sizes are "86x45", "260x147", and "480x272".
  """
  thumbnailURL(width: Int = 260, height: Int = 147): String!

  """The title of the clip."""
  title: String!

  """A URL to the clip's page."""
  url: String!

  """
  The video of the clip. Because not all broadcasts are archived, not all clips will
  have a video.
  """
  video: Video

  """The number of seconds into a VOD this clip was generated from."""
  videoOffsetSeconds: Int

  """
  The different quality options of this clip available for playback.
  The clip will first be available in the source video quality, indicated by when the
  clipCreationState is 'CREATED'. videoQualities will gradually be added to afterwards as
  more video quality options become playable.
  """
  videoQualities: [ClipVideoQuality!]

  """The number of times this clip has been viewed."""
  viewCount: Int!
}

"""A list of clips related to the subject."""
type ClipConnection {
  """The clips."""
  edges: [ClipEdge]

  """Information about pagination in this connection."""
  pageInfo: PageInfo
}

"""
An enumeration on the different status strings returned by a clip status.
"""
enum ClipCreationState {
  """
  The creating status indicates that the source quality video is still
  undergoing processing and transcoding.
  """
  CREATING

  """
  Clip has been successfully created in the source video quality.
  The field videoQualities will be gradually added to with other quality options.
  """
  CREATED

  """
  Clip creation failed and will remain in this state.
  Possible errors can happen due to problems in downloading and slicing
  the source of the original video, clipping offline channels, transcoding, etc.
  """
  FAILED
}

type ClipEdge {
  """Uniquely identifies this clip's position in a connection."""
  cursor: Cursor

  """The clip."""
  node: Clip
}

"""
ClipRawMedia describes metadata about the clip's raw media used in clip editing.
"""
type ClipRawMedia {
  """
  Default Offset is the seconds into the raw clip media the default clip begins at.
  """
  defaultClipInitialOffset: Float!

  """Total duration of the raw media."""
  duration: Float!

  """Total number of frames displayed in the spritesheet film strip."""
  filmStripFrames: Int!

  """Seconds covered by each frame in the spritesheet film strip."""
  filmStripSecondsPerFrame: Int!

  """Height of the frames displayed."""
  frameHeight: Int!

  """Width of the frames displayed."""
  frameWidth: Int!

  """Spritesheet displayed to user for clip editing."""
  spritesheetURL: String!

  """Status of the clip's raw media."""
  status: ClipCreationState!

  """
  URL link to the video mp4 containing to upwards of 90 seconds of the raw video from which the clip can be created from.
  """
  videoURL: String!
}

"""
There are different algorithms that return a different set of related clips.
They only return up to 4 clips per list.
"""
type ClipRelatedClips {
  """
  Up-to 4  randomly selected, top viewed clips from the same broadcaster created within the last 4 days.
  """
  broadcaster: [Clip!]

  """
  Up-to 10 clips, in order, combined from the other returned clip sets.
  Clips are included in the priority of similar, broadcaster, game, and then top.
  """
  combined: [Clip!]

  """
  Up-to 4  randomly selected, top viewed clips from the same user created within the last 4 days.
  """
  curator: [Clip!]

  """
  Up-to 4  randomly selected, top viewed clips from the same game created within the last 4 days.
  """
  game: [Clip!]

  """
  Up-to 4 similar clips, based on the recommendations service.
  Deprecated: The underlying recommendations service that determined similar clips has been deprecated.
  """
  similar: [Clip!] @deprecated(reason: "Similar clips relied on a deprecated backend service.")

  """
  Up-to 4 randomly selected, top viewed clips created within the last 4 days.
  """
  top: [Clip!]
}

"""ClipSegmentInput represents a single segment of a clip."""
input ClipSegmentInput {
  """The number of seconds this clip segment encompasses."""
  durationSeconds: Float!

  """The offset into the clip's 90 second raw media."""
  offsetSeconds: Float!

  """
  Valid input speeds are 0.25, 0.5, 1.0, 1.5, and 2.0.
  The segment speed will be set to 1 by default if unspecified.
  """
  speed: Float = 1
}

"""The set of methods to restrict clips results."""
enum ClipsFilter {
  """Limit results to trending clips."""
  TRENDING

  """
  Limit results to clips created in the period between now and the last 24 hours.
  """
  LAST_DAY

  """
  Limit results to clips created in the period between now and the last 7 days.
  """
  LAST_WEEK

  """
  Limit results to clips created in the period between now and the last 30 days.
  """
  LAST_MONTH

  """No limit on clips creation period."""
  ALL_TIME
}

"""
An enumeration on the different time frames to filter clips results based on
creation time.
"""
enum ClipsPeriod {
  """
  Limit results to clips created in the period between now and the last 24 hours.
  """
  LAST_DAY

  """
  Limit results to clips created in the period between now and the last 7 days.
  """
  LAST_WEEK

  """
  Limit results to clips created in the period between now and the last 30 days.
  """
  LAST_MONTH

  """No limit on when the clips were created."""
  ALL_TIME
}

"""An enumeration on the different sort orders of clips results."""
enum ClipsSort {
  """Sort the clips ascending by created_at."""
  CREATED_AT_ASC

  """Sort the clips descending by created_at."""
  CREATED_AT_DESC

  """Sort the clips ascending by views."""
  VIEWS_ASC

  """Sort the clips descending by views."""
  VIEWS_DESC

  """Sort the clips descending by popularity."""
  TRENDING
}

"""
ClipVideoQuality describes metadata about an available playback source for a clip.
"""
type ClipVideoQuality {
  """
  Frame rate is the number of frames per second of this video.
  This value is a 64-bit float, with a default value of 30.0,
  and is used for supporting different playback speeds.
  Frame rate will be empty for raw media video qualities.
  """
  frameRate: Float

  """
  Clips can have multiple playback qualities via transcoding.
  Some examples of qualities include "1080", "720", "480", "360", and "source".
  """
  quality: String!

  """The source video URL for the clip in this specific playback quality."""
  sourceURL: String!
}

"""
CloneExtensionDiscoveryDataError is an error associated with the cloneExtensionDiscoveryData mutation.
"""
enum CloneExtensionDiscoveryDataError {
  """User is unable to clone the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_NEW_VERSION

  """The Version to clone from does not exist."""
  VERSION_NOT_FOUND
}

"""
CloneExtensionDiscoveryData copies a given version's discovery data to another version.
"""
input CloneExtensionDiscoveryDataInput {
  """The extension ID of the extension to clone."""
  id: ID!

  """The version to clone to."""
  newVersion: String!

  """The extension version to clone from."""
  version: String!
}

"""
CloneExtensionDiscoveryDataPayload returns any errors that occur during the copying of the discovery data.
"""
type CloneExtensionDiscoveryDataPayload {
  """The error when the mutation fails to update an extension."""
  error: CloneExtensionDiscoveryDataError

  """The updated extension discovery data."""
  manifest: ExtensionVersionDiscoveryManifest
}

"""
CloneExtensionManifestError is an error associated with the cloneExtensionManifest mutation.
"""
enum CloneExtensionManifestError {
  """User is unable to clone the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_NEW_VERSION

  """The version to clone to already exists."""
  VERSION_ALREDY_EXISTS

  """The Version to clone from does not exist."""
  VERSION_NOT_FOUND
}

"""
CloneExtensionManifest copies the data in a given extension version to a new version.
"""
input CloneExtensionManifestInput {
  """The extension ID of the extension to clone."""
  id: ID!

  """The version of the clone."""
  newVersion: String!

  """The extension version to clone."""
  version: String!
}

"""
CloneExtensionManifestPayload returns any errors that occur during update and the new manifest.
"""
type CloneExtensionManifestPayload {
  """The error when the mutation fails to update an extension."""
  error: CloneExtensionManifestError

  """The updated extension manifest."""
  manifest: ExtensionManifest
}

"""Represents a cloud broadcast and its state."""
type CloudBroadcast {
  """The id of the cloud broadcast."""
  id: ID!

  """The status of a cloud broadcast."""
  state: CloudBroadcastState!

  """
  The ingest URI for the broadcast.
  This is available if the broadcast is in an online state; otherwise null.
  """
  uri: String
}

"""A cloud broadcast provider id."""
type CloudBroadcastProvider {
  """The supported capabilities of a cloud broadcast."""
  capabilities: CloudBroadcastProviderCapabilities

  """The friendly display name of the provider."""
  displayName: String!

  """The logical id of the provider, for interacting with providers."""
  id: ID!
}

"""Capabilities of a cloud broadcast provider."""
type CloudBroadcastProviderCapabilities {
  """
  The maximum supported broadcast framerate for the provider, if available.
  """
  framerate: Int

  """The maximum supported broadcast height for the provider, if available."""
  height: Int

  """The ID of the provider associated with the capabilities."""
  id: ID!

  """Whether or not if the broadcaster can send broadcasts to the service."""
  isAvailable: Boolean!

  """The maximum supported broadcast width for the provider, if available."""
  width: Int
}

"""A cloud broadcast provider id."""
type CloudBroadcastProviderKey {
  """The friendly display name of the provider."""
  displayName: String!

  """The logical id of the provider, for interacting with providers."""
  id: ID!
}

"""Represents the status of a cloud broadcast."""
enum CloudBroadcastState {
  """Broadcast is offline and needs to be started."""
  OFFLINE

  """Broadcast is pending and currently starting."""
  PENDING

  """Broadcast is online and ready."""
  ONLINE

  """The broadcast status is unknown."""
  UNKNOWN
}

"""
Collection (a.k.a. Playlist) is a backend concept for a list of videos.
"""
type Collection {
  """The user-supplied description of the collection."""
  description: String!

  """The collection's identifier."""
  id: ID!

  """
  The paginated items in the collection. At this time, they will all be VoDs.
  """
  items(first: Int = 10, after: Cursor): CollectionConnection!

  """Total length of the collection as summed from all video lengths."""
  lengthSeconds: Int!

  """The owner of the collection."""
  owner: User

  """
  The thumbnailURL for the collection.
  If either `height` or `width` are not given, a templated value (i.e.
  `{height}`, `{width}`) will be present in the URL instead.
  """
  thumbnailURL(height: Int, width: Int): String

  """The user-supplied title of the collection."""
  title: String!

  """
  The type of collection, either a series or default collection which is ''.
  """
  type: CollectionType!

  """Time when the collection was last updated."""
  updatedAt: Time!

  """The total view count of a collection."""
  viewCount: Int
}

"""A paginated list of videos, and its metadata."""
type CollectionConnection {
  """The list of items in this page."""
  edges: [CollectionItemEdge]!

  """Information about this page of videos."""
  pageInfo: PageInfo!

  """The total number of items in the collection."""
  totalCount: Int!
}

"""The types of objects that can be contained in a collection."""
union CollectionItem = Video

"""
A page entry, that contains a collection item and a cursor to return
from the query to allow pagination.
"""
type CollectionItemEdge {
  cursor: Cursor!
  node: CollectionItem!
}

"""
A Collection input to set options to include all items in a collection.
"""
input CollectionOptions {
  """Include all playlist items including private and deleted items."""
  includeAllItems: Boolean = false
}

"""
These two types allow clients to query for a LIST of COLLECTIONS
(i.e. a two-dimensional array of videos).
"""
type CollectionsConnection {
  edges: [CollectionsItemEdge]!
  pageInfo: PageInfo!
}

type CollectionsItemEdge {
  cursor: Cursor
  node: Collection!
}

"""Options for filtering collections."""
input CollectionsOptions {
  """Option to include empty collections."""
  includeEmpty: Boolean = false

  """Only return collections that include the given video ID."""
  withVideoID: ID
}

"""The set of different collection types."""
enum CollectionType {
  """Series collection type."""
  SERIES

  """Default collection type."""
  DEFAULT
}

"""An automatic community points reward."""
type CommunityPointsAutomaticReward {
  """The background color for the reward icon."""
  backgroundColor: String

  """The point cost of this reward."""
  cost: Int

  """The default background color for this reward."""
  defaultBackgroundColor: String!

  """The default point cost of this reward."""
  defaultCost: Int!

  """The default image for this reward."""
  defaultImage: CommunityPointsImage!

  """
  Time that the global template for this reward was last updated in a way that
  should show a new content indicator to viewers.
  """
  globallyUpdatedForIndicatorAt: Time!

  """The unique identifier of this reward in this channel."""
  id: ID!

  """The custom icon for this reward, if any."""
  image: CommunityPointsImage

  """Whether this reward is turned on or off in this channel at the moment."""
  isEnabled: Boolean!

  """
  Whether only non-subscribers are allowed to redeem this reward in this channel.
  """
  isHiddenForSubs: Boolean!

  """The lowest the broadcaster is allowed to set the cost of this reward."""
  minimumCost: Int!

  """The type of automatic reward this is."""
  type: CommunityPointsAutomaticRewardType!

  """
  Time that this reward was last updated for the channel in a way that should show a new content indicator to viewers.
  Will be null if the channel hasn't made any updates to override the global settings.
  """
  updatedForIndicatorAt: Time
}

"""Types of CommunityPointsAutomaticRewards."""
enum CommunityPointsAutomaticRewardType {
  """Send a single message through sub-only mode."""
  SINGLE_MESSAGE_BYPASS_SUB_MODE

  """Unlock a random subscriber emote."""
  RANDOM_SUB_EMOTE_UNLOCK

  """Unlock a chosen subscriber emote."""
  CHOSEN_SUB_EMOTE_UNLOCK

  """Send a highlighted chat message."""
  SEND_HIGHLIGHTED_MESSAGE

  """Unlock a chosen modification for a subscriber emote."""
  CHOSEN_MODIFIED_SUB_EMOTE_UNLOCK
}

"""Information on how points are earned by viewers in a specific channel."""
type CommunityPointsChannelEarningSettings {
  """
  The average number of points per hour earned by a regular (non-sub) user on this channel.
  """
  averagePointsPerHour: Int!

  """
  The average number of points per hour earned by a subscriber on this channel.
  """
  averagePointsPerHourSubscriber: Int! @deprecated(reason: "Front-end messaging will update to display base averagePointsPerHour value and multipliers instead.")

  """How many points are earned for cheering in a channel."""
  cheerPoints: Int!

  """How many minutes will pass in between bonus claims becoming available."""
  claimPeriodMinutes: Int!

  """How many points are earned for clicking a bonus claim."""
  claimPoints: Int!

  """How many points are earned for following the channel."""
  followPoints: Int!

  """A unique identifier."""
  id: ID!

  """The possible multipliers users can have on earning points."""
  multipliers: [CommunityPointsMultiplier!]!

  """
  How many minutes must be watched to earn points for passively watching the channel.
  """
  passiveWatchPeriodMinutes: Int!

  """How many points are earned for passively watching the channel."""
  passiveWatchPoints: Int!

  """How many points are earned for following a raid by the channel."""
  raidPoints: Int!

  """
  The earning multiplier applied to subscribers to the channel.
  This multiplier only applies to "watch" and "claim" actions.
  """
  subscriberMultiplier: Float! @deprecated(reason: "This is the T1 specific multipler value, which is now included in multipliers list.")

  """How many points are earned for gifting a subscription in a channel."""
  subscriptionGiftPoints: Int!

  """
  How many points are earned for watching consecutive streams.
  This list will be sorted from shortest duration to longest duration.
  Watch streaks beyond the longest duration here will be treated the same as watch streaks of the longest duration.
  """
  watchStreakPoints: [CommunityPointsWatchStreakEarningSettings!]!
}

"""Settings for a channel's Community Points."""
type CommunityPointsChannelSettings {
  """Archived community goals for this channel."""
  archivedGoals(first: Int = 10, after: Cursor): CommunityPointsCommunityGoalConnection

  """
  Automatic rewards for this channel. If no automatic rewards exist, will be an empty array.
  """
  automaticRewards: [CommunityPointsAutomaticReward!]

  """The default max contribution to a community goal per user per stream."""
  communityGoalMaxContributionPerStream: Int!

  """The default small contribution to a community goal."""
  communityGoalSmallContribution: Int!

  """Single custom reward by the given id for this channel."""
  customReward(id: ID!): CommunityPointsCustomReward

  """Collections of the custom reward templates for this channel."""
  customRewardTemplateCollections: [CommunityPointsCustomRewardTemplateCollection!]

  """
  Custom rewards for this channel. If no custom rewards exist, will be an empty array.
  """
  customRewards: [CommunityPointsCustomReward!]

  """The default image for community points."""
  defaultImage: CommunityPointsImage!

  """
  Properties concerning the user's participation in the Channel Points early access program.
  """
  earlyAccess: CommunityPointsEarlyAccessSettings @deprecated(reason: "Early Access period is over.")

  """Information on how points are earned by viewers in this channel."""
  earning: CommunityPointsChannelEarningSettings

  """
  A list of the emote variants (base emote + modifications) that are available for this channel.
  """
  emoteVariants: [CommunityPointsEmoteVariant!]

  """Non-archived community goals for this channel."""
  goals(includeGoalTypes: [CommunityPointsCommunityGoalType!]): [CommunityPointsCommunityGoal!]

  """
  The channel's custom community points icon. Null if they have not set an icon.
  """
  image: CommunityPointsImage

  """Whether the channel is allowed to turn community points on now."""
  isAvailable: Boolean!

  """
  Whether the channel will be allowed to turn community points on at full public launch.
  """
  isAvailableAtLaunch: Boolean! @deprecated(reason: "Early Access period is over.")

  """Whether the channel has community points turned on now."""
  isEnabled: Boolean!

  """
  Whether the channel will have community points turned on at full public launch.
  """
  isEnabledAtLaunch: Boolean! @deprecated(reason: "Early Access period is over.")

  """
  The channel's custom community points name. Null if they have not set a name.
  """
  name: String

  """
  The amount of points earned for participating in a raid from the channel.
  """
  raidPointAmount: Int! @deprecated(reason: "Should use earning.raidPoints instead")

  """A list of Smart Costs acknowledgements."""
  smartCostsAcknowledgements: [SmartCostsAcknowledgement!]

  """
  A summary of information about unfulfilled redemptions of each custom reward.
  """
  summarizedRewards: [CommunityPointsRewardSummary!]

  """
  A list of the progress for all ongoing Update Custom Reward Redemption Statuses requests.
  """
  updateCustomRewardRedemptionStatusesProgress: [CommunityPointsUpdateCustomRewardRedemptionStatusesProgress!]
}

"""Points that are available for a user to click to claim in a channel."""
type CommunityPointsClaim {
  """The claim's unique ID."""
  id: ID!

  """
  The multipliers that will affect this claim.
  Multipliers start at a base of 1.0, and are additive.
  Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
  """
  multipliers: [CommunityPointsMultiplier!]!

  """
  The baseline points this claim will grant, before applying multipliers.
  """
  pointsEarnedBaseline: Int!

  """The total points this claim will grant."""
  pointsEarnedTotal: Int!
}

"""Community goal."""
type CommunityPointsCommunityGoal {
  """The amount of community points that this goal needs to succeed."""
  amountNeeded: Int!

  """
  The background color of this goal. Should be a hex color string, for example "FF0000".
  """
  backgroundColor: String!

  """The default image of community goals."""
  defaultImage: CommunityPointsImage!

  """The description of this goal."""
  description: String

  """
  The *initial* duration the streamer set for the goal.
  Only really used during the UNSTARTED state; once the goal is started
  the endedAt timestamp is populated (and updated for extended deadlines).
  """
  durationDays: Int!

  """When the goal ended / will end."""
  endedAt: Time

  """The id of the goal."""
  id: ID!

  """The image of the goal."""
  image: CommunityPointsImage

  """
  If this goal is available to be contributed to.
  true when the goal is active and the streamer is live.
  For MLP, this is just whether the channel is live.
  """
  isInStock: Boolean!

  """The max per stream, per user contribution limit."""
  perStreamUserMaximumContribution: Int!

  """The total points contributed to this goal."""
  pointsContributed: Int!

  """
  The small contribution needed to contribute to the goal. Contribution can only be
  less than this amount if the goal has less than this amount left to complete or if
  the viewer has less than this amount to be able to contribute.
  """
  smallContribution: Int!

  """When the goal started."""
  startedAt: Time

  """The current status of this goal."""
  status: CommunityPointsCommunityGoalStatus!

  """The title of this goal."""
  title: String!

  """The type of this goal."""
  type: CommunityPointsCommunityGoalType!
}

"""A paginated list of community goals."""
type CommunityPointsCommunityGoalConnection {
  """The list of community goals in this page."""
  edges: [CommunityPointsCommunityGoalEdge!]

  """Information about this page of community goals."""
  pageInfo: PageInfo!
}

"""Community goal contribution."""
type CommunityPointsCommunityGoalContribution {
  """The community goal."""
  goal: CommunityPointsCommunityGoal!

  """
  The amount of user's channel points contributed to this community goal this stream.
  """
  userPointsContributedThisStream: Int!
}

"""A community goal page entry, contains an item and a cursor."""
type CommunityPointsCommunityGoalEdge {
  """Identifies this community goal's position in a connection."""
  cursor: Cursor!

  """The community goal."""
  node: CommunityPointsCommunityGoal!
}

"""Community goal status."""
enum CommunityPointsCommunityGoalStatus {
  """Goal was just created."""
  UNSTARTED

  """Goal was started."""
  STARTED

  """Goal ended."""
  ENDED

  """Goal marked fulfilled by streamer."""
  FULFILLED

  """Goal archived."""
  ARCHIVED

  """Goal status unknown."""
  UNKNOWN
}

"""Community goal type."""
enum CommunityPointsCommunityGoalType {
  """Goal owned by creator."""
  CREATOR

  """Community Boost Goal."""
  BOOST

  """Goal type unknown."""
  UNKNOWN
}

"""The different types of content for community points."""
enum CommunityPointsContentType {
  """The content type is not understood by GQL."""
  UNKNOWN

  """The content type for automatic rewards."""
  AUTOMATIC_REWARD

  """The content type for custom rewards."""
  CUSTOM_REWARD
}

"""A custom community points reward on a channel."""
type CommunityPointsCustomReward {
  """
  The custom background color for this reward. If no background color specified, will be null.
  """
  backgroundColor: String

  """
  The cooldown expires at field indidicates when reward will be able to be redeemed after the cooldown is set.
  This field will only have a value if the global cooldown feature is enabled and has been recently redeemed.
  """
  cooldownExpiresAt: Time

  """The point cost of this reward."""
  cost: Int!

  """The default image for community points custom rewards."""
  defaultImage: CommunityPointsImage!

  """
  The most rewards of this type that can be redeemed per the global cooldown.
  """
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting!

  """
  Whether this reward has real world value. Null if the broadcaster has not set this field yet.
  """
  hasRealWorldValue: Boolean

  """The unique identifier for this reward."""
  id: ID!

  """The custom image for this reward. If no image exists, will be null."""
  image: CommunityPointsImage

  """Whether this reward is enabled in this channel at the moment."""
  isEnabled: Boolean!

  """
  Whether this reward is in stock at the moment.
  If the reward has already been redeemed the maximum number of times per stream, this will be false.
  """
  isInStock: Boolean!

  """Whether redemptions of this reward are temporarily paused."""
  isPaused: Boolean!

  """
  Whether only subscribers are allowed to redeem this reward in this channel.
  """
  isSubOnly: Boolean!

  """Whether this reward requires users to enter text input."""
  isUserInputRequired: Boolean!

  """The most rewards of this type that can be redeemed per stream."""
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting!

  """
  The most rewards of this type that can be redeemed per user per stream.
  """
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting!

  """
  The user-facing prompt for this reward. If no prompt exists, will be null.
  """
  prompt: String

  """
  The value of redemptions of the reward for the current stream.
  This field will only have a value if the max per user per stream is enabled and has been recently redeemed.
  """
  redemptionsRedeemedCurrentStream: Int

  """
  Whether redemptions for this reward should skip the broadcaster's request queue and get
  automatically fulfilled.
  """
  shouldRedemptionsSkipRequestQueue: Boolean!

  """
  The id for the CustomReward template this reward was created from. Will be null if not created from a template.
  """
  templateID: ID

  """The short title displayed for this reward."""
  title: String!

  """
  Time that this reward was last updated in a way that should show a new content indicator to viewers.
  """
  updatedForIndicatorAt: Time!
}

"""Settings for how often a custom reward may be redeemed per stream."""
type CommunityPointsCustomRewardGlobalCooldownSetting {
  """
  The most rewards of this type that can be redeemed per the global cooldown.
  """
  globalCooldownSeconds: Int!

  """Whether the cooldown is being enforced."""
  isEnabled: Boolean!
}

"""
Input for creating and updating a Community Points custom reward's max per stream settings.
"""
input CommunityPointsCustomRewardGlobalCooldownSettingInput {
  """
  The most rewards of this type that can be redeemed per global cooldown.
  """
  globalCooldownSeconds: Int!

  """Whether the cooldown is being enforced."""
  isEnabled: Boolean!
}

"""Settings for how often a custom reward may be redeemed per stream."""
type CommunityPointsCustomRewardMaxPerStreamSetting {
  """Whether the maximum is being enforced."""
  isEnabled: Boolean!

  """The most rewards of this type that can be redeemed per stream."""
  maxPerStream: Int!
}

"""
Input for creating and updating a Community Points custom reward's max per stream settings.
"""
input CommunityPointsCustomRewardMaxPerStreamSettingInput {
  """Whether the maximum is being enforced."""
  isEnabled: Boolean!

  """The most rewards of this type that can be redeemed per stream."""
  maxPerStream: Int!
}

"""Settings for how often a custom reward may be redeemed per stream."""
type CommunityPointsCustomRewardMaxPerUserPerStreamSetting {
  """Whether the maximum is being enforced."""
  isEnabled: Boolean!

  """
  The most rewards of this type that can be redeemed per user per stream.
  """
  maxPerUserPerStream: Int!
}

"""
Input for creating and updating a Community Points custom reward's max per stream settings.
"""
input CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput {
  """Whether the maximum is being enforced."""
  isEnabled: Boolean!

  """
  The most rewards of this type that can be redeemed per user per stream.
  """
  maxPerUserPerStream: Int!
}

"""A community points custom reward that has been redeemed in a channel."""
type CommunityPointsCustomRewardRedemption {
  """The unique ID of this redemption."""
  id: ID!

  """The user-provided text input, if it exists."""
  input: String

  """The custom reward that was redeemed."""
  reward: CommunityPointsCustomReward @deprecated(reason: "Use the 'rewardID' and 'rewardTitle' fields instead.")

  """The unique ID of the reward that was redeemed."""
  rewardID: ID!

  """
  The title of the custom reward that was redeemed, at the time it was redeemed.
  """
  rewardTitle: String!

  """The status of this redemption."""
  status: CommunityPointsCustomRewardRedemptionStatus!

  """The time that the reward was redeemed at."""
  timestamp: Time!

  """The user that redeemed the reward."""
  user: User
}

"""
A paginated list of Community Points redemptions, and its metadata.
Only returns results for logged-in, authorized users, otherwise returns a nil response.
"""
type CommunityPointsCustomRewardRedemptionConnection {
  """The list of items in this page."""
  edges: [CommunityPointsCustomRewardRedemptionEdge!]!

  """Information about this page of Community Points redemptions."""
  pageInfo: PageInfo!
}

"""
A page entry, that contains a CommunityPointsCustomRewardRedemption item and a cursor to
return from the query to allow pagination.
"""
type CommunityPointsCustomRewardRedemptionEdge {
  """Cursor used for next query."""
  cursor: Cursor!

  """The underlying Community Points redemption."""
  node: CommunityPointsCustomRewardRedemption!
}

"""Ways to sort Community Points redemptions."""
enum CommunityPointsCustomRewardRedemptionQueueSortOrder {
  """The oldest redemption first."""
  OLDEST

  """The newest redemption first."""
  NEWEST
}

"""Possible states for a CommunityPointsCustomRewardRedemption."""
enum CommunityPointsCustomRewardRedemptionStatus {
  """A redemption that has not been acted on by the broadcaster."""
  UNFULFILLED

  """A redemption that has been fulfilled by the broadcaster."""
  FULFILLED

  """A redemption that has been canceled by the broadcaster."""
  CANCELED

  """A redemption that has been reported by the broadcaster."""
  REPORTED
}

"""A template used to create a custom reward."""
type CommunityPointsCustomRewardTemplate {
  """The custom background color for a reward created from this template."""
  backgroundColor: String!

  """The point cost for a reward created from this template."""
  cost: Int!

  """
  The maximum number of redemptions for the reward created from this
  template that can be redeemed per the global cooldown.
  """
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSetting!

  """The unique identifier for this reward template."""
  id: ID!

  """The default image for a reward created from this template."""
  image: CommunityPointsImage!

  """
  Whether only subscribers are allowed to redeem the reward created
  from this template.
  """
  isSubOnly: Boolean!

  """
  Whether the reward created from this template requires users to enter
  text input.
  """
  isUserInputRequired: Boolean!

  """
  The maximum number of redemptions for the reward created from this
  template that can be redeemed per stream.
  """
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSetting!

  """
  The maximum number of redemptions for the reward created from this
  template that can be redeemed per user per stream.
  """
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSetting!

  """
  The user-facing prompt for the reward created from this template.
  If no prompt exists, will be null.
  """
  prompt: String

  """
  Whether redemptions for the reward created from this template should
  skip the broadcaster's request queue and get automatically fulfilled.
  """
  shouldRedemptionsSkipRequestQueue: Boolean!

  """The short title displayed for the reward created from this template."""
  title: String!
}

"""A collection of custom reward templates for a category on a channel."""
type CommunityPointsCustomRewardTemplateCollection {
  """The category these templated custom rewards are for."""
  category: CommunityPointsCustomRewardTemplateCollectionCategory!

  """The templated custom rewards."""
  customRewardTemplates: [CommunityPointsCustomRewardTemplate!]!
}

"""The possible categories for a collection of custom reward templates."""
enum CommunityPointsCustomRewardTemplateCollectionCategory {
  """Unknown category."""
  UNKNOWN

  """
  The templates are for custom rewards that are related to actions in a game.
  """
  GAME

  """The templates are for custom rewards that are related to actions irl."""
  IRL

  """
  The templates are for custom rewards that are related to actions on twitch.
  """
  TWITCH
}

"""Custom reward user redemption."""
type CommunityPointsCustomRewardUserRedemption {
  """The custom reward."""
  reward: CommunityPointsCustomReward!

  """
  The amount of redempetions per user on this reward during the current stream.
  """
  userRedemptionsCurrentStream: Int!
}

"""
Properties concerning the user's participation in the Community Points early access program.
"""
type CommunityPointsEarlyAccessSettings {
  """
  Whether the user is eligible to sign up for Community Points early access.
  """
  canSignUp: Boolean!

  """Whether the user has signed up for Community Points early access."""
  isSignedUp: Boolean!
}

"""A community points emote."""
type CommunityPointsEmote {
  """The emote's identifier."""
  id: ID!

  """The text token of the emote."""
  token: String!
}

"""A community points emote modification."""
type CommunityPointsEmoteModification {
  """The modified emote."""
  emote: CommunityPointsEmote!

  """
  Time that the modification was last updated globally in a way that should show a new content indicator to viewers.
  """
  globallyUpdatedForIndicatorAt: Time!

  """The emote modification's identifier."""
  id: ID!

  """The modifier of the emote."""
  modifier: CommunityPointsEmoteModifier!

  """
  The dark version of the icon to represent the modification made to the emote.
  """
  modifierIconDark: CommunityPointsImage! @deprecated(reason: "Use field in modifier.")

  """
  The light version of the icon to represent the modification made to the emote.
  """
  modifierIconLight: CommunityPointsImage! @deprecated(reason: "Use field in modifier.")

  """The title for the modification."""
  title: String! @deprecated(reason: "Use field in modifier.")
}

"""A community points emote modifier."""
type CommunityPointsEmoteModifier {
  """
  The dark version of the icon to represent a modification made to an emote.
  """
  iconDark: CommunityPointsImage!

  """
  The light version of the icon to represent a modification made to an emote.
  """
  iconLight: CommunityPointsImage!

  """The emote modifier's identifier."""
  id: ID!

  """The title of the modifier."""
  title: String!
}

"""
A community points emote variant, includes base emote plus modifications.
"""
type CommunityPointsEmoteVariant {
  """The base emote for this variant."""
  emote: CommunityPointsEmote!

  """The emote variant's identifier."""
  id: ID!

  """Whether community points can be used to unlock the base emote."""
  isUnlockable: Boolean!

  """The modifications available to be unlocked for this emote."""
  modifications: [CommunityPointsEmoteModification!]!
}

"""Image URLs of different sizes for community points rewards."""
type CommunityPointsImage {
  """The URL for the small size image."""
  url: String!

  """The URL for the medium size image."""
  url2x: String!

  """The URL for the large size image."""
  url4x: String!
}

"""
The information required for the client to upload an image for Community Points.
"""
type CommunityPointsImageUploadInfo {
  """The upload ID."""
  uploadID: ID!

  """The URL to upload to."""
  url: String!
}

"""Holds the last time a content type was viewed."""
type CommunityPointsLastViewedContentByType {
  """The type of content that was viewed at the lastViewedAt time."""
  contentType: CommunityPointsContentType!

  """
  The time at which the contentType was last viewed. Will be null if the content hasn't been viewed.
  """
  lastViewedAt: Time
}

"""Holds the last time a specific piece of content was viewed."""
type CommunityPointsLastViewedContentByTypeAndID {
  """
  A unique identifier for the piece of content based on the type of content dictated by contentType.
  """
  contentID: ID!

  """The type of content that was viewed at the lastViewedAt time."""
  contentType: CommunityPointsContentType!

  """
  The time at which the content was last viewed. Will be null if the content hasn't been viewed.
  """
  lastViewedAt: Time
}

"""
Availability of limited earn actions for a viewer in a specific channel.
"""
type CommunityPointsLimitedEarnings {
  """
  Timestamp of when points will become available for cheering on the channel.
  This will be nil if isCheerAvailable is true and can be nil when isCheerAvailable is false
  indicating that there is not currently a time in the future when it will become available.
  """
  cheerAvailableAt: Time

  """A unique identifier."""
  id: ID!

  """Can the user cheer to get points on the channel."""
  isCheerAvailable: Boolean!

  """Can the user follow to get points on the channel."""
  isFollowAvailable: Boolean!

  """
  Can the user gift a subscription in the channel to get points on the channel.
  """
  isSubscriptionGiftAvailable: Boolean!

  """
  Timestamp of when points will become available for gifting subscriptions on the channel.
  This will be nil if isSubscriptionGiftAvailable is true and can be nil when isSubscriptionGiftAvailable is false
  indicating that there is not currently a time in the future when it will become available.
  """
  subscriptionGiftAvailableAt: Time
}

"""
A multiplier affecting the rate of community points earned for a user in a channel.
"""
type CommunityPointsMultiplier {
  """
  The multiplying factor being applied.
  Multipliers start at a base of 1.0, and are additive.
  Two multipliers of [0.2] and [0.3] will give a final multiplier of 1.5x.
  """
  factor: Float!

  """The reason that the multiplier is being applied."""
  reasonCode: CommunityPointsMultiplierReason!
}

"""
Reasons that community point earning could be multiplied for a user in a channel.
"""
enum CommunityPointsMultiplierReason {
  """Tier-1 Subscriber."""
  SUB_T1

  """Tier-2 Subscriber."""
  SUB_T2

  """Tier-3 Subscriber."""
  SUB_T3
}

"""Properties relating to a user's community points in a channel."""
type CommunityPointsProperties {
  """
  Multipliers currently affecting the logged in user's rate of point gaining in this channel.
  If there are no multipliers active, will be an empty array.
  """
  activeMultipliers: [CommunityPointsMultiplier!]

  """
  Points that are available for the user to click to claim in this channel. Null if there are no points available to claim.
  """
  availableClaim: CommunityPointsClaim

  """
  The number of community points this user currently has available to use in this channel.
  """
  balance: Int!

  """
  Whether the user can redeem rewards on this channel for free.
  The main example is broadcasters on their own channels.
  """
  canRedeemRewardsForFree: Boolean!

  """The community goal contributions."""
  goalContributions: [CommunityPointsCommunityGoalContribution!]

  """
  Timestamps of when the user last viewed the different types of community points content on the channel.
  """
  lastViewedContent: [CommunityPointsLastViewedContentByType!]

  """Availability of limited earning actions for the user in this channel."""
  limitedEarnings: CommunityPointsLimitedEarnings

  """The custom reward user redemptions for the current live stream."""
  userRedemptions: [CommunityPointsCustomRewardUserRedemption!]
}

"""Optional filters that can be applied to a redemption queue query."""
input CommunityPointsRedemptionQueueOptions {
  """The order of the results, either oldest first or newest first."""
  order: CommunityPointsCustomRewardRedemptionQueueSortOrder = OLDEST

  """Filter results to only redemptions of this reward."""
  rewardID: ID

  """Filter results to only redemptions of this status."""
  status: CommunityPointsCustomRewardRedemptionStatus
}

"""
A summary of information about redemptions of a given custom community points reward.
Only returns results for logged-in, authorized users, otherwise returns a nil response.
"""
type CommunityPointsRewardSummary {
  """
  The total number of unfulfilled redemptions of this reward on the channel.
  """
  count: Int!

  """
  If the count is at the max, the true count could be any number greater than or equal to the count.
  Clients should indicate that there could be more redemptions than the number indicates.
  For example, if count = 100 and isCountAtMaximum = true, clients could show "100+".
  """
  isCountAtMaximum: Boolean!

  """The reward being summarized."""
  node: CommunityPointsCustomReward!
}

"""An error from redeeming an unlock emote Community Points reward."""
type CommunityPointsUnlockEmoteError {
  """The error code."""
  code: CommunityPointsUnlockEmoteErrorCode!
}

"""
Possible errors from redeeming an unlock emote Community Points reward.
"""
enum CommunityPointsUnlockEmoteErrorCode {
  """
  The emote ID provided is for the wrong channel or the wrong type of emote.
  """
  INVALID_EMOTE

  """The user is already entitled to the emote provided."""
  EMOTE_ALREADY_ENTITLED

  """
  The user is entitled to all emotes that would be randomly selected from.
  """
  NO_EMOTES_AVAILABLE

  """The user does not have sufficient points to redeem the reward."""
  INSUFFICIENT_POINTS

  """
  The client is retrying a redemption with a transaction id that has already been redeemed.
  """
  TRANSACTION_ALREADY_COMMITTED

  """
  The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
  """
  TRANSACTION_IN_PROGRESS

  """The reward cost has changed since the user has tried to redeem it."""
  REWARD_COST_MISMATCH

  """The reward is currently disabled."""
  REWARD_DISABLED

  """The user is not allowed to redeem this reward on this channel."""
  REWARD_FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""
Methods for updating community points CustomReward redemption statuses.
"""
enum CommunityPointsUpdateCustomRewardRedemptionStatusesMethod {
  """Unknown method."""
  UNKNOWN

  """Statuses for all redemptions for the channel are being updated."""
  BY_CHANNEL

  """Statuses for all redemptions for a reward are being updated."""
  BY_REWARD

  """Statuses for the provided redemptions are being updated."""
  BY_REDEMPTIONS
}

"""
The type representing Community Points Update Custom Reward Redemption Statuses Progress.
"""
type CommunityPointsUpdateCustomRewardRedemptionStatusesProgress {
  """The channel ID the redemptions are being updated for."""
  channelID: ID!

  """Unique identifier for the progress."""
  id: ID!

  """The method being used to update the custom reward redemption statuses."""
  method: CommunityPointsUpdateCustomRewardRedemptionStatusesMethod!

  """The new status the redemptions are being set to."""
  newStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The number of redemptions that have been processed so far."""
  processed: Int!

  """
  The reward ID the redemptions being updated are for.
  Will only be set if method is BY_REWARD.
  """
  rewardID: ID

  """The total number of redemptions being updated."""
  total: Int!
}

"""Properties relating to a user's community points across twitch."""
type CommunityPointsUserProperties {
  """
  Timestamps of when the user last viewed the different global pieces of content for community points.
  """
  lastViewedContent: [CommunityPointsLastViewedContentByTypeAndID!]
}

"""
Settings for how many community points are awarded for a watch streak of a specific duration.
"""
type CommunityPointsWatchStreakEarningSettings {
  """How many points are awarded for a streak of this length."""
  points: Int!

  """How long of a streak a user has."""
  streakLength: Int!
}

"""A company that is on Twitch."""
type Company {
  """The bounty board campaigns that the company owns."""
  bountyCampaigns(campaignID: ID, status: BountyCampaignStatus): BountyCampaignConnection

  """The brand portal settings for the company."""
  brandPortalSettings: BrandPortalSettings

  """ID of the Company in the CurseForge Infrastructure."""
  curseCompanyID: ID

  """
  The estimated viewer reach for the pool of broadcasters this company is considering targeting.
  """
  estimatedBroadcasterViewerReach(gameNames: [String!]!, targetAllBroadcasters: Boolean!, targetVarietyBroadcasters: Boolean!, streamLengthSeconds: Int, targetAllCountries: Boolean = false, targetAllGames: Boolean = false, countries: [String!] = []): BroadcasterViewerReach

  """
  The games associated with the company. Optionally include games that a company can use for Bounty Board
  campaigns (ie. "Just Chatting" for trailer campaigns).
  """
  games(includeBountyBoardGames: Boolean = false): [Game!]

  """The company's unique identifier."""
  id: ID!

  """Legacy Companies need to agree to the Drops Terms."""
  isCampaignsEnabled: Boolean!

  """Legacy Companies are required to sign the Contract."""
  isContractSigned: Boolean!

  """
  Indicates if the Company is a Legacy Company from the first iteration of the DevSite.
  """
  isLegacy: Boolean!

  """The human-readable name of the company."""
  name: String!

  """Indicates if company is a developer, publisher or other."""
  type: OrganizationType!

  """The Company URL for their Corporate Website."""
  url: String!
}

"""A Competition created by a competition organizer."""
type Competition {
  """Banner image for the competition event page."""
  bannerImageURL: String

  """The time when a competition organizer cancelled a competition."""
  cancelledAt: Time

  """
  This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
  """
  checkInDurationMinutes: Int!

  """The time the competition was created."""
  createdAt: Time!

  """
  Long form text block description for the competition and will be converted to Markdown client-side.
  """
  description: String

  """The time the competition is scheduled to end."""
  endAt: Time!

  """
  The format contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.).
  """
  format: CompetitionFormat!

  """The game being played in the competition."""
  game: Game

  """Unique Competition ID."""
  id: ID!

  """Primary artwork for the competition."""
  imageURL: String

  """The name of the competition."""
  name: String!

  """The competition organizer."""
  owner: User

  """
  The participant-facing points of contact for the competition that only registered participants can see.
  """
  participantOnlyContactInfo: CompetitionContactInfo

  """The type of participant for the competition. e.g. SOLO, TEAM, ..."""
  participantType: CompetitionParticipantType!

  """Paginated list of participants in the competition."""
  participants(first: Int = 10, after: Cursor): CompetitionParticipantConnection

  """A list of phases in the competition."""
  phases: [CompetitionPhase!]!

  """Paginated list of players in the competition."""
  players(first: Int = 10, after: Cursor, state: CompetitionPlayerState): CompetitionPlayerConnection

  """
  Long form text block description that explains the prizing for the competition
  and will be converted to Markdown client-side.
  """
  prizeDescription: String

  """The public points of contact for the competition that anyone can see."""
  publicContactInfo: CompetitionContactInfo

  """The time the competition is scheduled to end registration."""
  registrationEndAt: Time!

  """The maximum number of players in a REGISTERED state."""
  registrationLimit: Int!

  """
  The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ...
  """
  registrationType: RegistrationType!

  """
  Long form text block description that explains the rules for the competition
  and will be converted to Markdown client-side.
  """
  rulesDescription: String

  """The relationship between the authenticated user and the competition."""
  self: CompetitionSelfEdge

  """Paginated, ordered list representing the standings of the competition."""
  standings(first: Int = 100, after: Cursor): CompetitionStandingConnection

  """The time the competition is scheduled to start."""
  startAt: Time!

  """The state of the tournament."""
  state: CompetitionState!

  """
  The number of players within a single team entity. Must be 1 for solo-type competitions.
  """
  teamSize: Int!

  """Paginated list of teams in the competition."""
  teams(first: Int = 10, after: Cursor): CompetitionTeamConnection

  """Link URL to any additional terms and conditions."""
  termsURL: String

  """The time the competition was last updated."""
  updatedAt: Time!

  """Visibility of the competition."""
  visibility: CompetitionVisibilityState!
}

"""Enum for fields passing through automod."""
enum CompetitionAutomodField {
  """Competition name."""
  COMPETITION_NAME

  """Public contact info discord URL."""
  PCI_DISCORD

  """Public contact info email."""
  PCI_EMAIL

  """Participant only contact info discord URL."""
  POCI_DISCORD

  """Participant only contact info email."""
  POCI_EMAIL

  """Competition image URL."""
  IMAGE_URL

  """Competition banner image URL."""
  BANNER_IMAGE_URL

  """Terms URL."""
  TERMS_URL

  """Competition description."""
  DESCRIPTION

  """Competition rules description."""
  RULES

  """Competition prize description."""
  PRIZE

  """Player discord username."""
  PLAYER_DISCORD_USERNAME

  """Player in game username."""
  PLAYER_IN_GAME_USERNAME

  """Team name."""
  TEAM_NAME

  """Used when the field is unknown."""
  UNKNOWN
}

"""Paginated list of Competitions."""
type CompetitionConnection {
  """The elements of the list."""
  edges: [CompetitionEdge!]!

  """Are there more competitions in the list and what is the cursor."""
  pageInfo: PageInfo!
}

"""The contact information to contact the organizers for the competition."""
type CompetitionContactInfo {
  """Link to Discord server for competition contact purposes."""
  discordURL: String

  """Email address point of contact for the competition."""
  email: String
}

"""
Contains information about a Competition's relationship to a given page (connection),
and the Competition itself.
"""
type CompetitionEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A competition record in the list of competitons."""
  node: Competition!
}

"""Information to communicate to the user about an error state."""
type CompetitionError {
  """The fields failing to pass automod (on an automod failure)."""
  automodFailedFields: [CompetitionAutomodField!]

  """The error code."""
  code: CompetitionErrorCode!

  """The error message string."""
  message: String!
}

"""Enum for user errors."""
enum CompetitionErrorCode {
  """Used when an argument is missing but was required."""
  REQUIRED_ARGUMENT

  """Used when an argument that is passed in is invalid in some way."""
  INVALID_ARGUMENT

  """
  Used when an attempt to add a resource but that resource already exists.
  """
  ALREADY_EXISTS

  """Used when the registration limit on the competition has been reached."""
  LIMIT_REACHED

  """Used when a competition field fails to pass automod."""
  AUTOMOD_FAILED

  """Used when the error is unknown."""
  UNKNOWN
}

"""
The CompetitionFormat contains the type and type metadata of the competition. (i.e. single elimination, round robin, etc.).
"""
type CompetitionFormat {
  """The details of the format, currently only used for LEADERBOARD type."""
  details: FormatTypeDetails

  """The type of the format for the competition."""
  type: FormatType!
}

"""
The competition Image type sent by the user to determine what image is being uploaded to the competition.
"""
enum CompetitionImageType {
  """Banner image for the competition."""
  BANNER

  """Thumbnail image for the competition."""
  THUMBNAIL

  """Image type is unknown."""
  UNKNOWN
}

"""Identifiers for the competition image."""
type CompetitionImageUpload {
  """ID of the upload."""
  id: ID!

  """URL at which clients can access the image."""
  url: String!
}

"""A Lobby in a phase."""
type CompetitionLobby {
  """Lobby ID of lobby to advance the winner to."""
  advanceNextLobby: ID

  """Unique lobby ID."""
  id: ID!

  """Lobby ID of lobby to advance the loser to."""
  lossNextLobby: ID

  """The participants of a lobby, and their scores."""
  participants: [CompetitionLobbyParticipant!]

  """The count of reported scores of the lobby."""
  reportedScoreCount: Int!

  """The state of the lobby."""
  state: LobbyState!

  """
  The participant who had a higher score, if scores are equal and the lobby is
  done, the lobby ended in a tie and winner returns null
  """
  winner: CompetitionLobbyParticipant
}

"""A CompetitionLobbyParticipant, and its scores, in a lobby."""
type CompetitionLobbyParticipant {
  """
  The detailed participant associated with the lobby participant, can be a Competition Player or Competition Team.
  """
  detailedParticipant: CompetitionParticipant!

  """Unique ID for CompetitionLobbyParticipant."""
  id: ID!

  """The score for this participant."""
  score: Int

  """Tie breaker points awarded to the participant for this lobby"""
  tiebreakerScore: Int
}

"""
The features a user has access to when creating a competition with the Versus product.
"""
type CompetitionOrganizerCapability {
  """
  The features a user available to them when they are a Competition Organizer.
  null or [] mean no special permissions are given to this user.
  """
  allowedRegistrationTypes: [RegistrationType!]

  """
  Can this user upload or attach additional terms of service for a competition.
  """
  canAttachTerms: Boolean

  """Can this user create competitions in Versus."""
  canCreateCompetitions: Boolean

  """
  Can this user change participant statuses (invited -> registered) without participant consent.
  """
  canManageParticipantStatus: Boolean

  """Can this user host a Custom Format competition."""
  canUseCustomFormat: Boolean
}

"""
A CompetitionParticipant is either a CompetitionPlayer who is playing solo or a CompetitionTeam who plays as a team.
"""
union CompetitionParticipant = CompetitionPlayer | CompetitionTeam

"""Sorted list of competition participants."""
type CompetitionParticipantConnection {
  """The elements of the list."""
  edges: [CompetitionParticipantEdge!]!

  """Are there more competition participants and what is the cursor."""
  pageInfo: PageInfo!

  """The total amount of competition participants in the competition."""
  totalCount: Int!
}

"""
Contains information about a competition participant relationship to the paginated request,
and the participant themselves.
"""
type CompetitionParticipantEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A competition participant record."""
  node: CompetitionParticipant!
}

"""
The participant type signifies whether the competition will be played as team or solo.
"""
enum CompetitionParticipantType {
  """Participants are represented as a team."""
  TEAM

  """Participant is represented as solo."""
  SOLO

  """Unknown participant type."""
  UNKNOWN
}

"""A Phase created by a competition organizer."""
type CompetitionPhase {
  """Unique phase ID."""
  id: ID!

  """The lobbies in a phase."""
  lobbies: [CompetitionLobby!]!

  """
  The state of the phase. It is derived on whether any of the lobbies are actively playing.
  """
  state: PhaseState!

  """
  For more complex tournaments, the type determines how you progress after a phase.
  """
  type: CompetitionPhaseType
}

"""The phase type subdivides phases for more complex tournament types."""
enum CompetitionPhaseType {
  """
  This phase contains participants who have not used their second-chance.
  """
  DOUBLE_ELIMINATION_WINNERS

  """This phase contains participants who have lost a lobby once."""
  DOUBLE_ELIMINATION_LOSERS

  """Phase type is not applicable to a phase of this competition type."""
  NOT_APPLICABLE

  """Phase type is unknown."""
  UNKNOWN
}

"""The placement within the competition for an participant."""
type CompetitionPlacement {
  """The position in the total participant list a participant ranks."""
  position: Int
}

"""A player is solo participant in a Competition."""
type CompetitionPlayer {
  """Competition ID player is a part of."""
  competitionID: ID!

  """The time the player was added."""
  createdAt: Time!

  """The discord username for the player."""
  discordUsername: String

  """Unique ID for competition player."""
  id: ID!

  """The in game username for the player."""
  inGameUsername: String

  """Indicates whether the player is disqualified."""
  isDisqualified: Boolean!

  """The state a player has in the competition."""
  state: CompetitionPlayerState!

  """The associated team the user is part of."""
  team: CompetitionTeam

  """The total score for the competition player."""
  totalScore: Int!

  """The associated user."""
  user: User!
}

"""Paginated list of players in a Competition."""
type CompetitionPlayerConnection {
  """The elements of the list."""
  edges: [CompetitionPlayerEdge!]!

  """Are there more players in the competition and what is the cursor."""
  pageInfo: PageInfo!

  """The total amount of players in the competition."""
  totalCount: Int!
}

"""
Contains information about a Players relationship to a given page (connection),
and the Player themselves.
"""
type CompetitionPlayerEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A competition record in the list of competitions."""
  node: CompetitionPlayer!
}

"""The states a player can have in the competition."""
enum CompetitionPlayerState {
  """The player has been invited."""
  INVITED

  """
  The player has registered to compete in this competition in the future.
  """
  REGISTERED

  """The player has checked in to compete now."""
  CHECKED_IN

  """The player has competed in the competition."""
  COMPETED

  """The player has declined the competition."""
  DECLINED

  """The player state is unknown."""
  UNKNOWN
}

"""The relationship between the authenticated user and the competition."""
type CompetitionSelfEdge {
  """Whether the user is invited to the competition."""
  isInvited: Boolean

  """Whether the user is the owner."""
  isOwner: Boolean

  """Whether the user is a player in the competition."""
  isPlayer: Boolean

  """Whether the user is registered in the competition."""
  isRegistered: Boolean
}

"""
A single participant's competition standing including score and placement.
"""
type CompetitionStanding {
  """
  A record of all lobbies (1 per phase) in which the participant has competed.
  """
  history: [HistoricalCompetitionLobby!]

  """The participant whose score and placement are being reported."""
  participant: CompetitionParticipant!

  """Placement is a participant's rank in the competition standings."""
  placement: CompetitionPlacement!

  """The participant's current score for the competition."""
  score: Int

  """Summation of bonus points awarded to a participant."""
  tiebreakerScore: Int

  """
  Percentage of done lobbies the participant has won out of the done lobbies the
  participant in, if participant is not in any done lobbies this will be null.
  """
  winPercentage: Int
}

"""Paginated list of standings for a Competition."""
type CompetitionStandingConnection {
  """The elements of the list."""
  edges: [CompetitionStandingEdge!]!

  """Are there more standings for the competition and what is the cursor."""
  pageInfo: PageInfo!
}

"""
Contains information about a CompetitionStanding's relationship to a given page (connection),
and the standing itself.
"""
type CompetitionStandingEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A competition standing record in the list of competition standings."""
  node: CompetitionStanding!
}

"""The State of the Competition."""
enum CompetitionState {
  """Upcoming competition."""
  UPCOMING

  """Past competition."""
  PAST

  """Live competition."""
  LIVE

  """A competition that's awaiting check-ins."""
  CHECK_IN

  """A competition that's ready to be started."""
  READY

  """A competition that finished with no conclusion."""
  CANCELLED

  """Unknown state."""
  UNKNOWN
}

"""A Team is scheduled or has competed in a Competition."""
type CompetitionTeam {
  """The captain of the team is a Competition Player."""
  captain: CompetitionPlayer

  """CompetitionID we are a part of."""
  competitionID: ID!

  """Unique ID for competition team."""
  id: ID!

  """Indicates whether the team is disqualified."""
  isDisqualified: Boolean!

  """The members of the team are Competition Players."""
  members: [CompetitionPlayer!]

  """The name of the competition team."""
  name: String!

  """
  The relationship between the authenticated user and the competition team.
  """
  self: CompetitionTeamSelfEdge

  """The total score for the competition team."""
  totalScore: Int!
}

"""List of competition teams and their scores."""
type CompetitionTeamConnection {
  """The elements of the list."""
  edges: [CompetitionTeamEdge!]!

  """Are there more teams in the competition and what is the cursor."""
  pageInfo: PageInfo!

  """The total amount of teams in the competition."""
  totalCount: Int!
}

"""
Contains information about a Team relationship to a given page (connection),
and the Team themselves.
"""
type CompetitionTeamEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A competition team record."""
  node: CompetitionTeam!
}

"""
The relationship between the authenticated user and the competition Team.
"""
type CompetitionTeamSelfEdge {
  """Whether the user is the captain."""
  isCaptain: Boolean!
}

"""Information to communicate to the user about an error state."""
type CompetitionUploadImageError {
  """The error code."""
  code: CompetitionUploadImageErrorCode!

  """The error message string."""
  message: String!
}

"""Enum for user errors."""
enum CompetitionUploadImageErrorCode {
  """Used when an argument is missing but was required."""
  REQUIRED_ARGUMENT

  """Used when an argument that is passed in is invalid in some way."""
  INVALID_ARGUMENT

  """Used when the error is unknown."""
  UNKNOWN
}

"""The Visibility of the Competition."""
enum CompetitionVisibilityState {
  """Private competition."""
  PRIVATE

  """Public competition."""
  PUBLIC

  """Unknown state."""
  UNKNOWN
}

"""The required configuration to activate a component extension."""
input ComponentActivationInput {
  """The slot name of where the component extension should be displayed."""
  slot: String!

  """
  The horizontal positioning of the left side of the component extension from the left side
  of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  """
  x: Int

  """
  The vertical positioning of the top side of the component extension from the top side
  of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  """
  y: Int
}

"""
The view configuration of an extension if the component anchor is supported.
"""
type ComponentView implements ExtensionView {
  """
  Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
  
  NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
         however, since both will be used for a short time during the rollout of the new UI,
         aspectWidth and aspectHeight will not be deprecated until later.
  """
  aspectRatioX: Int!

  """
  Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
  
  NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
         however, since both will be used for a short time during the rollout of the new UI,
         aspectWidth and aspectHeight will not be deprecated until later.
  """
  aspectRatioY: Int!

  """
  Specifies whether or not the extension has the ability to link to external websites.
  """
  canLinkExternalContent: Boolean!

  """
  Specifies whether to automatically scale the extension iframe using css zoom as the video
  player dimensions change.
  """
  hasAutoscale: Boolean!

  """
  If Autoscale is true, this indicates the baseline width of the extension.
  This fields is optional, but is required if hasAutoscale is true.
  """
  scalePixels: Int

  """
  The percentage of the available space (0-100) (between the top and bottom player controls)
  that the extension aims to consume.
  
  NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
         however, since both will be used for a short time during the rollout of the new UI,
         aspectWidth and aspectHeight will not be deprecated until later.
  """
  targetHeight: Int!

  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
The view configuration of an extension if the component anchor is supported.
"""
input ComponentViewInput {
  """
  The developer configured height of the extension as a ratio relative to it's width.
  """
  aspectHeight: Int!

  """
  The developer configured width of the extension as a ratio relative to it's height.
  """
  aspectWidth: Int!

  """
  Specifies whether CSS zooming should be applied to the CE container, creating a consistent
  size of 1024 pixels along the long edge of the component. Default: true.
  """
  hasZoom: Boolean!

  """
  Size of the long edge of the Component Extension, relative to the length of the corresponding
  interactable dimension of the video.
  """
  size: Float!

  """Relative path of the HTML file to load for this view."""
  viewerPath: String!

  """
  If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
  Default: 1024.
  """
  zoomPixels: Int
}

"""
ConfigView holds the view configuration of an extension if the config page is supported.
"""
type ConfigView implements ExtensionView {
  """
  Specifies whether or not the extension has the ability to link to external websites.
  """
  canLinkExternalContent: Boolean!

  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
ConfigViewInput holds the view configuration of an extension if the config page is supported.
"""
input ConfigViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
ConnectAdIdentityInput accepts a deviceID and other parameters to generate an ad identity for that user.
"""
input ConnectAdIdentityInput {
  """mobile is an optional field that provides mobile device data."""
  mobile: MobileAdIdentityInput

  """targetDeviceID is the acting device ID."""
  targetDeviceID: ID!
}

"""ConnectAdIdentityPayload contains the identity URL."""
type ConnectAdIdentityPayload {
  """URL that the client should use to link ad identity."""
  identityURL: String
}

"""The consent status returned for the current user."""
type Consent {
  """The unique identifier of a consent status."""
  id: ID!

  """
  Identifier to determine whether consent is denied due to user underage.
  """
  isDeniedUnderage: Boolean!

  """Privacy law, e.g. CCPA or GDPR."""
  privacyLawName: PrivacyLawName!

  """Identifier to determine whether should notification to the user."""
  shouldShowNotification: Boolean!

  """
  Identifier to determine whether should show the consent settings page to the user.
  """
  shouldShowSettingsPage: Boolean!

  """A list of vendor consent status of a user."""
  vendorConsentStatus: VendorConsent!

  """A list of vendor consent status of a user."""
  vendorStatus: [VendorConsentStatus!]! @deprecated(reason: "Use vendorConsentStatus instead")
}

"""
List of features from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
"""
enum ConsentFeature {
  """Match and combine offline data sources."""
  MATCH_COMBINE_OFFLINE_DATA_SOURCES

  """Link different devices."""
  LINK_DIFFERENT_DEVICES

  """Receive and use automati…tics for identification."""
  RECEIVE_USE_AUTO_SENT_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION
}

"""
List of purposes from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
"""
enum ConsentPurpose {
  """Store and/or access information on a device."""
  STORE_ACCESS_INFO_ON_DEVICE

  """Select basic ads."""
  SELECT_BASIC_ADS

  """Create a personalised ads profile."""
  CREATE_PERSONALISED_ADS_PROFILE

  """Select personalised ads."""
  SELECT_PERSONALISED_ADS

  """Create a personalised content profile."""
  CREATE_PERSONALISED_CONTENT_PROFILE

  """Select personalised content."""
  SELECT_PERSONALISED_CONTENT

  """Measure ad performance."""
  MEASURE_AD_PERFORMANCE

  """Measure content performance."""
  MEASURE_CONTENT_PERFORMANCE

  """Apply market research to…erate audience insights."""
  APPLY_MARKET_RESEARCH_TO_GENERATE_AUDIENCE_INSIGHTS

  """Develop and improve products."""
  DEVELOP_IMPROVE_PRODUCTS
}

"""
List of special features from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
"""
enum ConsentSpecialFeature {
  """Use precise geolocation data."""
  USE_PRECISE_GEO_DATA

  """Actively scan device cha…tics for identification."""
  ACTIVELY_SCAN_DEVICE_CHARACTERISTICS_FOR_IDENTIFICATION
}

"""
List of special purposes from GVL https://vendorlist.consensu.org/v2/vendor-list.json.
"""
enum ConsentSpecialPurpose {
  """Ensure security, prevent fraud, and debug."""
  ENSURE_SECURITY_PREVENT_FRAUD_DEBUG

  """Technically deliver ads or content."""
  TECHNICALLY_DELIVER_ADS_CONTENT
}

"""ConsentStatus is the flag to show user gives or denies the consent."""
enum ConsentStatus {
  """User gives consent."""
  GIVEN

  """User denies consent."""
  DENIED
}

"""An enumeration on the different content type that enable tagging."""
enum ContentType {
  """Clip will enable tagging in v2."""
  CLIP

  """User is enabled for tagging in v1."""
  USER
  LIVE_CHANNEL @deprecated(reason: "Use 'USER' instead")

  """VOD will enable tagging in v2."""
  VOD

  """Games and other stream categories."""
  CATEGORY
}

"""Contribute community goal error."""
type ContributeCommunityPointsCommunityGoalError {
  """The error code."""
  code: ContributeCommunityPointsCommunityGoalErrorCode!
}

"""Contribute community goal error codes."""
enum ContributeCommunityPointsCommunityGoalErrorCode {
  """
  The goal is not currently redeemable, possibly because stream is not live.
  """
  NOT_CURRENTLY_REDEEMABLE

  """
  The current user does not have enough points to contribute this amount.
  """
  NOT_ENOUGH_POINTS

  """The community goal was not found."""
  NOT_FOUND

  """
  The current user is not allowed to contribute community points towards community goals for this channel.
  """
  FORBIDDEN

  """
  The current user has already reached the maximum points contributable per stream.
  """
  MAX_PER_STREAM

  """The current user has a contribution already in progress."""
  TRANSACTION_IN_PROGRESS

  """The current user has already completed this transaction."""
  DUPLICATE_TRANSACTION

  """The current user is banned."""
  USER_BANNED

  """An unknown error occurred."""
  UNKNOWN
}

"""Contribute community goal input."""
input ContributeCommunityPointsCommunityGoalInput {
  """The redemption amount."""
  amount: Int!

  """The channel."""
  channelID: ID!

  """The id of the community goal."""
  goalID: ID!

  """The id of this transaction."""
  transactionID: ID!
}

"""Contribute community goal payload."""
type ContributeCommunityPointsCommunityGoalPayload {
  """The error, if any."""
  error: ContributeCommunityPointsCommunityGoalError
}

"""Contribute to challenge error."""
type ContributeToChallengeError {
  """Code describing the error."""
  code: ContributeToChallengeErrorCode!
}

"""Contribute to challenge error code."""
enum ContributeToChallengeErrorCode {
  """
  User tried to contribute to a challenge that doesn't exist i.e. there is no indicated challenge at all).
  """
  CHALLENGE_NOT_FOUND

  """User tried to contribute to a challenge that is not active."""
  CHALLENGE_NOT_ACTIVE

  """
  Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist).
  """
  INVALID_CHANNEL_ID

  """
  User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100).
  """
  INSUFFICIENT_BITS_BALANCE

  """
  User is not allowed to contribute to the challenge (e.g. they're banned in the channel).
  """
  USER_FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""Inputs for contributing to a challenge."""
input ContributeToChallengeInput {
  """The amount of bits being contributed for this challenge."""
  bits: Int!

  """The id of the challenge that is being contributed to."""
  challengeID: ID!

  """The user id of the contributer."""
  userID: ID!
}

"""Output from the contribute to challenge mutation."""
type ContributeToChallengePayload {
  """
  The participant object returned by the Contribute to Challenge operation.
  """
  challengeParticipant: ChannelChallengeParticipant

  """If present, there was an error with the request."""
  error: ContributeToChallengeError
}

"""CookieVendorType is the type of cookie."""
enum CookieVendorType {
  """Vendors cookies that are essential."""
  ESSENTIAL

  """Vendors cookies that are used for analytics purposes."""
  ANALYTICS

  """Vendors cookies that are used for advertising purposes."""
  ADVERTISING
}

"""Errors for creating emotes."""
type CreateArchivedEmoteError {
  """The associated error code."""
  code: CreateArchivedEmoteErrorCode!
}

"""Possible error codes returned for creating emotes."""
enum CreateArchivedEmoteErrorCode {
  """The creator has reached their limit of archived emotes."""
  EMOTE_LIMIT_REACHED

  """Only the channel owner is allowed to upload archived emotes."""
  INVALID_OWNER

  """
  The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  """
  EMOTE_CODE_UNACCEPTABLE

  """Data for least one of the image sizes is not provided or invalid."""
  INCOMPLETE_EMOTE_IMAGE_DATA

  """The emote code suffix submitted contains invalid characters."""
  INVALID_CODE_SUFFIX

  """The upload emote image could not be parsed."""
  INVALID_IMAGE_UPLOAD

  """The uploaded emote image could not be found."""
  EMOTE_IMAGE_NOT_FOUND

  """
  There were not enough image assets supplied for the selected asset type.
  """
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS

  """
  There were more image assets supplied than required for the selected asset type.
  """
  TOO_MANY_EMOTE_IMAGE_ASSETS

  """The selected emote asset type was invalid."""
  INVALID_EMOTE_ASSET_TYPE

  """The selected emote state was invalid."""
  INVALID_EMOTE_STATE

  """
  There were more emote groups supplied than required for the emote state.
  """
  TOO_MANY_EMOTE_GROUPS

  """
  A static image asset was not supplied, but is required for the selected asset type.
  """
  EMOTE_MISSING_STATIC_ASSET

  """
  An animated image asset was not supplied, but is required for the selected asset type.
  """
  EMOTE_MISSING_ANIMATED_ASSET

  """Other errors returned from the service."""
  UNKNOWN_ERROR
}

"""
The data needed to finalize the creation of a non-active (aka archived) Emote.
"""
input CreateArchivedEmoteInput {
  """The type of image asset for the emote."""
  assetType: EmoteAssetType

  """
  The channel's emote prefix and the codeSuffix of the emote put together. This is how the emote is invoked in chat.
  """
  code: String!

  """
  The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code.
  """
  codeSuffix: String!

  """A list containing the image IDs for all assets needed for the emote."""
  imageAssets: [EmoteImageAssetInput!]!
}

"""Results of the create emote publish."""
type CreateArchivedEmotePayload {
  """The newly created emote if successful."""
  emote: Emote

  """Service error, if any."""
  error: CreateArchivedEmoteError
}

"""A 4xx-level error from the CreateBadgeFlair mutation"""
type CreateBadgeFlairError {
  """Code describing the cause of the error."""
  code: CreateBadgeFlairErrorCode!

  """String containing any relevant error message from Subscriptions."""
  message: String!
}

"""Error code describing a CreateBadgeFlairError"""
enum CreateBadgeFlairErrorCode {
  """Channel ID argument was invalid or empty."""
  INVALID_CHANNEL_ID

  """Image ID for 1x image was invalid or empty."""
  INVALID_FLAIR_IMAGE_1X_ID

  """Image ID for 2x image was invalid or empty."""
  INVALID_FLAIR_IMAGE_2X_ID

  """Image ID for 4x image was invalid or empty."""
  INVALID_FLAIR_IMAGE_4X_ID

  """Tier value was invalid or empty."""
  INVALID_TIER
}

"""Input to the CreateBadgeFlair mutation"""
input CreateBadgeFlairInput {
  """ID of the creator/channel which owns this custom badge flair."""
  channelID: ID!

  """
  The S3 ID of the 1x sized badge, provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation).
  """
  image1xID: ID!

  """
  The S3 ID of the 2x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation).
  """
  image2xID: ID!

  """
  The S3 ID of the 4x sized badge provided to clients by Upload Service. (See the createLoyaltyBadgeUploadConfig mutation).
  """
  image4xID: ID!

  """Sub tier which receives access to this flair."""
  tier: CreatorBadgeFlairTier!
}

"""Payload from the CreateBadgeFlair mutation"""
type CreateBadgeFlairPayload {
  """Error representing any 4xx-level error, if any."""
  error: CreateBadgeFlairError
}

"""
CreateBitsChallengeConditionForExtensionInput creates a Bits condition on behalf of a user by an extension.
"""
input CreateBitsChallengeConditionForExtensionInput {
  """
  A list of the different bits recipients and their weighted share of the total bits pool once the condition is satisfied.
  If this is not defined during condition creation, it must be defined when the condition is satisfied.
  """
  bitsRecipientWeightedShares: [BitsChallengeConditionPoolRecipientWeightedShare!]

  """Description of the condition."""
  description: String

  """
  Whether to disable the condition once it has been satisfied or keep it active.
  """
  disableWhenSatisfied: Boolean!

  """ID of the extension creating the conditional."""
  extensionID: ID!

  """
  ID of the channel where the extension is installed.
  TODO: change to required once the extension coordinator starts sending this param.
  """
  extensionInstallationChannelID: ID

  """Name of the condition."""
  name: String!

  """Time when the condition should time out."""
  timeoutAt: Time
}

"""
CreateBitsChallengeConditionForExtensionPayload returns the new condition that was created.
"""
type CreateBitsChallengeConditionForExtensionPayload {
  """The newly created condition."""
  condition: ChallengeCondition

  """If present, there was an error in the request."""
  error: CreateChallengeConditionError
}

"""
CreateBitsChallengeConditionParticipantForExtensionInput creates a Bits
condition participant on behalf of a user by an extension.
"""
input CreateBitsChallengeConditionParticipantForExtensionInput {
  """Bits quantity to be held pending condition satisfaction."""
  bitsAmount: Int!

  """ID of the associated condition."""
  conditionID: ID!

  """TUID of condition owner."""
  conditionOwnerID: ID!

  """ID of the extension creating the conditionParticipant."""
  extensionID: ID!

  """
  Time in seconds, after which the conditionParticipant is expired and the Bits are released (range: 1-43_200).
  """
  ttlSeconds: Int!
}

"""
CreateBitsChallengeConditionParticipantForExtensionPayload returns the new condition participant that was created.
"""
type CreateBitsChallengeConditionParticipantForExtensionPayload {
  """The newly created condition participant."""
  conditionParticipant: ChallengeConditionParticipant

  """If present, there was an error in the request."""
  error: CreateChallengeConditionParticipantError
}

"""CreateBountyCampaignInput includes the campaign that is being created."""
input CreateBountyCampaignInput {
  """The platforms that the campaign applies to."""
  availablePlatforms: [String!]

  """The list of broadcaster IDs to blacklist (if any) for the campaign."""
  blacklistedBroadcasters: [ID!]

  """Optional box art URL for the campaign."""
  boxArtURL: String

  """
  The message that will be shown to the broadcaster when they view the campaign.
  """
  broadcasterMessage: String

  """The multiplier for the broadcaster payout rate."""
  broadcasterMultiplier: Float!

  """The budget for the campaign in cents."""
  budgetCents: Int!

  """The chat Calls to Action for the campaign."""
  chatCTAs: [BountyCampaignChatCTAInput!]

  """The ID of the content that the campaign is related to."""
  contentID: ID

  """Optional cover URL for the campaign."""
  coverURL: String

  """Optional display for the campaign."""
  displayName: String

  """When the campaign will end."""
  endAt: Time!

  """If the campaing is a promotional campaign."""
  isPromotionEligible: Boolean

  """The ID of the organization that the campaign is related to."""
  organizationID: ID!

  """If the campaign should allow any game to be played."""
  shouldAllowAllGames: Boolean

  """The optional name of the sponsor of the campaign."""
  sponsor: String

  """When the campaign will start."""
  startAt: Time!

  """
  Deprecated. How long the broadcaster needs to stream the sponsored content to complete the bounty (in minutes).
  """
  streamLengthMinutes: Int

  """
  How long the broadcaster needs to stream the sponsored content to complete the bounty (in seconds).
  """
  streamLengthSeconds: Int

  """Flag to target all broadcaters for the campaign."""
  targetAllBroadcasters: Boolean

  """Flag to target all countries for the campaign."""
  targetAllCountries: Boolean

  """Flag to target all games for the campaign."""
  targetAllGames: Boolean

  """The click target of the campaign if it is a promotional campaign."""
  targetPromotionalVideoClicks: Int

  """Flag to target variety broadcaters for the campaign."""
  targetVarietyBroadcasters: Boolean

  """
  Targeted countries for the campaign (represented by ISO 3166-1 alpha-2).
  """
  targetedCountries: [String!]

  """Targeted Games (game titles) for the campaign."""
  targetedGames: [String!]

  """The title of the campaign."""
  title: String!

  """The tracking URLs for this campaign."""
  trackingPixels: [TrackingPixelInput!]

  """The type of the campaign."""
  type: BountyCampaignType

  """
  Deprecated, use videos instead. The URL of the video for this campaign.
  """
  videoURL: String

  """The video URLS for the campaign."""
  videos: [BountyCampaignVideoInput!]
}

"""Data that was mutated after the campaign was created."""
type CreateBountyCampaignPayload {
  """The campaign that was created."""
  campaign: BountyCampaign
}

"""
CreateBountyCampaignUploadConfigInput is the input for create bounty campaign upload configuration.
"""
input CreateBountyCampaignUploadConfigInput {
  """The ID of the organization that the campaign is related to."""
  organizationID: ID!

  """The image type to be uploaded."""
  uploadType: BountyCampaignUploadType!
}

"""
Returned information about image upload including URL to upload the image to.
"""
type CreateBountyCampaignUploadConfigPayload {
  """Unique identifier for the image."""
  imageID: ID

  """Unique identifier for the generated URL."""
  uploadID: ID

  """The actual URL to be used by the client to upload the image."""
  uploadURL: String
}

"""Inputs for creating a new celebration."""
input CreateCelebrationInput {
  """Where on the channel page the celebration will show."""
  area: CelebrationArea!

  """Channel id to create the celebration on."""
  channelID: ID!

  """Length the celebration will play."""
  durationMilliseconds: Int!

  """Effect which will show when the celebration triggers (ex Fireworks)."""
  effect: CelebrationEffect!

  """Threshold which will trigger the celebration (ex: Cheering 100 Bits)."""
  eventThreshold: Int!

  """Event type which will trigger the celebration (ex: Cheering Bits)."""
  eventType: CelebrationEventType!

  """
  Intensity of the celebration.
  Should be bounded (TBA) value which will determine the spectacle of the celebration.
  """
  intensity: Int!

  """If true, the celebration is enabled."""
  isEnabled: Boolean!
}

"""Outputs from the create celebration mutation."""
type CreateCelebrationPayload {
  """The created celebration."""
  celebration: Celebration

  """If present, there was an error with the request."""
  error: CelebrationError
}

"""Create Challenge Condition error."""
type CreateChallengeConditionError {
  """Code describing the error."""
  code: CreateChallengeConditionErrorCode!
}

"""Create Challenge Condition error code."""
enum CreateChallengeConditionErrorCode {
  """
  User tried to create a condition with a bits recipient that is ineligible to receive bits.
  """
  BITS_RECIPIENT_INELIGIBLE

  """An unknown error occurred."""
  UNKNOWN
}

"""Create Challenge Condition Participant error."""
type CreateChallengeConditionParticipantError {
  """Code describing the error."""
  code: CreateChallengeConditionParticipantErrorCode!
}

"""Create Challenge Condition Participant error code."""
enum CreateChallengeConditionParticipantErrorCode {
  """
  User tried to create a condition participant with a USE_BITS effect type, but they are ineligible to use bits.
  """
  BITS_BENEFACTOR_INELIGIBLE

  """
  User tried to create a condition participant with a USE_BITS effect type, but they lacked sufficient bits.
  """
  INSUFFICIENT_BITS_BALANCE

  """
  User tried to create a condition participant for an inactive condition.
  """
  CONDITION_NOT_ACTIVE

  """
  User tried to create a condition participant for a non-existent condition.
  """
  CONDITION_NOT_FOUND

  """
  User tried to create a condition participant with an effect type that is not supported by the associated condition.
  """
  EFFECT_TYPE_UNSUPPORTED_BY_CONDITION

  """An unknown error occurred."""
  UNKNOWN
}

"""CreateChanletInput creates a chanlet under the given channelID."""
input CreateChanletInput {
  """The ID of the channel the chanlet should belong to."""
  channelID: ID!
}

"""CreateChanletPayload returns the new chanlet that was created."""
type CreateChanletPayload {
  """The chanlet that was created."""
  chanlet: Channel!

  """The channelID that the chanlet was created under."""
  channelID: ID!
}

"""CreateClipError is an error associated with the createClip mutation."""
type CreateClipError {
  """The associated error code."""
  code: CreateClipErrorCode
}

"""
CreateClipErrorCode contains the possible errors that can occur when creating a clip.
"""
enum CreateClipErrorCode {
  """This channel cannot be clipped."""
  CHANNEL_NOT_CLIPPABLE

  """The channel has been banned and cannot be clipped."""
  CHANNEL_BANNED

  """User has been banned from the channel and cannot clip."""
  USER_BANNED

  """User has been timed out from the channel and cannot clip."""
  USER_TIMED_OUT

  """Clip cannot be created because channel is no longer live."""
  CHANNEL_NOT_LIVE

  """Clip cannot be created because the request is throttled."""
  REQUEST_THROTTLED

  """User does not have permissions and cannot clip."""
  USER_RESTRICTED

  """Unknown error."""
  UNKNOWN
}

"""
CreateClipInput creates a clip either from a broadcast or video. If both broadcastID
and videoID are set, the broadcastID will be preferred.
"""
input CreateClipInput {
  """The ID of the broadcast to create a clip from."""
  broadcastID: ID

  """The ID of the broadcaster that the broadcast or video belongs to."""
  broadcasterID: ID!

  """
  The number of seconds into the broadcast or video to create the clip from.
  """
  offsetSeconds: Float!

  """The ID of the video to create a clip from."""
  videoID: ID
}

"""
CreateClipPayload returns the created clip or any error that prevented the clip creation.
"""
type CreateClipPayload {
  """
  The created clip has all fields execpt for durationSeconds and viewCount.
  """
  clip: Clip

  """The error when a clip fails to create."""
  error: CreateClipError
}

"""Inputs for creating a new collection."""
input CreateCollectionInput {
  """A description of the collection being created."""
  description: String

  """The id of the user who will own the collection."""
  ownerID: ID!

  """The title of the collection being created."""
  title: String!
}

"""The response from creating a new collection."""
type CreateCollectionPayload {
  """The newly created collection."""
  collection: Collection
}

"""Create community goal error."""
type CreateCommunityPointsCommunityGoalError {
  """The error code."""
  code: CreateCommunityPointsCommunityGoalErrorCode!
}

"""Create community goal error code."""
enum CreateCommunityPointsCommunityGoalErrorCode {
  """Goal already exists."""
  DUPLICATE_GOAL

  """Goal title failed automod."""
  TITLE_AUTOMOD_FAILED

  """Goal title is invalid."""
  TITLE_INVALID

  """Goal description failed automod."""
  DESCRIPTION_AUTOMOD_FAILED

  """Goal description is invalid."""
  DESCRIPTION_INVALID

  """Goal amount is invalid."""
  GOAL_AMOUNT_INVALID

  """Goal duration is invalid."""
  DURATION_INVALID

  """Goal background color is invalid."""
  BACKGROUND_COLOR_INVALID

  """Too many goals already exists."""
  TOO_MANY_GOALS

  """The current user is not allowed to create goals for this channel."""
  FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""Create community goal input."""
input CreateCommunityPointsCommunityGoalInput {
  """The amount of community points that this goal needs to succeed."""
  amountNeeded: Int!

  """The background color of this goal."""
  backgroundColor: String!

  """The channel."""
  channelID: ID!

  """The description of this goal."""
  description: String

  """
  The *initial* duration the streamer set for the goal.
  Only really used during the UNSTARTED state; once the goal is started
  the endedAt timestamp is populated (and updated for extended deadlines).
  """
  durationDays: Int!

  """The title of this goal."""
  title: String!
}

"""Create community goal payload."""
type CreateCommunityPointsCommunityGoalPayload {
  """The error, if any."""
  error: CreateCommunityPointsCommunityGoalError

  """The community goal that was created."""
  goal: CommunityPointsCommunityGoal
}

"""An error from creating a custom Community Points reward in a channel."""
type CreateCommunityPointsCustomRewardError {
  """An identifier for the error that occurred."""
  code: CreateCommunityPointsCustomRewardErrorCode!

  """On TOO_MANY_REWARDS, the most custom rewards a channel can have."""
  maxRewards: Int
}

"""
The possible reasons creating a custom Community Points reward in a channel could fail.
"""
enum CreateCommunityPointsCustomRewardErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """The current user is not allowed to create a reward in this channel."""
  FORBIDDEN

  """The title failed AutoMod."""
  TITLE_AUTOMOD_FAILED

  """The prompt failed AutoMod."""
  PROMPT_AUTOMOD_FAILED

  """The cost is invalid. Costs must be greater than 0."""
  COST_INVALID

  """The maxPerStream is invalid. maxPerStream must be greater than 0."""
  MAX_PER_STREAM_INVALID

  """
  The channel has too many rewards. An existing reward must be deleted before you can create a new reward.
  """
  TOO_MANY_REWARDS

  """
  The title is invalid. Titles must not be empty and must be at most 45 characters long.
  """
  TITLE_INVALID

  """
  A reward with the provided title already exists. Custom reward titles must be unique.
  """
  DUPLICATE_REWARD

  """
  The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
  """
  BACKGROUND_COLOR_INVALID

  """
  The template id provided is invalid. Template id must be the id for a valid template or null.
  """
  TEMPLATE_INVALID

  """
  The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0.
  """
  MAX_PER_USER_PER_STREAM_INVALID

  """The globalCooldown is invalid. globalCooldown must be greater tham 0."""
  GLOBAL_COOLDOWN_INVALID
}

"""Input for creating a custom Community Points reward in a channel."""
input CreateCommunityPointsCustomRewardInput {
  """
  The optional custom background color for this reward.
  Should be a hex color string, for example "FF0000".
  """
  backgroundColor: String

  """The channel ID that the reward is being created in."""
  channelID: ID!

  """The point cost of this reward."""
  cost: Int!

  """
  The length of the global cooldown applied to rewards redeemed of this type.
  """
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSettingInput

  """
  Whether only subscribers are allowed to redeem this reward in this channel.
  """
  isSubOnly: Boolean!

  """Whether this reward requires users to enter text input."""
  isUserInputRequired: Boolean!

  """The most rewards of this type that can be redeemed per stream."""
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSettingInput

  """
  The most rewards of this type that can be redeemed per user per stream.
  """
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput

  """The optional user-facing prompt for this reward."""
  prompt: String

  """
  Optional boolean for whether redemptions for this reward should skip the broadcaster's
  request queue and get automatically fulfilled. Defaults to false.
  """
  shouldRedemptionsSkipRequestQueue: Boolean = false

  """
  The id for the CustomRewardTemplate this reward is being created from. Null if a template wasn't used.
  """
  templateID: ID

  """The short title displayed for this reward."""
  title: String!
}

"""
The response from creating a custom Community Points reward in a channel.
"""
type CreateCommunityPointsCustomRewardPayload {
  """
  An error that occurred while creating a custom Community Points reward in a channel.
  """
  error: CreateCommunityPointsCustomRewardError

  """The newly created reward."""
  reward: CommunityPointsCustomReward
}

"""An error from generating upload info for Community Points images."""
type CreateCommunityPointsImageUploadInfoError {
  """An identifier for the error that occurred."""
  code: CreateCommunityPointsImageUploadInfoErrorCode
}

"""
The possible reasons generating upload info for Community Points images could fail.
"""
enum CreateCommunityPointsImageUploadInfoErrorCode {
  """The current user is not allowed to upload images for this channel."""
  FORBIDDEN

  """More than one image type was specified in the request."""
  MORE_THAN_ONE_TYPE

  """Your provided custom reward ID was not found."""
  CUSTOM_REWARD_NOT_FOUND
}

"""
Input for generating upload info (urls and upload IDs) for uploading Community Points images.
Channel ID is required. Only one of the other three fields should be set, to indicate what the image is being uploaded for.
"""
input CreateCommunityPointsImageUploadInfoInput {
  """
  If set, this request is for uploading new images for the given automatic reward.
  """
  automaticRewardType: CommunityPointsAutomaticRewardType

  """The channel ID to upload images for."""
  channelID: ID!

  """
  If set, this request is for uploading new images for the given custom reward.
  """
  customRewardID: ID

  """
  If set, this request is for uploading new images for the given community goal.
  """
  goalID: ID

  """
  If set, this request is for uploading new images for the channel Community Points icon.
  """
  icon: Boolean
}

"""The response from generating upload info for Community Points images."""
type CreateCommunityPointsImageUploadInfoPayload {
  """An error that occurred retrieving upload info for Community Points."""
  error: CreateCommunityPointsImageUploadInfoError

  """
  The upload info (url and upload ID) for the large version of the image.
  """
  uploadInfoLarge: CommunityPointsImageUploadInfo

  """
  The upload info (url and upload ID) for the medium version of the image.
  """
  uploadInfoMedium: CommunityPointsImageUploadInfo

  """
  The upload info (url and upload ID) for the small version of the image.
  """
  uploadInfoSmall: CommunityPointsImageUploadInfo
}

"""The competition contact info for creates."""
input CreateCompetitionContactInfoInput {
  """Link to Discord server for competition contact purposes."""
  discordURL: String

  """Email address point of contact for the competition."""
  email: String
}

"""Create a Competition."""
input CreateCompetitionInput {
  """Banner image for the competition event page."""
  bannerImageURL: String

  """
  This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
  """
  checkInDurationMinutes: Int!

  """Long form description of the competition."""
  description: String

  """The time the competition is scheduled to end."""
  endAt: Time!

  """
  The competition format type (i.e. enum values of LEADERBOARD, ROUND_ROBIN, SINGLE_ELIM etc.).
  """
  formatType: FormatType!

  """The game_id of the game being played in the competition."""
  gameID: ID!

  """Primary artwork for the competition."""
  imageURL: String

  """The required inputs for leaderboard format."""
  leaderboardDetails: CreateCompetitionLeaderboardDetailsInput

  """The name of the competition."""
  name: String!

  """Owner of the Competition, or filled in as user making the request."""
  ownerID: ID

  """
  The participant-facing points of contact for the competition that only registered players can see.
  """
  participantOnlyContactInfo: CreateCompetitionContactInfoInput

  """The type of participant for the competition. e.g. SOLO, TEAM, ..."""
  participantType: CompetitionParticipantType!

  """
  Long form text block description that explains the prizing for the competition
  and will be converted to Markdown client-side.
  """
  prizeDescription: String

  """The public points of contact for the competition that anyone can see."""
  publicContactInfo: CreateCompetitionContactInfoInput

  """The time the competition is scheduled to end registration."""
  registrationEndAt: Time!

  """
  The maximum number of players in a REGISTERED state. A default value will be set if none is provided.
  """
  registrationLimit: Int = 100

  """
  The type of a registration for the competition. e.g. OPEN, INVITATIONAL, ...
  """
  registrationType: RegistrationType!

  """
  Long form text block description that explains the rules for the competition
  and will be converted to Markdown client-side.
  """
  rulesDescription: String

  """The time the competition is scheduled to start."""
  startAt: Time!

  """
  The state the Competition. Defaults to the UPCOMING state if not specified.
  """
  state: CompetitionState

  """
  The number of players within a single team entity. Must be 1 for solo-type competitions.
  """
  teamSize: Int!

  """Link URL to any additional terms and conditions."""
  termsURL: String
}

"""The required inputs for leaderboard format."""
input CreateCompetitionLeaderboardDetailsInput {
  """
  The max participant count for a lobby in phase. Valid values are 1-100.
  """
  lobbyMaxSize: Int!

  """
  The number of phases to be created for the competition. Valid values are 1-20.
  """
  phaseCount: Int!

  """A label for additional points to resolve a tie."""
  tiebreakerLabel: TiebreakerLabel
}

"""Data that was mutated after the competition was created."""
type CreateCompetitionPayload {
  """The competition that was created."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Create new tags associated with CLIP, STREAM, or VOD with contentID."""
input CreateContentTagsInput {
  """ID of the channel owning the content."""
  authorID: ID!

  """
  ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  """
  contentID: ID!

  """
  Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  """
  contentType: ContentType!

  """List of tag IDs to be added to the content."""
  tagIDs: [ID!]!
}

"""Result of mutation is the updated tags."""
type CreateContentTagsPayload {
  """Content which tags have been added to."""
  content: TaggedContent
}

"""
Error codes for issues that may occur when trying to create a
new Mosaic layout.
"""
enum CreateDashboardViewMosaicLayoutErrorCode {
  """An unhandled error."""
  UNKNOWN

  """User has reached a limit of layouts they can store."""
  CUSTOM_LIMIT_EXCEEDED

  """The name argument is required."""
  INVALID_ARGUMENT_NAME

  """The userID argument is required."""
  INVALID_ARGUMENT_USERID

  """The provided type argument is invalid."""
  INVALID_ARGUMENT_TYPE

  """The layout argument is required."""
  INVALID_ARGUMENT_LAYOUT

  """The version argument is required."""
  INVALID_ARGUMENT_VERSION

  """The channelID argument is required."""
  INVALID_ARGUMENT_CHANNELID

  """
  One or more unspecified aguments are invalid. These are not
  user-actionable, but might indicate a logic error.
  """
  INVALID_ARGUMENT
}

"""
Input parameters for creating a new custom mosaic layout,
such as for Stream Manager, Twitch Studio, etc.
Requires at least the type and id to be specified.
"""
input CreateDashboardViewMosaicLayoutInput {
  """The channel for which to create a new Mosaic layout."""
  channelID: ID!

  """
  The Mosaic data blob (in string form) representing the new Mosaic layout.
  """
  data: MosaicData!

  """The display name of the new Mosaic layout."""
  name: String!

  """
  The type of Mosaic layout being modified, such as for Twitch Studio,
  Stream Manager, etc.
  """
  type: ChannelDashboardViewType!

  """
  The version tag for a Mosaic layout, which can be used for deprecation.
  """
  version: String!
}

"""Result of the createDashboardViewMosaicLayout mutation."""
type CreateDashboardViewMosaicLayoutPayload {
  """Represents an error when attempting to create a layout, if applicable."""
  errorCode: CreateDashboardViewMosaicLayoutErrorCode

  """The the layout that was created."""
  layout: ChannelDashboardLayout
}

"""CreateDropBenefitInput has fields required to create a drop benefit."""
input CreateDropBenefitInput {
  """The redirect URL where a user can link their account."""
  accountLinkURL: String!

  """The ID of this benefit object."""
  benefitID: ID!

  """The display name of this benefit object."""
  benefitName: String!

  """The global limit of how often this benefit can be entitled to a user."""
  entitlementLimit: Int!

  """The game that awarded the Drop."""
  gameID: ID!

  """
  Specifies if this reward is considered for a game that is available on iOS.
  """
  isIosAvailable: Boolean

  """The RBAC organization ID of the owner."""
  ownerID: ID!
}

"""CreateDropBenefitPayload returns the result of the creation."""
type CreateDropBenefitPayload {
  """Returns the created Benefit."""
  dropBenefit: DropBenefit

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
CreateDropCampaignInput has the fields necessary to create a campaign for an RBAC organization.
"""
input CreateDropCampaignInput {
  """The redirect URL where a user can link their account."""
  accountLinkURL: String!

  """
  The type of a campaign defines what type of drops are allowed to be added to the campaign.
  """
  campaignType: CampaignType

  """The description of this campaign."""
  description: String!

  """The URL that links to the details / marketing page for this drop."""
  detailsURL: String!

  """
  The date at which this campaign ends and all contained drops end at the latest.
  """
  endAt: Time!

  """The game associated with this campaign."""
  gameID: ID!

  """The name of the campaign."""
  name: String!

  """
  This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
  """
  ownerID: ID!

  """
  The date at which this campaign starts and all contained drops start the earliest.
  """
  startAt: Time!
}

"""CreateDropCampaignyPayload returns the newly created campaign."""
type CreateDropCampaignPayload {
  """Returns the created Campaign."""
  dropCampaign: DropCampaign

  """
  error, if there was one.
  A mapped error returned by the drops management service.
  """
  error: DropsError
}

"""Possible errors from CreateDropImageUploadURL."""
enum CreateDropImageUploadURLErrorCode {
  """
  The user does not have permissions to create this type of image for this service.
  """
  USER_UNAUTHORIZED

  """There was an issue calling a dependency of this call."""
  SERVICE_DEPENDENCY_FAILURE

  """An issue not matching any other specific error code."""
  UNKNOWN
}

"""Information needed to generate a URL to upload a drop image to."""
input CreateDropImageUploadURLInput {
  """The campaign this image is for if it's of type LINK_NOTIFICATION."""
  campaignID: ID

  """The type of image this is."""
  imageType: DropImageType!

  """The item ID this image is for if it's of type ITEM."""
  itemID: ID

  """The drop service this image will be created for."""
  serviceID: ID!

  """The JWT used to verify the request."""
  token: String!
}

"""
Returned information about image upload including URL to upload the image to.
"""
type CreateDropImageUploadURLPayload {
  """Error (if any) from trying to create the upload URL."""
  error: CreateDropImageUploadURLErrorCode

  """Unique identifier for the generated URL."""
  uploadID: ID

  """The actual URL to be used by the client to upload the image."""
  url: String
}

"""
CreateExtensionClientError is an error associated with the createExtensionClient mutation.
"""
enum CreateExtensionClientError {
  """The specified name was invalid."""
  INVALID_NAME

  """The specified name is already taken by another extension or app."""
  NAME_IN_USE
}

"""CreateExtensionClientInput creates an extension with a given name."""
input CreateExtensionClientInput {
  """name is the name of the extension client ID."""
  name: String!

  """
  organizationID is the organization ID that the extension will be binded with in RBAC.
  """
  organizationID: ID

  """
  redirectURI is the URI that can be used for OAuth login using the extension's client ID.
  """
  redirectURI: String!
}

"""CreateExtensionClientPayload returns the created extension ID."""
type CreateExtensionClientPayload {
  """The created extension client."""
  client: ExtensionClient

  """The error when the mutation fails to create an extension client."""
  error: CreateExtensionClientError
}

"""
CreateExtensionImageUploadInfoError is wrapper for error associated with the createExtensionImageUploadInfo mutation.
"""
type CreateExtensionImageUploadInfoError {
  """Error code."""
  code: CreateExtensionImageUploadInfoErrorCode!

  """
  On TOO_MANY_UPLOAD_DISCOVERY_IMAGE, TOO_MANY_UPLOAD_LOGO_IMAGE
  ,TOO_MANY_UPLOAD_SCREENSHOT_IMAGE, TOO_MANY_UPLOAD_TASKBAR_IMAGE, the maximum
  number of specific image allowed (existing + incoming).
  """
  maximum: Int

  """
  On NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE, NOT_ENOUGH_UPLOAD_LOGO_IMAGE
  ,NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE, NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE, the
  minimum number of screenshots allowed (existing + incoming).
  """
  minimum: Int
}

"""
CreateExtensionImageUploadInfoErrorCode is an error code associated with CreateExtensionImageUploadInfoError.
"""
enum CreateExtensionImageUploadInfoErrorCode {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_VERSION

  """Not enough discovery image to upload. Must >= 0."""
  NOT_ENOUGH_UPLOAD_DISCOVERY_IMAGE

  """Not enough logo image to upload. Must >= 0."""
  NOT_ENOUGH_UPLOAD_LOGO_IMAGE

  """Not enough screenshot image to upload. Must >= 0."""
  NOT_ENOUGH_UPLOAD_SCREENSHOT_IMAGE

  """Not enough taskbar image to upload. Must >= 0."""
  NOT_ENOUGH_UPLOAD_TASKBAR_IMAGE

  """Too many discovery image to upload. Must <= 1."""
  TOO_MANY_UPLOAD_DISCOVERY_IMAGE

  """Too many logo image to upload. Must <= 1."""
  TOO_MANY_UPLOAD_LOGO_IMAGE

  """Too many screenshot image to upload. Must <= 1."""
  TOO_MANY_UPLOAD_SCREENSHOT_IMAGE

  """Too many taskbar image to upload. Must <= 1."""
  TOO_MANY_UPLOAD_TASKBAR_IMAGE
}

"""
Information needed to generate a URL and UploadId to upload extension images to.
"""
input CreateExtensionImageUploadInfoInput {
  """Whether to upload new discovery image."""
  discovery: Boolean

  """The extension:version the images are for."""
  extensionID: ID!

  """Whether to upload new logo image."""
  logo: Boolean

  """Amount of new screenshot image to be uploaded."""
  screenshots: Int

  """Whether to upload new taskbar image."""
  taskbar: Boolean
}

"""
Returned information about images upload including URL to upload the image to.
"""
type CreateExtensionImageUploadInfoPayload {
  """Url and UploadId for discovery."""
  discovery: ExtensionImageUploadResponse

  """The error when the mutation fails to create upload information."""
  error: CreateExtensionImageUploadInfoError

  """Url and UploadId for logo."""
  logo: ExtensionImageUploadResponse

  """Urls and UploadIds for screenshots."""
  screenshots: [ExtensionImageUploadResponse]

  """Url and UploadId for taskbar."""
  taskbar: ExtensionImageUploadResponse
}

"""
CreateExtensionZipUploadInfoError is an error associated with the createExtensionZipUploadInfo mutation.
"""
enum CreateExtensionZipUploadInfoError {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_VERSION
}

"""
Information needed to generate a URL and UploadId to upload extension zip file to.
"""
input CreateExtensionZipUploadInfoInput {
  """The extension:version the zip file is for."""
  extensionID: ID!

  """The file name of the zip file."""
  filename: String
}

"""
Returned information about zip file upload including URL to upload the zip to.
"""
type CreateExtensionZipUploadInfoPayload {
  """The error when the mutation fails to upload a zip file."""
  error: CreateExtensionZipUploadInfoError

  """Url and UploadId for zip file."""
  response: ExtensionZipUploadResponse
}

input CreateFriendRequestInput {
  """
  The authenticated user will send a friend request to the user with an ID equal to targetID.
  """
  targetID: ID!
}

type CreateFriendRequestPayload {
  """The user who is the target of the friend request."""
  user: User
}

"""Error associated with mutation CreateGameApplication."""
type CreateGameApplicationError {
  """Error code."""
  code: CreateGameApplicationErrorCode
}

"""Client error code."""
enum CreateGameApplicationErrorCode {
  """The game has already been owned by another company."""
  GAME_HAS_ALREADY_BEEN_OWNED

  """
  Sumbitting user does not have authorization to create a game application for the organization.
  """
  PERMISSION_DENIED

  """Internal error."""
  INTERNAL_ERROR
}

"""Input to the CreateGameApplication mutation."""
input CreateGameApplicationInput {
  """Company ID."""
  companyID: ID!

  """Game ID."""
  gameID: ID!
}

"""Output from the CreateGameApplication mutation."""
type CreateGameApplicationPayload {
  """The possible error returned from service."""
  error: CreateGameApplicationError

  """The game application."""
  gameApplication: GameApplication
}

"""GameID that needs to upload a box art image."""
input CreateGameBoxArtUploadURLInput {
  """Game identifier."""
  gameID: ID!
}

"""URL info that can be used to upload the image."""
type CreateGameBoxArtUploadURLPayload {
  """response with non-nullable data."""
  response: CreateGameBoxArtUploadURLResponse
}

"""URL info that can be used to upload the image."""
type CreateGameBoxArtUploadURLResponse {
  """Upload id to be used on the upload request."""
  uploadID: ID!

  """
  URL to be used by the client, to upload the image.
  NOTE: The image that is uploaded later must be a 600x800px, no larger than 1 MB, JPEG.
  """
  url: String!
}

"""CreateLoyaltyBadge creates a new badge with these settings."""
input CreateLoyaltyBadgeInput {
  """The channel ID where the badge will be uploaded."""
  channelID: ID!

  """The S3 ID of the 1x sized badge."""
  image1xID: ID!

  """The S3 ID of the 2x sized badge."""
  image2xID: ID!

  """The S3 ID of the 4x sized badge."""
  image4xID: ID!

  """The number of months of the badge."""
  requiredTenureMonths: Int!
}

"""CreateLoyaltyBadgePayload returns the created badge."""
type CreateLoyaltyBadgePayload {
  """The created badge."""
  badge: LoyaltyBadge

  """A code indicating why the create call failed, if it did."""
  errorCode: CreateLoyaltyBadgeResponseCode
}

"""A code indicating why the create call failed, if it did."""
enum CreateLoyaltyBadgeResponseCode {
  """Only eligible users can create a badge."""
  ERR_INVALID_USER

  """The badge image 1x submitted was not valid."""
  ERR_INVALID_BADGE_IMAGE_1X_ID

  """The badge image 2x submitted was not valid."""
  ERR_INVALID_BADGE_IMAGE_2X_ID

  """The badge image 4x submitted was not valid."""
  ERR_INVALID_BADGE_IMAGE_4X_ID

  """The badge tenure submitted was not valid."""
  ERR_INVALID_BADGE_REQUIRED_TENURE_MONTHS

  """Badge already exists for this tenure."""
  ERR_BADGE_EXISTS

  """User is timed out of badge creation."""
  ERR_BADGE_TIMEOUT

  """Unknown error occurred, most likely a server error."""
  ERR_UNKNOWN
}

"""
CreateLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to.
"""
input CreateLoyaltyBadgeUploadConfigInput {
  """The channel ID where the badge will be uploaded."""
  channelID: ID!

  """The size of the badge."""
  size: Int!
}

"""CreateLoyaltyBadgeUploadConfigPayload returns the badge upload config."""
type CreateLoyaltyBadgeUploadConfigPayload {
  """A code indicating why the config call failed, if it did."""
  errorCode: CreateLoyaltyBadgeUploadConfigResponseCode

  """The badge upload config."""
  uploadConfig: LoyaltyBadgeUploadConfig
}

"""A code indicating why the config call failed, if it did."""
enum CreateLoyaltyBadgeUploadConfigResponseCode {
  """Only eligible users can create a badge upload config."""
  ERR_INVALID_USER

  """The badge submitted was not valid."""
  ERR_INVALID_BADGE_SIZE

  """Unknown error occurred, most likely a server error."""
  ERR_UNKNOWN
}

"""The required input to create a moderator comment on a channel."""
input CreateModeratorCommentInput {
  """The channel where the moderator comment was created."""
  channelID: ID!

  """The target of the moderator comment."""
  targetID: ID!

  """The body of the comment."""
  text: String!
}

"""Result of a createModeratorComment mutation."""
type CreateModeratorCommentPayload {
  """The moderator comment created."""
  comment: ModLogsComment
}

"""Input for creating a new highlight with multi-segment support."""
input CreateMultiVideoHighlightInput {
  """Metadata used to create the highlight."""
  metadata: CreateMultiVideoHighlightMetadata!
}

"""Metadata to describe the requested highlight to be created."""
input CreateMultiVideoHighlightMetadata {
  """The ID of the user who created this highlight."""
  creatorID: ID!

  """The long form description of the Highlight content."""
  description: String!

  """The primary game featured in the highlight, if any."""
  game: ID

  """
  List of ordered time ranges from the source VOD used to create the highlight.
  """
  highlightRanges: [HighlightRange!]!

  """The language the highlight content is in."""
  language: String!

  """Discovery tags to associate with the Highlight."""
  tags: [String!]!

  """The title of the the highlight."""
  title: String!
}

"""
Response of highlight creation, the new highlight entering the creation process.
"""
type CreateMultiVideoHighlightPayload {
  """The created Video representing the Highlight."""
  highlight: Video
}

"""Contains the channel ID to create new image upload URL for."""
input CreateMultiviewContentAttributeImageUploadConfigInput {
  """The channel for which the content attribute belongs to."""
  channelID: ID!
}

"""
Payload contains the upload ID and URL, as well as the URL to access the uploaded image.
"""
type CreateMultiviewContentAttributeImageUploadConfigPayload {
  """The channel for which the content attribute belongs to."""
  channel: Channel

  """The URL to access this image once uploaded."""
  imageURL: String!

  """Generated unique identifier for this upload."""
  uploadID: ID!

  """Generated unique URL to upload the image to."""
  uploadURL: String!
}

"""Contains a list of new content attributes to be created."""
input CreateMultiviewContentAttributesInput {
  """
  params is a list of multi-view content attribute params for creating new records.
  """
  params: [MultiviewContentAttributeParams!]!
}

"""Contains the results from the create request."""
type CreateMultiviewContentAttributesPayload {
  """Unprocessed content attributes."""
  failedCreates: [MultiviewContentAttribute!]!

  """Processed content attributes."""
  succeededCreates: [MultiviewContentAttribute!]!
}

"""Error associated with mutation CreateGameApplication."""
type CreateOrganizationApplicationError {
  """Error code."""
  code: CreateOrganizationApplicationErrorCode
}

"""Client error code."""
enum CreateOrganizationApplicationErrorCode {
  """Internal error."""
  INTERNAL_ERROR

  """Invalid Argument."""
  INVALID_ARGUMENT
}

"""Input to the CreateOrganizationApplication mutation."""
input CreateOrganizationApplicationInput {
  """City the applying Organization is located in. e.g. San Fransico."""
  city: String

  """
  Email of the person creating the application.
  Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
  """
  contactEmail: String

  """First Name of person creating the application."""
  contactFirstName: String!

  """Last Name of the person creating the application."""
  contactLastName: String!

  """Title of the person creating the application. e.g. Director of Sales."""
  contactTitle: String!

  """Country the applying organization is located in. e.g. US."""
  country: String!

  """List of game IDs that belong to the applying organization."""
  gameIDs: [ID!]

  """
  Industry the applying organization is operating in e.g. e-sports, gaming, health care, energy.
  """
  industry: String!

  """Reason for wanting to add the organization."""
  joinReason: String

  """The name of applying organization."""
  organizationName: String!

  """
  Indicate which Twitch products the organization wants to manage; e.g. creating
  Drops, managing game box art, accessing game Insights.
  """
  productInterest: String

  """
  Estimated size of the applying organization. e.g. 1-5, 6-20, 21-50, 51-100, 101-1000, and 1000+.
  """
  size: String!

  """State the applying organization is located in. e.g. CA."""
  state: String

  """The type of work the applying organization does."""
  type: OrganizationType!

  """
  The Twitch ID for the user submitting the applicaton.
  Deprecated as the userID now comes off the authenticated user.
  """
  userID: ID

  """The website address for the applying organization."""
  website: String!
}

"""Output from the CreateGameApplication mutation."""
type CreateOrganizationApplicationPayload {
  """The organization application id."""
  applicationID: ID

  """The possible error returned from service."""
  error: CreateOrganizationApplicationError
}

"""
CreateOrganizationInviteError is the error associated with a CreateOrganizationInvite.
"""
type CreateOrganizationInviteError {
  """The associated error code."""
  code: CreateOrganizationInviteErrorCode!
}

"""
CreateOrganizationInviteErrorCode defines a client error that occurred while creating an organization Invite.
"""
enum CreateOrganizationInviteErrorCode {
  """Internal error."""
  INTERNAL_ERROR

  """Invalid Argument."""
  INVALID_ARGUMENT

  """Organization Invite already exists."""
  ALREADY_EXISTS

  """User does not have permission to perform action."""
  PERMISSION_DENIED

  """The user does not exist."""
  USER_NOT_FOUND

  """
  The user doesn't meet the requirements to have this role. For example, when trying to assign the
  "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  """
  MEMBER_INELIGIBLE
}

"""Inputs to the CreateOrganizationInvite mutation."""
input CreateOrganizationInviteInput {
  """The Twitch ID of user being invited to join the organization."""
  inviteeTwitchID: ID!

  """
  The Twitch ID of user being doing the inviting and is already a member of the organization.
  """
  inviterTwitchID: ID!

  """The ID of the organization."""
  organizationID: ID!

  """The Role a Invite has in an organization."""
  role: OrganizationMemberRole!
}

"""Outputs from the CreateOrganizationInvite mutation."""
type CreateOrganizationInvitePayload {
  """The possible error returned from the service."""
  error: CreateOrganizationInviteError

  """The created invite. returned on successful creation."""
  invite: OrganizationInvite
}

"""
CreateOrganizationJWTError is the error associated with a CreateOrganizationJWT.
"""
type CreateOrganizationJWTError {
  """The associated error code."""
  code: CreateOrganizationJWTErrorCode!
}

"""
CreateOrganizationJWTErrorCode defines a client error that occurred while creating Organization JWT.
"""
enum CreateOrganizationJWTErrorCode {
  """
  User does not have permission to create the JWT for this operation and company.
  """
  PERMISSION_DENIED

  """The operation passed in was invalid."""
  INVALID_ARGUMENT
}

"""Inputs to the CreateOrganizationJWT mutation."""
input CreateOrganizationJWTInput {
  """Operation to be used in drops to get a jwt for."""
  operation: String!

  """Organization id for which to generate the jwt."""
  organizationID: ID!
}

"""Outputs from the CreateOrganizationJWT mutation."""
type CreateOrganizationJWTPayload {
  """The possible error returned from the service."""
  error: CreateOrganizationJWTError

  """The new orgnizationJWT."""
  jwt: String
}

"""
CreateOrganizationMemberError is the error associated with a CreateOrganizationMember.
"""
type CreateOrganizationMemberError {
  """The associated error code."""
  code: CreateOrganizationMemberErrorCode!
}

"""
CreateOrganizationMemberErrorCode defines a client error that occurred while creating an organization member.
"""
enum CreateOrganizationMemberErrorCode {
  """Organization Member already exists."""
  ALREADY_EXISTS

  """User does not have permission to perform action."""
  PERMISSION_DENIED

  """The user does not exist."""
  USER_NOT_FOUND

  """
  The user doesn't meet the requirements to have this role. For example, when trying to assign the
  "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  """
  MEMBER_INELIGIBLE
}

"""Inputs to the CreateOrganizationMember mutation."""
input CreateOrganizationMemberInput {
  """Users email."""
  email: String!

  """Users first name."""
  firstName: String!

  """Users last name."""
  lastName: String!

  """The ID of the organization."""
  organizationID: ID!

  """The Role a member has in an organization."""
  role: OrganizationMemberRole!

  """Users title."""
  title: String!

  """The user's Twitch ID."""
  userID: ID!
}

"""Outputs from the CreateOrganizationMember mutation."""
type CreateOrganizationMemberPayload {
  """The possible error returned from the service."""
  error: CreateOrganizationMemberError

  """The new orgnizationMember."""
  organizationMember: OrganizationMember
}

"""The upload info struct that is returned from AWS."""
type CreatePanelImageUploadInfo {
  """A unique identifier for the generated URL."""
  uploadID: ID!

  """The actual URL to be used by the client to upload the image."""
  url: String!
}

"""Information required to generate a URL to upload a panel image to."""
input CreatePanelImageUploadInfoInput {
  """The channel the panel belongs to."""
  channelID: ID!

  """The cropped height of the image."""
  height: Int!

  """The left edge of the cropped image."""
  left: Int!

  """The top edge of the cropped image."""
  top: Int!

  """The cropped width of the image."""
  width: Int!
}

"""The response resulting from a successful panel image URL creation."""
type CreatePanelImageUploadInfoPayload {
  """The upload info struct that is returned from AWS."""
  uploadInfo: CreatePanelImageUploadInfo
}

"""
CreatePanelInput contains a panel with created data
The schema here has arguments for both extension panels and default panels
each panel needs a PanelType, and channelID it corresponds to,
but each panel does not need the other arguments
extension panels can have a slotID
default panels can have a title, image, link, and/or description.
"""
input CreatePanelInput {
  channelID: ID!
  description: String
  imageURL: String
  linkURL: String
  slotID: String
  title: String
  type: PanelType!
}

"""CreatePanelPayload contains the panel data after the create succeeds."""
type CreatePanelPayload {
  panel: Panel!
}

"""
CreatePartnershipApplication accepts a userID and other parameters to create the partnership application of a given user.
The required input for a createPartnershipApplicationInput mutation.
"""
input CreatePartnershipApplicationInput {
  """
  Broadcast category (selected by the applicant).
  eg: gaming, creative.
  """
  category: String!

  """
  Country from where the applicant belongs (selected by the applicant).
  eg: US, NZ, UK.
  """
  country: String!

  """Description why the applicant wants to be a partner."""
  description: String!

  """First and last name of the applicant."""
  fullName: String!

  """Broadcast language (selected by the applicant)."""
  language: String!
}

"""
Whether or not the partnership application submission to was successful.
The result of a createPartnershipApplicationInput mutation.
"""
type CreatePartnershipApplicationPayload {
  """
  A successful creation returns the partnership application.
  A failed creation returns null.
  """
  partnershipApplication: PartnershipApplication
}

"""Inputs for creating a choice."""
input CreatePollChoiceInput {
  """Title of the choice."""
  title: String!
}

"""Vote in poll error."""
type CreatePollError {
  """Code describing the error."""
  code: CreatePollErrorCode!
}

"""Vote in poll error code."""
enum CreatePollErrorCode {
  """User attempted to create poll with restricted content."""
  AUTOMOD_FAILED

  """User attempted to create poll when a poll was already active."""
  POLL_ALREADY_ACTIVE

  """
  User attempted to create poll with bits on a channel where bits are not enabled.
  """
  CHANNEL_NOT_BITS_ENABLED

  """An unknown error occurred."""
  UNKNOWN
}

"""Inputs for creating a new poll."""
input CreatePollInput {
  """The cost in bits for casting a vote."""
  bitsCost: Int = 0

  """Denotes if votes can be cast with bits."""
  bitsVoting: Boolean = false

  """Choices that can be voted for in the poll."""
  choices: [CreatePollChoiceInput!]!

  """The cost in Community Points for casting a vote."""
  communityPointsCost: Int = 0

  """Duration of the poll in seconds."""
  durationSeconds: Int!

  """Denotes if votes can be cast with Community Points."""
  isCommunityPointsVotingEnabled: Boolean = false

  """Denotes if the poll allows voting for multiple options."""
  multichoiceEnabled: Boolean = true

  """Id of the channel this poll is owned by."""
  ownedBy: ID!

  """
  Denotes if subscribers receives bonus votes.
  Deprecated: Subscriber multipliers are no longer supported.
  """
  subscriberMultiplier: Boolean = false

  """
  Denotes if the poll is only open to subscribers.
  Deprecated: Subscriber-only polls are no longer supported.
  """
  subscriberOnly: Boolean = false

  """Title of the poll."""
  title: String!
}

"""Outputs from the create poll mutation."""
type CreatePollPayload {
  """If present, there was an error with the request."""
  error: CreatePollError

  """The created poll."""
  poll: Poll
}

input CreatePostInput {
  body: String!
  channelID: ID!
  embedURLs: [String!]
  postToTwitter: Boolean
}

type CreatePostPayload {
  post: Post
  tweet: String
  tweetStatus: Int!
}

"""An error returned from the createPredictionEvent mutation."""
type CreatePredictionEventError {
  """Code describing the error."""
  code: CreatePredictionEventErrorCode!

  """
  If the error code is TOO_MANY_OUTCOMES, this will be the maximum number of Outcomes.
  """
  maxOutcomes: Int

  """
  If the error code is INVALID_PREDICTION_WINDOW, this will be the maximum Prediction Window in seconds.
  """
  maxPredictionWindowSeconds: Int
}

"""Possible error codes from the createPredictionEvent mutation."""
enum CreatePredictionEventErrorCode {
  """
  The current user is forbidden from creating Prediction Events on the specified channel.
  """
  FORBIDDEN

  """User attempted to create a Prediction Event with restricted content."""
  AUTOMOD_FAILED

  """
  There is already an active or pending Prediction Event on the channel. The Event must be resolved before a new
  Prediction Event can be created.
  """
  EVENT_ALREADY_ACTIVE

  """Channel Points are not enabled on this channel."""
  CHANNEL_POINTS_NOT_ENABLED

  """The colors chosen for each Option must be unique."""
  COLORS_NOT_UNIQUE

  """Events must have at least 2 Outcomes."""
  NOT_ENOUGH_OUTCOMES

  """Events have a maximum number of Outcomes."""
  TOO_MANY_OUTCOMES

  """
  The specified Prediction Window is invalid. Prediction window must be positive. Prediction window has a maximum.
  """
  INVALID_PREDICTION_WINDOW

  """An unknown error occurred."""
  UNKNOWN
}

"""Input for creating a Prediction Event."""
input CreatePredictionEventInput {
  """The channel to create the Prediction Event on."""
  channelID: ID!

  """Outcomes that can be chosen in the Prediction Event."""
  outcomes: [CreatePredictionOutcomeInput!]!

  """The duration of the Prediction Window, in seconds."""
  predictionWindowSeconds: Int!

  """The intended title of the Prediction Event."""
  title: String!
}

"""Payload for creating a prediction event."""
type CreatePredictionEventPayload {
  """If present, there was an error with the request."""
  error: CreatePredictionEventError

  """The created Prediction Event."""
  predictionEvent: PredictionEvent
}

"""Input for creating a Prediction Outcome."""
input CreatePredictionOutcomeInput {
  """Color of the Outcome."""
  color: PredictionOutcomeColor!

  """Title of the Outcome."""
  title: String!
}

"""CreateRaidError is the error associated with a createRaid."""
type CreateRaidError {
  """The associated error code."""
  code: CreateRaidErrorCode!
}

"""
CreateRaidErrorCode are the possible errors that this mutation returns.
"""
enum CreateRaidErrorCode {
  """The user is already raiding another channel."""
  ALREADY_RAIDING

  """The user tries to raid themselves."""
  CANNOT_RAID_YOURSELF

  """The user tries to raid an unraidable channel."""
  CANNOT_RAID_THIS_CHANNEL

  """The request is missing valid channel parameters."""
  INVALID_CHANNEL

  """The user tries to raid with too many viewers."""
  TOO_MANY_VIEWERS_TO_RAID
}

"""Inputs to the createRaid mutation."""
input CreateRaidInput {
  """
  Caller is expected to be a channel owner, editor, or staff.
  User ID of the source channel hosting the raid.
  """
  sourceID: ID!

  """User ID of the target channel."""
  targetID: ID!
}

"""Outputs from the createRaid mutation."""
type CreateRaidPayload {
  """The possible error returned from the service."""
  error: CreateRaidError

  """The created raid."""
  raid: Raid
}

"""Inputs to the createRewardedVideo mutation."""
input CreateRewardedVideoTokenInput {
  """userID requesting the rewarded video token."""
  userID: ID!
}

"""Outputs from the createRewardedVideo mutation."""
type CreateRewardedVideoTokenPayload {
  """token used to initialize the truex client application."""
  token: String
}

type CreateRoomError {
  code: CreateRoomErrorCode!

  """On MAX_ROOMS_LIMIT_EXCEEDED: Maximum number of rooms user can create."""
  maxAllowedRooms: Int

  """
  On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters.
  """
  maxLength: Int

  """
  On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters.
  """
  minLength: Int
}

enum CreateRoomErrorCode {
  """Name too short or too long."""
  NAME_LENGTH_INVALID

  """Name contains invalid characters (e.g. spaces)."""
  NAME_CONTAINS_INVALID_CHARACTERS

  """Name failed automod check."""
  NAME_INAPPROPRIATE

  """Name was not unique to channel."""
  NAME_NOT_UNIQUE

  """Topic too short or too long."""
  TOPIC_LENGTH_INVALID

  """Topic failed automod check."""
  TOPIC_INAPPROPRIATE

  """User cannot create any more rooms."""
  MAX_ROOMS_LIMIT_EXCEEDED

  """
  Invalid roles specified (e.g. a more permissive role for send than read).
  """
  ROLES_INVALID
}

input CreateRoomInput {
  """Deprecated. Use minimumReadMessagesRole instead."""
  isPreviewable: Boolean

  """
  Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead.
  """
  minimumAllowedRole: RoomRole

  """Minimum role required to read messages in the room."""
  minimumReadMessagesRole: RoomRole

  """Minimum role required to send messages in the room."""
  minimumSendMessagesRole: RoomRole

  """The name of the room."""
  name: String!

  """The topic for the room."""
  topic: String!
}

type CreateRoomPayload {
  error: CreateRoomError
  room: Room
}

"""The possible errors."""
enum CreateScheduleError {
  """Channel already has a schedule."""
  ALREADY_EXISTS

  """Cannot create a schedule for this channel."""
  PERMISSION_DENIED
}

"""The input to create a schedule."""
input CreateScheduleInput {
  """The channel ID the schedule belongs to."""
  channelID: ID!
}

"""The payload returned after creating a schedule."""
type CreateSchedulePayload {
  """The channel with the new schedule."""
  channel: Channel

  """The possible error."""
  error: CreateScheduleError
}

"""
CreateScheduleSegmentError is a wrapper for error associated with the CreateScheduleSegment mutation.
"""
type CreateScheduleSegmentError {
  """Error code."""
  code: CreateScheduleSegmentErrorCode!

  """
  If the error is related to overlapping segments, provide the existing segment causing a conflict.
  """
  conflictingSegment: ScheduleSegment

  """
  If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
  """
  maximum: Int

  """
  If the error is related to an input out of service-defined bounds, provide the minimum allowed value.
  """
  minimum: Int
}

"""The possible errors when creating a schedule segment."""
enum CreateScheduleSegmentErrorCode {
  """Not authorized to edit this user schedule."""
  PERMISSION_DENIED

  """The schedule to create a segment for was not found."""
  NOT_FOUND

  """
  The number of categories is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_CATEGORY_COUNT

  """The segment time overlaps with another segment time."""
  OVERLAPPING_SEGMENTS

  """
  The title length is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_TITLE

  """The title failed the moderation check."""
  TITLE_FAILED_MODERATION

  """The timezone is not valid."""
  INVALID_TIMEZONE

  """The category is not valid."""
  INVALID_CATEGORIES

  """The the start day is not valid."""
  INVALID_START_DAY

  """The start hour is not valid."""
  INVALID_START_HOUR

  """The start minute is not valid."""
  INVALID_START_MINUTE

  """
  The duration is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_DURATION

  """The segment is invalid."""
  INVALID_SEGMENT

  """The input is not valid."""
  INVALID_ARGUMENT

  """
  The number of segments is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_SEGMENT_COUNT

  """
  The count for the number of times segment should repeat is invalid. The value must be 0 or greater.
  """
  REPEAT_ENDS_AFTER_COUNT_INVALID

  """The segment first occurrence date is set in the past."""
  FIRST_OCCURRENCE_DATE_IN_PAST
}

"""The input to create a new schedule segment."""
input CreateScheduleSegmentInput {
  """The categories of the new segment."""
  categories: [ID!]!

  """The duration of the segment in minutes."""
  durationMinutes: Int

  """The start date and time of the first occurrence of the segment."""
  firstOccurrenceDate: Time

  """
  The number of times the segment should repeat. If 1, this is a single segment.
  """
  repeatEndsAfterCount: Int

  """The ID of the schedule."""
  scheduleID: ID!

  """The start time of the new segment. Ignored for single segments."""
  start: SegmentStartTimeInput

  """
  The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles".
  """
  timezone: String!

  """The title of the new segment."""
  title: String
}

"""The payload returned when creating a new schedule segment."""
type CreateScheduleSegmentPayload {
  """The possible error."""
  error: CreateScheduleSegmentError

  """The updated schedule with the created segment."""
  schedule: Schedule
}

"""CreateSocialMediaError is a user error while creating a social media."""
enum CreateSocialMediaError {
  """The title failed moderation."""
  FAILED_TITLE_MODERATION

  """The provided title was too long."""
  TITLE_TOO_LONG

  """The provided url is invalid."""
  INVALID_URL

  """Maximun number of social medias reached."""
  TOO_MANY
}

"""CreateSocialMediaInput creates social media under the given channelID."""
input CreateSocialMediaInput {
  """The ID of the channel the social media should belong to."""
  channelID: ID!

  """The visible text of the social media item."""
  title: String!

  """The web address of the social media item."""
  url: String!
}

"""
CreateSocialMediaPayload returns the new social medias that were created.
"""
type CreateSocialMediaPayload {
  """The channel of the social media that was created."""
  channel: Channel

  """The potential error when creating a social media."""
  error: CreateSocialMediaError
}

"""
CreateSquadStreamInvitationError is the error associated with a createSquadStreamInvitation.
"""
type CreateSquadStreamInvitationError {
  """The associated error code."""
  code: CreateSquadStreamInvitationErrorCode!
}

"""
CreateSquadStreamInvitationErrorCode are the possible errors that this mutation returns.
"""
enum CreateSquadStreamInvitationErrorCode {
  """The squad is already full."""
  SQUAD_FULL

  """The recipient does not have access to squad streams."""
  USER_CANNOT_ACCESS_SQUADS

  """The recipient is already in the squad."""
  USER_ALREADY_IN_SQUAD

  """The recipient is already invited to the squad."""
  INVITATION_ALREADY_EXISTS

  """The sender does not have permission to invite the recipient."""
  INVITATION_BLOCKED

  """The invitation is not valid (e.g. the user is inviting themselves)."""
  INVITATION_INVALID

  """The user is not authorized to invite members to the squad."""
  UNAUTHORIZED
}

"""Inputs to the createSquadStreamInvitation mutation."""
input CreateSquadStreamInvitationInput {
  """
  The user ID of the broadcaster that should be invited to join the squad stream.
  """
  recipientUserID: ID!

  """
  The user ID of the broadcaster that is sending the invitation to join the squad stream.
  """
  senderUserID: ID!
}

"""Outputs from the createSquadStreamInvitation mutation."""
type CreateSquadStreamInvitationPayload {
  """The possible error returned from the service."""
  error: CreateSquadStreamInvitationError

  """The updated squad stream."""
  squadStream: SquadStream
}

"""Inputs to creating a stucco."""
input CreateStuccoInput {
  """ID of the channel this stucco belongs to."""
  channelID: ID!

  """
  Description representing the stucco, should be the words contained in the stucco, used by screen readers.
  """
  description: String!

  """Base64 encoded binary data of the 92x28px stucco ("1x") image asset."""
  imageData1x: String!

  """Base64 encoded binary data of the 182x56px stucco ("2x") image asset."""
  imageData2x: String!

  """Base64 encoded binary data of the 368x112px stucco ("4x") image asset."""
  imageData4x: String!

  """
  Text code representing the stucco without any prefixes (prefixes are added in the backend).
  """
  suffix: String!
}

"""Inputs for creating a new stucco pack."""
input CreateStuccoPackInput {
  """Id of the channel this pack is part of."""
  channelID: ID!

  """Updated list of stuccos for this pack."""
  stuccos: [CreateStuccoPackItemInput!]
}

"""
Single item in a stuccopack, as part of the create stucco pack call, representing one stucco to be used in a certain slot.
"""
input CreateStuccoPackItemInput {
  """Slot index in the pack (used for ordering)."""
  slotIndex: Int!

  """Id of the stucco."""
  stuccoID: ID!
}

"""Outputs from the create stucco pack mutation."""
type CreateStuccoPackPayload {
  """The created stucco pack."""
  stuccoPack: StuccoPack
}

"""The output for the create update stucco mutation."""
type CreateStuccoPayload {
  """The created or updated stucco."""
  stucco: Stucco
}

"""Error from create unban request mutation."""
type CreateUnbanRequestError {
  """Error code from create unban request mutation."""
  code: CreateUnbanRequestErrorCode!
}

"""Error codes from create unban request mutation."""
enum CreateUnbanRequestErrorCode {
  """User already has a request for the current ban."""
  ALREADY_CREATED

  """User is not banned in the channel."""
  NOT_BANNED

  """
  User is attempting to create a request too since their ban. Must wait for cooldown period to end.
  """
  TOO_SOON_SINCE_BAN

  """Channel is not receiving unban requests."""
  UNBAN_REQUESTS_DISABLED

  """Unknown error."""
  UNKNOWN
}

"""Required input to create an unban request on a channel."""
input CreateUnbanRequestInput {
  """Channel on which requester is requesting an unban."""
  channelID: ID!

  """Custom message from unban requester to attach to unban request."""
  requesterMessage: String!
}

"""Result of a createUnbanRequest mutation."""
type CreateUnbanRequestPayload {
  """Error from attempting to create unban request."""
  error: CreateUnbanRequestError

  """The newly created unban request."""
  unbanRequest: UnbanRequest
}

"""CreateVideoAppealInput details needed to create a video appeal."""
input CreateVideoAppealInput {
  """city is the appeal city."""
  city: String!

  """country is the appeal country."""
  country: String!

  """fullName is the appeal full name."""
  fullName: String!

  """state is the appeal state."""
  state: String!

  """streetAddress1 is the appeal street address 1."""
  streetAddress1: String!

  """streetAddress2 is the appeal street address 2."""
  streetAddress2: String

  """trackAppeals is list of tracks that are being appealed."""
  trackAppeals: [TrackAppealRequestInput!]!

  """videoID is the id of the vod that this appeal is for."""
  videoID: ID!

  """zipcode is the appeal zipcode."""
  zipcode: String!
}

"""CreateVideoAppealPayload the ID of the video for the appeal made."""
type CreateVideoAppealPayload {
  """The ID of the Vod this appeal was created for."""
  videoID: ID
}

"""
CreateVideoBookmarkError is the error associated with a createVideoBookmark.
"""
type CreateVideoBookmarkError {
  """The associated error code."""
  code: CreateVideoBookmarkErrorCode
}

"""
CreateVideoBookmarkErrorCode are the possible errors that this mutation returns.
"""
enum CreateVideoBookmarkErrorCode {
  """The broadcaster is not live."""
  BROADCASTER_NOT_LIVE

  """Archives are disabled for the channel."""
  ARCHIVES_DISABLED

  """The rerun broadcast format is unsupported.."""
  BROADCAST_FORMAT_INVALID_RERUN

  """The premiere broadcast format is unsupported."""
  BROADCAST_FORMAT_INVALID_PREMIERE

  """The VOD for the associated broadcast is not yet ready."""
  VOD_NOT_READY

  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """The user is unauthorized to create the bookmark."""
  USER_UNAUTHORIZED

  """The description length has exceeded the max length."""
  MAX_DESCRIPTION_LENGTH_EXCEEDED
}

"""Input for creating a new bookmark."""
input CreateVideoBookmarkInput {
  """ID of the broadcast the bookmark is made for."""
  broadcastID: ID

  """Channel ID of the channel the bookmark is made for."""
  channelID: ID

  """A description for the bookmark."""
  description: String

  """
  The medium where the request came from.
  e.g. "popout_chat", "chat", "live_dashboard_button", "live_dashboard_hotkey", "live_dashboard_chat".
  """
  medium: String!

  """
  The platform where the request came from.
  e.g."web", "android", "ios".
  """
  platform: String!
}

"""Response for creating a bookmark, the bookmark that was created."""
type CreateVideoBookmarkPayload {
  """Error of the create video bookmark request."""
  error: CreateVideoBookmarkError

  """The bookmark that was created."""
  videoBookmark: VideoBookmark
}

input CreateVideoCommentInput {
  """The id of the parent video comment when you reply."""
  commentID: ID

  """Position of the video where this comment will be added."""
  contentOffsetSeconds: Int!

  """The message of the comment."""
  message: String!

  """The id of the video this comment belongs to."""
  videoID: ID!
}

type CreateVideoCommentPayload {
  """The comment that was created."""
  comment: VideoComment!
}

input CreateVideoHighlightInput {
  """
  The time in the source Archive type video that the Highlight will end at.
  """
  endOffsetSeconds: Int!

  """Metadata to set for the highlight."""
  metadata: CreateVideoHighlightMetadata!

  """The id of the Archive type video to create the Highlight from."""
  sourceVideoID: ID!

  """
  The time in the source Archive type video that the Highlight will begin at.
  """
  startOffsetSeconds: Int!
}

input CreateVideoHighlightMetadata {
  """The long form description of the Highlight content."""
  description: String!

  """The primary game featured in the highlight, if any."""
  game: ID

  """The language the highlight content is in."""
  language: String!

  """Discovery tags to associate with the Highlight."""
  tags: [String!]!

  """The title of the the highlight."""
  title: String!
}

type CreateVideoHighlightPayload {
  """The created Video representing the Highlight."""
  highlight: Video!
}

"""Input to CreateVideoThumbnailUploadRequest mutation."""
input CreateVideoThumbnailUploadRequestInput {
  """Crop height of the thumbnail."""
  cropH: Int!

  """Crop width of the thumbnail."""
  cropW: Int!

  """Crop X of the thumbnail."""
  cropX: Int!

  """Crop Y of the thumbnail."""
  cropY: Int!

  """ID of the video being updated."""
  videoID: ID!
}

"""Output from CreateVideoThumbnailUploadRequest mutation."""
type CreateVideoThumbnailUploadRequestPayload {
  """The created thumbnail upload request url."""
  url: String
}

"""Data pertaining to a creator's badge flair for their own channel."""
type CreatorBadgeFlair {
  """The creator's setting for which badge flair, if any, can be displayed."""
  setting: CreatorBadgeFlairSetting

  """The set of badge flair assets for each tier."""
  assets: [CreatorBadgeFlairAsset!]
}

"""
A set of URLs where clients can find the badge flair asset for a given creator at a given tier
"""
type CreatorBadgeFlairAsset {
  """
  The tier to which these flair assets correspond to, as determined by the creator at time of upload.
  """
  tier: CreatorBadgeFlairTier!

  """The "1x" dimension (18x18) image URL."""
  image1xURL: String!

  """The "2x" dimension (36x36) image URL."""
  image2xURL: String!

  """The "4x" dimension (72x72) image URL."""
  image4xURL: String!
}

"""
Setting for a user's channel that indicates what type of badge flair, if any,
is available for eligible subscribers to select.
"""
enum CreatorBadgeFlairSetting {
  """Indicates no badge flair is available."""
  NONE

  """
  Indicates badge flair using the default Twitch-provided flair asset is available.
  """
  DEFAULT

  """
  Indicates badge flair using a custom user-provided flair asset is available.
  """
  CUSTOM
}

"""Valid subscription tiers that custom badge flair can be associated to."""
enum CreatorBadgeFlairTier {
  """Tier 2 subscriptions (sometimes represented with string "2000")."""
  TIER_2

  """Tier 3 subscriptions (sometimes represented with string "3000")."""
  TIER_3
}

"""
A CreatorCampArticle is a represenation of an article from
https://www.twitch.tv/creatorcamp.
"""
type CreatorCampArticle {
  """
  The ID of the article is also a human readable "slug" e.g. "twitch-101".
  """
  id: ID!

  """The locale associated with this article's translations."""
  locale: String!

  """A URL pointing to an image associated with this article."""
  previewImage: String

  """A short introduction for the article."""
  previewText: String

  """The localized title of the article."""
  title: String!

  """The cannonical location of this article on the CreatorCamp site."""
  url: String!

  """The length of the article's video in seconds."""
  videoDurationSeconds: Int

  """
  A URL pointing to the embedded video in this article. Most
  CreatorCamp articles have an assoicated video.
  """
  videoURL: String
}

"""
A CreatorCampCategory is a grouping of CreatorCamp articles.
https://www.twitch.tv/creatorcamp.
"""
type CreatorCampCategory {
  """A list of CreatorCamp articles in this category."""
  articles: [CreatorCampArticle!]!

  """
  The ID of the category is also a human-readable "slug" e.g. "learn-the-basics".
  """
  id: ID!

  """The localized title of the category."""
  title: String!
}

"""Creator Dashboard shown in twilight."""
type CreatorDashboard {
  """
  Channel Analytics query for the Channel Analytics Tab in the Creator Dashboard.
  """
  channelAnalytics: ChannelAnalytics
}

"""
The container for creator gifts the creator has. This will be null if the creator
does not have this feature enabled.
"""
type CreatorGifting {
  """The identifier for the creator gifting type. This is the user's ID."""
  id: ID!

  """
  The balance of gift subscriptions the creator has to give. These subscriptions do not pay out to the creator.
  """
  subscriptionsBalance: Int
}

"""Top level Creator Home object, includes data for clusters and panels."""
type CreatorHome {
  """Id for caching."""
  id: ID!

  """Clusters for layout information."""
  clusters: [CreatorHomeCluster!]!
}

"""Predefined clusters for creators."""
type CreatorHomeCluster {
  """Unique identifier for the cluster, i.e. "FAR_FROM_AFFILIATE"."""
  id: ID!
}

"""Creator metrics for the given time period."""
type CreatorMetricsByInterval {
  """Creator metrics aggregated and broken up by the interval length."""
  items: [CreatorMetricsByIntervalItem]
}

"""Creator metrics for the given time period."""
type CreatorMetricsByIntervalItem {
  """Ad breaks in seconds for the time period."""
  adBreaksInSecondsString: String!

  """Ad seconds per hour for the time period."""
  adSecondsPerHour: Float!

  """Average viewers for the time period."""
  averageViewers: Float!

  """Clips views for the time period."""
  clipViewsString: String!

  """Clips created for the time period."""
  clipsCreatedString: String!

  """Number of follows for the time period."""
  followsString: String!

  """Host raids percentage for the time period."""
  hostRaidsPercentage: Float!

  """Live views for the time period."""
  liveViewsString: String!

  """Max viewers for the time period."""
  maxViewersString: String!

  """Time streamed (in minutes) for the time period."""
  minutesStreamedString: String!

  """Minutes watched for the time period."""
  minutesWatchedString: String!

  """New subscriptions for the time period."""
  newSubscriptionsString: String!

  """Promotion clicks for the time period."""
  promotionClickString: String!

  """Promotion displays for the time period."""
  promotionDisplayString: String!

  """Starting timestamp for the time period."""
  timestamp: Time!

  """Total chat messages for the time period."""
  totalChatMessagesString: String!

  """Total chatters for the time period."""
  totalChattersString: String!

  """Unique viewers for the time period."""
  uniqueViewersString: String!
}

"""
Onboarding content and tips that are shown during the streamer onboarding experience.
"""
type CreatorOnboardingContent {
  """The time when the onboarding content was first shown to the user."""
  firstSeenAt: Time

  """The id of the creator onboarding content."""
  id: ID!
}

"""
A url to be shared by a creator to gain referrals, and associated metadata.
"""
type CreatorReferralLink {
  """
  The body text that will show on social media when the associated url is shared -- og:description.
  """
  description: String!

  """The ID of the referral link."""
  id: ID!

  """
  The image that will show on social media when the associated url is shared -- og:image.
  """
  imageURL: String!

  """
  The title text that will show on social media when the associated url is shared -- og:title.
  """
  title: String!

  """The url of the referral link."""
  url: String!
}

"""A paginated list of creator referral links."""
type CreatorReferralLinkConnection {
  """
  The list edges contain CreatorReferralLink with pagination information.
  """
  edges: [CreatorReferralLinkEdge!]!

  """Information about this page of creator referral links."""
  pageInfo: PageInfo!
}

"""An element in a paginated list of creator referral links."""
type CreatorReferralLinkEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the creator referral link for the current edge."""
  node: CreatorReferralLink!
}

"""
Contains a reference to the link object and the number of referrals from that link.
"""
type CreatorReferralLinkStat {
  """
  The reference to the link that caused the associated number of referrals.
  """
  link: CreatorReferralLink!

  """The number of referred users for the given link."""
  referralCount: Int!
}

"""Contains the statistics summary for creator referral link."""
type CreatorReferralSummary {
  """Average referrals per day in the given date range."""
  averageReferrals: Int!

  """List of data points in the summary."""
  days: [CreatorReferralSummaryDay!]!

  """Total referrals in the given date range."""
  totalReferrals: Int!

  """
  Trend of the referrals per day in the given date range, when compared to the previous date range of the same length.
  """
  trend: CreatorReferralTrend!
}

"""
Each data point contains date and list of links with number of referred users.
"""
type CreatorReferralSummaryDay {
  """The date for the enclosed data."""
  date: Time!

  """List of CreatorReferralLinkStat objects on the given date."""
  linkStats: [CreatorReferralLinkStat!]!

  """The total number of referred users on the given date."""
  referralCountSum: Int!
}

"""Specifies the general trend of this data set vs the previous data set."""
enum CreatorReferralTrend {
  """The new data set has increased relative to the previous data set."""
  POSITIVE

  """The new data set has not changed relative to the previous data set."""
  NEUTRAL

  """The new data set has decreased relative to the previous data set."""
  NEGATIVE
}

"""Single item of stats for the time series."""
type CreatorTimeseriesItem {
  """Streamed duration (in minutes)."""
  minutesStreamed: Int

  """Timestamp of the broken down time series."""
  timestamp: Time!

  """Value at the timestamp."""
  value: Float!
}

"""List of timestamp, value metric pairs and total for that metric."""
type CreatorTimeseriesMetric {
  """CreatorTimeseries data (timestamp, value) associated with this metric."""
  items: [CreatorTimeseriesItem!]

  """Total (sum) of all CreatorTimeseriesMetrics values."""
  total: Int!
}

"""
Metrics within a time frame broken down by granularity.
This is used for per team stats, per channel stats use "TimeseriesStats".
"""
type CreatorTimeseriesMetrics {
  """Seconds of ads played per time chunk."""
  adBreaksInSeconds: CreatorTimeseriesMetric!

  """Ad time (in seconds) per hour per time chunk."""
  adTimePerHour: CreatorTimeseriesMetric!

  """Average number of viewers per time chunk."""
  averageViewers: CreatorTimeseriesMetric!

  """Number of chat messages per time chunk."""
  chatMessages: CreatorTimeseriesMetric!

  """Number of clip views per time chunk."""
  clipViews: CreatorTimeseriesMetric!

  """Number of clips created per time chunk."""
  clipsCreated: CreatorTimeseriesMetric!

  """Number of follows during this timestamp."""
  follows: CreatorTimeseriesMetric!

  """Granularity of the time series, default unit is five minutes."""
  granularity: Granularity!

  """Host/Raid viewers per time chunk."""
  hostRaidViewers: CreatorTimeseriesMetric!

  """Live number of views per time chunk."""
  liveViews: CreatorTimeseriesMetric!

  """Max viewers per time chunk."""
  maxViewers: CreatorTimeseriesMetric!

  """Minutes watched per time chunk."""
  minutesWatched: CreatorTimeseriesMetric!

  """Number of subscriptions per time chunk."""
  newSubscriptions: CreatorTimeseriesMetric!

  """Promotion clicks for the time period."""
  promotionClick: CreatorTimeseriesMetric!

  """Promotion displays for the time period."""
  promotionDisplay: CreatorTimeseriesMetric!

  """Time streamed per time chunk."""
  timeStreamed: CreatorTimeseriesMetric!

  """Number of people chatting per time chunk."""
  uniqueChatters: CreatorTimeseriesMetric!

  """Number of unique people watching per time chunk."""
  uniqueViewers: CreatorTimeseriesMetric!
}

"""CreditChargeModel defines a charge model using non-FIAT currencies."""
type CreditChargeModel {
  """The value of the credit."""
  amount: Int!

  """The type of credit."""
  creditType: CreditType!
}

"""Types of non-fiat currencies."""
enum CreditType {
  """Indicates that there is no specific type of Credit in this model."""
  NO_CREDIT_TYPE

  """A sub token type."""
  SUB_TOKEN
}

"""Possible values of actionPrompted in SubmitCSATFeedbackInput."""
enum CSATActionPrompted {
  """
  The user registers their client app (i.e. save information for an app), in their personal console.
  """
  CLIENT_APP_REGISTER

  """The user creates a new drop campaign."""
  DROP_CREATE_CAMPAIGN

  """The user moves a drop's state to active."""
  DROP_MOVE_STATE_TO_ACTIVE

  """The user move's a drop's state to testing."""
  DROP_MOVE_STATE_TO_TESTING

  """The user creates a new extension."""
  EXTENSION_CREATE

  """The user changes the state of an extension."""
  EXTENSION_STATE_CHANGE

  """The user views the analytics page of their game."""
  GAMES_VIEW_ANALYTICS

  """The user submits box art for their game."""
  GAMES_SUBMIT_BOX_ART

  """The user creates a new organization."""
  ORGANIZATION_CREATE

  """The user adds another user to their organization."""
  ORGANIZATION_ADD_USER
}

"""Possible ratings that the user can submit as part of their feedback."""
enum CSATRating {
  """The user selects "Very Dissatisfied"."""
  VERY_DISSATISFIED

  """The user selects "Somewhat Dissatisfied"."""
  SOMEWHAT_DISSATISFIED

  """The user selects "Neutral"."""
  NEUTRAL

  """The user selects "Somewhat Satisfied"."""
  SOMEWHAT_SATISFIED

  """The user selects "Very Satisfied"."""
  VERY_SATISFIED
}

"""An enumeration of ISO 4217 currencies accepted by the API."""
enum Currency {
  """Afghani currency."""
  AFN

  """Euro currency."""
  EUR

  """Lek currency."""
  ALL

  """Algerian Dinar currency."""
  DZD

  """US Dollar currency."""
  USD

  """Kwanza currency."""
  AOA

  """East Caribbean Dollar currency."""
  XCD

  """Argentine Peso currency."""
  ARS

  """Armenian Dram currency."""
  AMD

  """Aruban Florin currency."""
  AWG

  """Australian Dollar currency."""
  AUD

  """Azerbaijan Manat currency."""
  AZN

  """Bahamian Dollar currency."""
  BSD

  """Bahraini Dinar currency."""
  BHD

  """Taka currency."""
  BDT

  """Barbados Dollar currency."""
  BBD

  """Belarusian Ruble currency."""
  BYN

  """Belize Dollar currency."""
  BZD

  """CFA Franc BCEAO currency."""
  XOF

  """Bermudian Dollar currency."""
  BMD

  """Indian Rupee currency."""
  INR

  """Ngultrum currency."""
  BTN

  """Boliviano currency."""
  BOB

  """Mvdol currency."""
  BOV

  """Convertible Mark currency."""
  BAM

  """Pula currency."""
  BWP

  """Norwegian Krone currency."""
  NOK

  """Brazilian Real currency."""
  BRL

  """Brunei Dollar currency."""
  BND

  """Bulgarian Lev currency."""
  BGN

  """Burundi Franc currency."""
  BIF

  """Cabo Verde Escudo currency."""
  CVE

  """Riel currency."""
  KHR

  """CFA Franc BEAC currency."""
  XAF

  """Canadian Dollar currency."""
  CAD

  """Cayman Islands Dollar currency."""
  KYD

  """Chilean Peso currency."""
  CLP

  """Unidad de Fomento currency."""
  CLF

  """Yuan Renminbi currency."""
  CNY

  """Colombian Peso currency."""
  COP

  """Unidad de Valor Real currency."""
  COU

  """Comorian Franc currency."""
  KMF

  """Congolese Franc currency."""
  CDF

  """New Zealand Dollar currency."""
  NZD

  """Costa Rican Colon currency."""
  CRC

  """Kuna currency."""
  HRK

  """Cuban Peso currency."""
  CUP

  """Peso Convertible currency."""
  CUC

  """Netherlands Antillean Guilder currency."""
  ANG

  """Czech Koruna currency."""
  CZK

  """Danish Krone currency."""
  DKK

  """Djibouti Franc currency."""
  DJF

  """Dominican Peso currency."""
  DOP

  """Egyptian Pound currency."""
  EGP

  """El Salvador Colon currency."""
  SVC

  """Nakfa currency."""
  ERN

  """Ethiopian Birr currency."""
  ETB

  """Falkland Islands Pound currency."""
  FKP

  """Fiji Dollar currency."""
  FJD

  """CFP Franc currency."""
  XPF

  """Dalasi currency."""
  GMD

  """Lari currency."""
  GEL

  """Ghana Cedi currency."""
  GHS

  """Gibraltar Pound currency."""
  GIP

  """Quetzal currency."""
  GTQ

  """Pound Sterling currency."""
  GBP

  """Guinean Franc currency."""
  GNF

  """Guyana Dollar currency."""
  GYD

  """Gourde currency."""
  HTG

  """Lempira currency."""
  HNL

  """Hong Kong Dollar currency."""
  HKD

  """Forint currency."""
  HUF

  """Iceland Krona currency."""
  ISK

  """Rupiah currency."""
  IDR

  """Iranian Rial currency."""
  IRR

  """Iraqi Dinar currency."""
  IQD

  """New Israeli Sheqel currency."""
  ILS

  """Jamaican Dollar currency."""
  JMD

  """Yen currency."""
  JPY

  """Jordanian Dinar currency."""
  JOD

  """Tenge currency."""
  KZT

  """Kenyan Shilling currency."""
  KES

  """Won currency."""
  KRW

  """Kuwaiti Dinar currency."""
  KWD

  """Som currency."""
  KGS

  """Lao Kip currency."""
  LAK

  """Lebanese Pound currency."""
  LBP

  """Loti currency."""
  LSL

  """Rand currency."""
  ZAR

  """Liberian Dollar currency."""
  LRD

  """Libyan Dinar currency."""
  LYD

  """Swiss Franc currency."""
  CHF

  """Pataca currency."""
  MOP

  """Denar currency."""
  MKD

  """Malagasy Ariary currency."""
  MGA

  """Malawi Kwacha currency."""
  MWK

  """Malaysian Ringgit currency."""
  MYR

  """Rufiyaa currency."""
  MVR

  """Ouguiya currency."""
  MRU

  """Mauritius Rupee currency."""
  MUR

  """ADB Unit of Account currency."""
  XUA

  """Mexican Peso currency."""
  MXN

  """Mexican Unidad de Inversion (UDI) currency."""
  MXV

  """Moldovan Leu currency."""
  MDL

  """Tugrik currency."""
  MNT

  """Moroccan Dirham currency."""
  MAD

  """Mozambique Metical currency."""
  MZN

  """Kyat currency."""
  MMK

  """Namibia Dollar currency."""
  NAD

  """Nepalese Rupee currency."""
  NPR

  """Cordoba Oro currency."""
  NIO

  """Naira currency."""
  NGN

  """Rial Omani currency."""
  OMR

  """Pakistan Rupee currency."""
  PKR

  """Balboa currency."""
  PAB

  """Kina currency."""
  PGK

  """Guarani currency."""
  PYG

  """Sol currency."""
  PEN

  """Philippine Peso currency."""
  PHP

  """Zloty currency."""
  PLN

  """Qatari Rial currency."""
  QAR

  """Romanian Leu currency."""
  RON

  """Russian Ruble currency."""
  RUB

  """Rwanda Franc currency."""
  RWF

  """Saint Helena Pound currency."""
  SHP

  """Tala currency."""
  WST

  """Dobra currency."""
  STN

  """Saudi Riyal currency."""
  SAR

  """Serbian Dinar currency."""
  RSD

  """Seychelles Rupee currency."""
  SCR

  """Leone currency."""
  SLL

  """Singapore Dollar currency."""
  SGD

  """Sucre currency."""
  XSU

  """Solomon Islands Dollar currency."""
  SBD

  """Somali Shilling currency."""
  SOS

  """South Sudanese Pound currency."""
  SSP

  """Sri Lanka Rupee currency."""
  LKR

  """Sudanese Pound currency."""
  SDG

  """Surinam Dollar currency."""
  SRD

  """Lilangeni currency."""
  SZL

  """Swedish Krona currency."""
  SEK

  """WIR Euro currency."""
  CHE

  """WIR Franc currency."""
  CHW

  """New Taiwan Dollar currency."""
  TWD

  """Somoni currency."""
  TJS

  """Tanzanian Shilling currency."""
  TZS

  """Baht currency."""
  THB

  """Pa’anga currency."""
  TOP

  """Trinidad and Tobago Dollar currency."""
  TTD

  """Tunisian Dinar currency."""
  TND

  """Turkish Lira currency."""
  TRY

  """Turkmenistan New Manat currency."""
  TMT

  """Uganda Shilling currency."""
  UGX

  """Hryvnia currency."""
  UAH

  """UAE Dirham currency."""
  AED

  """Peso Uruguayo currency."""
  UYU

  """Uruguay Peso en Unidades Indexadas (UI) currency."""
  UYI

  """Unidad Previsional currency."""
  UYW

  """Uzbekistan Sum currency."""
  UZS

  """Vatu currency."""
  VUV

  """Bolívar Soberano currency."""
  VES

  """Dong currency."""
  VND

  """Yemeni Rial currency."""
  YER

  """Zambian Kwacha currency."""
  ZMW

  """Zimbabwe Dollar currency."""
  ZWL
}

"""
CurrentPrimePayout is the detail breakdown of the payout that will be made in this specific payout cycle.
"""
type CurrentPrimePayout {
  """
  pastCyclePayoutAmount is the part of the payout that was earned in previous payout cycle(s).
  """
  pastCyclePayoutAmount: Int!

  """
  thisCyclePayoutAmount is the part of the payout that was earned in this payout cycle itself.
  """
  thisCyclePayoutAmount: Int!

  """totalPayoutAmount is the total amount for this payout."""
  totalPayoutAmount: Int!
}

"""
An opaque identifier for a connection edge. Used for pagination.

This is part of the Relay Cursor Connections Specification:
https://facebook.github.io/relay/graphql/connections.htm.
"""
scalar Cursor

"""
An action (and metadata about the action) which occurred for a channel's Dashboard Activity Feed.
"""
interface DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Unique identifier for this activity."""
  id: ID!

  """When this activity occurred."""
  timestamp: Time!
}

"""
DashboardActivityFeedActivityAlertStatus are the possible alert statuses that an activity's corresponding alert can have.
"""
enum DashboardActivityFeedActivityAlertStatus {
  """The alert failed to be published."""
  FAILED

  """The alert was received when the channel was offline."""
  OFFLINE

  """The alert has been played and will not be seen again."""
  PLAYED

  """The alert is currently being displayed."""
  PLAYING

  """The alert is in the alert queue, but yet to be seen."""
  QUEUED

  """The alert was not queued and will not be displayed."""
  REJECTED

  """The alert was being displayed, but was skipped by the broadcaster."""
  SKIPPED

  """
  The alert was purged from the alert queue by the broadcaster, after being queued originally.
  """
  PURGED
}

"""When a user AutoHosts a channel."""
type DashboardActivityFeedActivityAutoHosting implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """User/Channel who is now AutoHosting the channel."""
  host: User

  """Unique identifier for this AutoHosting action."""
  id: ID!

  """When the host initiated the AutoHosting session."""
  timestamp: Time!

  """Number of viewers from the host channel."""
  viewerCount: Int!
}

"""When a user uses Bits for or sends Bits to a channel."""
type DashboardActivityFeedActivityBitsUsage implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Bits spent."""
  amount: Int!

  """Unique identifier for this Bits usage."""
  id: ID!

  """
  Whether the Cheer was anonymized to other users.
  If true, then `user` is guaranteed to be null.
  """
  isAnonymous: Boolean!

  """When the Bits were used."""
  timestamp: Time!

  """Bits spender."""
  user: User
}

"""When a Boost completes for the given user."""
type DashboardActivityFeedActivityBoostComplete implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """The progress made toward the goalTarget."""
  goalProgress: Int!

  """The target size for the boost order."""
  goalTarget: Int!

  """Unique identifier for this Boost event."""
  id: ID!

  """The user who purchased the boost order."""
  purchaser: User

  """The number of boosts in the order."""
  quantity: Int!

  """When this Boost event occurred."""
  timestamp: Time!
}

"""When a Boost starts for the given user."""
type DashboardActivityFeedActivityBoostStart implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """The progress made toward the goalTarget."""
  goalProgress: Int!

  """The target size for the boost order."""
  goalTarget: Int!

  """Unique identifier for this Boost event."""
  id: ID!

  """The user who purchased the boost order."""
  purchaser: User

  """The number of boosts in the order."""
  quantity: Int!

  """When this Boost event occurred."""
  timestamp: Time!
}

"""When a Celebration event occurs for the given user."""
type DashboardActivityFeedActivityCelebrationPurchaseEvent implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """The effect used for the celebration."""
  effect: CelebrationEffect!

  """Unique identifier for this Celebration event."""
  id: ID!

  """The intensity of the celebration."""
  intensity: CelebrationIntensity!

  """The user who purchased the celebration."""
  purchasingUser: User

  """When this Celebration event occurred."""
  timestamp: Time!
}

"""When a user redeems a community points reward on a channel."""
type DashboardActivityFeedActivityCommunityPointsReward implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Unique identifier for this redemption."""
  id: ID!

  """The user that redeemed the reward."""
  redeemingUser: User

  """The redemption object itself."""
  redemption: CommunityPointsCustomRewardRedemption

  """When the reward was redeemed."""
  timestamp: Time!

  """The title of the reward."""
  title: String!

  """The user's text input, if provided."""
  userInput: String
}

"""When a user gifts subscriptions to a community for a channel."""
type DashboardActivityFeedActivityCommunitySubscriptionGifting implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Total subscriptions gifted by the gifter."""
  giftQuantity: Int!

  """Total number of months the gifted subscription lasts for."""
  giftedMonths: Int!

  """Subscription purchaser & gifter."""
  gifter: User

  """Unique identifier for this gifting action."""
  id: ID!

  """
  Whether the subscription gifting was anonymized to other users.
  If true, then `gifter` is guaranteed to be null.
  """
  isAnonymous: Boolean!

  """
  Users who received the gift.
  Maximum count is currently 100.
  """
  recipients: [User!] @deprecated(reason: "Use giftQuantity for total subscriptions")

  """The gifted subscription's tier."""
  tier: SubscriptionTier!

  """When the subscriptions were gifted."""
  timestamp: Time!
}

"""
Paginated list of past activities for a channel's Dashboard Activity Feed.
"""
type DashboardActivityFeedActivityConnection {
  """Activity elements of the list."""
  edges: [DashboardActivityFeedActivityEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""When a Community Goal ends for the channel."""
type DashboardActivityFeedActivityCopoGoalEnd implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """The target number of points for the goal that has ended."""
  goalAmount: Int!

  """The id of the goal that has ended."""
  goalID: ID!

  """The current status of the goal that has ended."""
  goalStatus: CommunityPointsCommunityGoalStatus!

  """The title of the goal that has ended."""
  goalTitle: String!

  """The type of the goal that has ended."""
  goalType: CommunityPointsCommunityGoalType!

  """Unique identifier for this goal end event."""
  id: ID!

  """The number of points contributed towards the goal."""
  pointsContributed: Int!

  """The name of the community points on the channel."""
  pointsName: String

  """When this goal end event occurred."""
  timestamp: Time!
}

"""
When a creator completes a drop quest and a drop can now be claimed by users/viewers.
"""
type DashboardActivityFeedActivityDropClaimWindowOpen implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """The community claimable drop which has been activated."""
  drop: DropObject!

  """Unique identifier for this drop activity."""
  id: ID!

  """When the quest was completed."""
  timestamp: Time!
}

"""
Activity element in a list of past activities of a channel's Dashboard Activity Feed.
"""
type DashboardActivityFeedActivityEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """Activity that occurred."""
  node: DashboardActivityFeedActivity!
}

"""When a user newly follows or refollows a channel."""
type DashboardActivityFeedActivityFollowing implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """User who is now following the channel."""
  follower: User

  """Unique identifier for this follow action."""
  id: ID!

  """When the user followed the channel."""
  timestamp: Time!
}

"""When a user hosts a channel."""
type DashboardActivityFeedActivityHosting implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """User/Channel who is now hosting the channel."""
  host: User

  """Unique identifier for this hosting action."""
  id: ID!

  """When the host initiated the hosting session."""
  timestamp: Time!

  """Number of viewers from the host channel."""
  viewerCount: Int
}

"""When a HypeTrain event occurs for the given user."""
type DashboardActivityFeedActivityHypeTrainEvent implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """The highest level completed on this HypeTrain."""
  completedLevel: Int

  """Unique identifier of the Hype Train."""
  hypeTrainID: ID!

  """Unique identifier for this HypeTrain event."""
  id: ID!

  """When this HypeTrain event occurred."""
  timestamp: Time!

  """The total amount of Bits contributed on this HypeTrain."""
  totalBitsAmount: Int

  """The total count of subs and sub gifts contributed on this HypeTrain."""
  totalSubsCount: Int

  """The type of this HypeTrain event."""
  type: HypeTrainEventType!
}

"""
When a user gifts a single subscription to another individual user for a channel.
"""
type DashboardActivityFeedActivityIndividualSubscriptionGifting implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Total number of months the gifted subscription lasts for."""
  giftedMonths: Int!

  """Subscription purchaser & gifter."""
  gifter: User

  """Unique identifier for this gifting action."""
  id: ID!

  """
  Whether the subscription gifting was anonymized to other users.
  If true, then `gifter` is guaranteed to be null.
  """
  isAnonymous: Boolean!

  """User that received the gift."""
  recipient: User

  """The gifted subscription's tier."""
  tier: SubscriptionTier!

  """When the subscription was gifted."""
  timestamp: Time!
}

"""
When an ingest session begins.
Deprecated type: no longer exists in activity feed.
"""
type DashboardActivityFeedActivityIngestSessionStarting implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus @deprecated(reason: "ingest start has been removed from activity feed")

  """Unique identifier for the start of this ingest session."""
  id: ID! @deprecated(reason: "ingest start has been removed from activity feed")

  """Start time of the ingest session."""
  timestamp: Time! @deprecated(reason: "ingest start has been removed from activity feed")
}

"""When a user resubscribes via Twitch Prime to a channel."""
type DashboardActivityFeedActivityPrimeResubscribing implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Duration of the subscription."""
  durationMonths: Int!

  """Unique identifier for the act of renewing the subscription."""
  id: ID!

  """Custom message submitted by the resubscribing user to share in chat."""
  message: String @deprecated(reason: "Use messageContent's fragments for enriching the text")

  """
  Custom message submitted by the resubscribing user to share in chat.
  Message is filtered for moderation and emotes are extracted as message fragments.
  """
  messageContent: MessageContent

  """User who is renewing the subscription."""
  resubscriber: User

  """When the subscription was renewed."""
  timestamp: Time!
}

"""
When a user subscribes for the first time via Twitch Prime to a channel.
"""
type DashboardActivityFeedActivityPrimeSubscribing implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Unique identifier for the act of subscribing."""
  id: ID!

  """User who made the subscription."""
  subscriber: User

  """When the subscription was made."""
  timestamp: Time!
}

"""When a user raids a channel."""
type DashboardActivityFeedActivityRaiding implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Unique identifier for this raiding action."""
  id: ID!

  """Number of users who participated in the raid."""
  partySize: Int! @deprecated(reason: "Renamed to viewerCount")

  """User/Channel who is now raiding the channel."""
  raider: User

  """When the raid was initiated."""
  timestamp: Time!

  """Number of users who participated in the raid."""
  viewerCount: Int!
}

"""When a user resubscribes (NOT via Twitch Prime) to a channel."""
type DashboardActivityFeedActivityResubscribing implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Duration of the subscription."""
  durationMonths: Int!

  """Unique identifier for the act of renewing the subscription."""
  id: ID!

  """Custom message submitted by the resubscribing user to share in chat."""
  message: String @deprecated(reason: "Use messageContent's fragments for enriching the text")

  """
  Custom message submitted by the resubscribing user to share in chat.
  Message is filtered for moderation and emotes are extracted as message fragments.
  """
  messageContent: MessageContent

  """Duration of the multi month subscription."""
  multiMonthDuration: Int!

  """Tenure of the user's current multi month subscription."""
  multiMonthTenure: Int!

  """User who is renewing the subscription."""
  resubscriber: User

  """Subscription tier."""
  tier: SubscriptionTier!

  """When the subscription was renewed."""
  timestamp: Time!
}

"""
When a user subscribes for the first time (NOT via Twitch Prime) to a channel.
"""
type DashboardActivityFeedActivitySubscribing implements DashboardActivityFeedActivity {
  """Status of the corresponding alert."""
  alertStatus: DashboardActivityFeedActivityAlertStatus

  """Unique identifier for the act of subscribing."""
  id: ID!

  """Duration of the multi month subscription."""
  multiMonthDuration: Int!

  """Tenure of the user's current multi month subscription."""
  multiMonthTenure: Int!

  """User who made the subscription."""
  subscriber: User

  """Subscription tier."""
  tier: SubscriptionTier!

  """When the subscription was made."""
  timestamp: Time!
}

"""
Paginated list of past activities for a channel's Dashboard Alert Queue.
"""
type DashboardAlertQueueActivityConnection {
  """Activity elements of the list."""
  edges: [DashboardAlertQueueActivityEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""
Activity element in a list of past activities of a channel's Dashboard Alert Queue.
"""
type DashboardAlertQueueActivityEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """Activity that occurred."""
  node: DashboardActivityFeedActivity!
}

"""
Preferences of a user controlling the types of dashboard alerts to be published.
"""
type DashboardAlertQueuePreferences {
  """If true, cannot publish alerts to the user."""
  isDNDModeEnabled: Boolean!

  """When the preferences were last modified."""
  lastModified: Time

  """If true, cannot publish bits alerts to the user."""
  shouldHideBits: Boolean!

  """If true, cannot publish follows alerts to the user."""
  shouldHideFollows: Boolean!

  """If true, cannot publish subscription gift alerts to the user."""
  shouldHideGiftSubscriptions: Boolean!

  """If true, cannot publish hosts alerts to the user."""
  shouldHideHosts: Boolean!

  """If true, cannot publish raids alerts to the user."""
  shouldHideRaids: Boolean!

  """
  If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown).
  """
  shouldHideSubscriptions: Boolean!
}

"""A shelf title token type that contains a date with various formatters."""
type DateToken {
  """The date to display for this token."""
  time: Time!
}

"""The required input for a deactivateExtension mutation."""
input DeactivateExtensionInput {
  """
  The composite ID of an extension installation <extensionID:version:channelID>.
  """
  extensionInstallationID: ID!
}

"""The resulting payload after a deactivateExtension mutation."""
type DeactivateExtensionPayload {
  """The resulting extension installation record from the deactivate."""
  installedExtension: ExtensionInstallation!
}

"""Error associated with mutation DeclineOrganizationInvite."""
type DeclineOrganizationInviteError {
  """Error code."""
  code: DeclineOrganizationInviteErrorCode!
}

"""Client error code."""
enum DeclineOrganizationInviteErrorCode {
  """Internal error."""
  INTERNAL_ERROR

  """Invitation not found."""
  NOT_FOUND

  """Permission Denied."""
  PERMISSION_DENIED
}

"""Input to the DeclineOrganiztaionInvite mutation."""
input DeclineOrganizationInviteInput {
  """ID of the invite to decline."""
  organizationInviteID: ID!
}

"""Output from the DeclineOrganizationInvite mutation."""
type DeclineOrganizationInvitePayload {
  """The possible error returned from service."""
  error: DeclineOrganizationInviteError
}

"""DefaultPanel is the normal panel type that displays text and images."""
type DefaultPanel implements Panel {
  """
  description is markdown-formatted text to be displayed below the title and image.
  If the panel doesn't have a description this will be null.
  """
  description: String

  """id is a unique identifier for the panel."""
  id: ID!

  """
  imageURL is a URL to an image to be displayed at the top of the panel (but below the header).
  If the panel doesn't use an image this will be null.
  """
  imageURL: String

  """
  linkURL is the URL to navigate to when a user clicks on the image.
  If the panel's image doesn't link anywhere this will be null.
  """
  linkURL: String

  """
  title is the header text to display in the panel.
  If the panel doesn't have a title this will return null.
  """
  title: String

  """type is `PanelType.DEFAULT`."""
  type: PanelType!
}

"""
DeferredPrimePayout is the earning that has been deferred to future payout cycles.
"""
type DeferredPrimePayout {
  """totalPayoutAmount is the total amount for this payout."""
  totalPayoutAmount: Int!
}

"""Inputs for deleting all videos by channel id mutation."""
input DeleteAllChannelVideosInput {
  """The ID of the channel to delete all videos from."""
  channelID: ID!
}

"""The returned payload from the DeleteAllChannelVideos mutation."""
type DeleteAllChannelVideosPayload {
  """The status for this mutation."""
  status: DeleteAllChannelVideosStatus
}

"""Status associated with mutation DeleteAllChannelVideos."""
type DeleteAllChannelVideosStatus {
  """Error code."""
  code: DeleteAllChannelVideosStatusCode!
}

"""The status codes for this mutation."""
enum DeleteAllChannelVideosStatusCode {
  """Deletion job was successful started."""
  SUCCESS

  """User does not have permission to delete videos."""
  FORBIDDEN

  """Internal error."""
  INTERNAL_ERROR

  """Invalid Argument."""
  INVALID_ARGUMENT

  """Unknown Error."""
  UNKNOWN
}

"""The input for delete bits badge tier emoticon."""
input DeleteBitsBadgeTierEmoticonInput {
  """channelID is the owner of the emoticon being deleted."""
  channelID: ID!

  """emoteID is the unique identifier for the emote."""
  emoteID: ID!

  """
  The visual representation of the emote.
  For example, "O_o" instead of "(O|o)_(o|O)".
  """
  text: String!

  """threshold is the badge tier threshold associated with this emoticon."""
  threshold: Int!
}

"""Result of delete bits badge tier emoticon."""
type DeleteBitsBadgeTierEmoticonPayload {
  """Time that the emoticon got deleted."""
  deletedAt: Time
}

"""Inputs for deleting a celebration."""
input DeleteCelebrationInput {
  """ID of celebration to delete."""
  celebrationID: ID!

  """ID of channel where the celebration to delete exists."""
  channelID: ID!
}

"""Outputs from the create celebration mutation."""
type DeleteCelebrationPayload {
  """If present, there was an error with the request."""
  error: CelebrationError
}

"""Errors that the mutation returns."""
type DeleteChannelBlockedTermError {
  """The error code that the mutation returned."""
  code: DeleteChannelBlockedTermErrorCode!
}

"""The errors returned from this mutation."""
enum DeleteChannelBlockedTermErrorCode {
  """User does not have permission to delete blocked term in channel."""
  NO_PERMISSIONS
}

"""
Inputs for the mutation. channel ID and a list of phrases to be deleted.
"""
input DeleteChannelBlockedTermInput {
  """channelID is the owner of the term being deleted."""
  channelID: ID!

  """phrases is the strings representation of the term being deleted."""
  phrases: [String!]!
}

"""The returned payload from the mutation."""
type DeleteChannelBlockedTermPayload {
  """The time term was deleted."""
  deletedAt: Time

  """Mutation error caused by the user input."""
  error: DeleteChannelBlockedTermError

  """The phrases that were deleted."""
  phrases: [String!]!
}

"""Inputs for the deleting a channel's clip."""
input DeleteChannelClipsInput {
  """channelID is the channel's ID."""
  channelID: ID!
}

"""The returned payload from the mutation."""
type DeleteChannelClipsPayload {
  """channelID is the channel's ID."""
  channelID: ID!
}

"""The errors returned from this mutation."""
type DeleteChannelPermittedTermError {
  """Error code that was returned."""
  code: DeleteChannelPermittedTermErrorCode!
}

"""The possible error types returned from this mutation."""
enum DeleteChannelPermittedTermErrorCode {
  """User does not have permission to delete Permitted term in channel."""
  NO_PERMISSIONS
}

"""
Inputs for the mutation. channel ID and a list of phrases to be deleted.
"""
input DeleteChannelPermittedTermInput {
  """channelID is the ID of the owner of the permitted term being deleted."""
  channelID: ID!

  """phrases is the string representation of the term being deleted."""
  phrases: [String!]!
}

"""Returned payload of the mutation."""
type DeleteChannelPermittedTermPayload {
  """The time term was deleted."""
  deletedAt: Time

  """Mutation error caused by the user input."""
  error: DeleteChannelPermittedTermError

  """The phrases that were deleted."""
  phrases: [String!]!
}

"""The input for deleteChatMessage."""
input DeleteChatMessageInput {
  """The channel the message was sent in."""
  channelID: ID!

  """The UUID of the message to be deleted."""
  messageID: ID!
}

"""The returned payload for deleteChatMessage."""
type DeleteChatMessagePayload {
  """The returned message."""
  message: DeletedMessage

  """The response codes for this mutation."""
  responseCode: DeleteChatMessageStatusCode!
}

"""The response codes for this mutation."""
enum DeleteChatMessageStatusCode {
  """Deletion was successful."""
  SUCCESS

  """Deletion was successful. Target user is staff."""
  SUCCESS_STAFF

  """User does not have permission to delete messages."""
  FORBIDDEN

  """Target is the broadcaster."""
  TARGET_IS_BROADCASTER

  """Target is another moderator."""
  TARGET_IS_MODERATOR
}

"""Error returned after attempting to delete a cheermote tier."""
type DeleteCheermoteTierError {
  """The error code associated with this error."""
  code: DeleteCheermoteTierErrorCode!
}

"""Possible error codes for DeleteCheermoteTierError."""
enum DeleteCheermoteTierErrorCode {
  """The user is not allowed to delete this cheermote tier."""
  PERMISSION_DENIED

  """Unknown error."""
  UNKNOWN
}

"""The input for delete cheermote tier."""
input DeleteCheermoteTierInput {
  """Threshold of the cheermote tier to be deleted."""
  tierThreshold: CheermoteTierThreshold!

  """ID of the owner of the cheermote tier being deleted."""
  userID: ID!
}

"""Result of delete cheermote tier."""
type DeleteCheermoteTierPayload {
  """Time that the cheermote tier got deleted."""
  deletedAt: Time

  """Error returned after attempting to delete a cheermote tier."""
  error: DeleteCheermoteTierError
}

"""
DeleteClipsInput accepts either a list of slugs, a video id, or a broadcast id
to determine the clips to delete.
"""
input DeleteClipsInput {
  """The id of the broadcast to delete clips from."""
  broadcastID: ID

  """The list of clip slugs to be deleted."""
  slugs: [ID!]

  """The id of the video to delete clips from."""
  videoID: ID
}

"""
DeleteClipsPayload returns the deleted clips. Only the slug and id can be accessed
from the returned list of deleted clips.
"""
type DeleteClipsPayload {
  """The clips that were deleted. Only Slug and ID can be accessed."""
  clips: [Clip]!

  """The amount of clips that were deleted."""
  count: Int!
}

"""DeleteCollectionInput accepts a collection ID to delete a collection."""
input DeleteCollectionInput {
  """The id of the collection to be deleted."""
  collectionID: ID!
}

"""DeleteCollectionPayload resolves the deleted collection."""
type DeleteCollectionPayload {
  """The collection that was just deleted."""
  collection: Collection!
}

"""Delete community goal error."""
type DeleteCommunityPointsCommunityGoalError {
  """The error code."""
  code: DeleteCommunityPointsCommunityGoalErrorCode!
}

"""Delete community goal error code."""
enum DeleteCommunityPointsCommunityGoalErrorCode {
  """The goal was not found."""
  NOT_FOUND

  """
  The current user is not allowed to delete community goals for this channel.
  """
  FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""Delete community goal input."""
input DeleteCommunityPointsCommunityGoalInput {
  """The channel."""
  channelID: ID!

  """The community goal."""
  goalID: ID!
}

"""Delete community goal payload."""
type DeleteCommunityPointsCommunityGoalPayload {
  """The error, if any."""
  error: DeleteCommunityPointsCommunityGoalError

  """The community goal that was deleted."""
  goal: CommunityPointsCommunityGoal
}

"""An error from deleting a custom Community Points reward in a channel."""
type DeleteCommunityPointsCustomRewardError {
  """An identifier for the error that occurred."""
  code: DeleteCommunityPointsCustomRewardErrorCode!
}

"""
The possible reasons deleting a custom Community Points reward in a channel could fail.
"""
enum DeleteCommunityPointsCustomRewardErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """The current user is not allowed to delete a reward in this channel."""
  FORBIDDEN

  """The reward was not found."""
  NOT_FOUND
}

"""Input for deleting a custom Community Points reward in a channel."""
input DeleteCommunityPointsCustomRewardInput {
  """The channel ID that the reward is being deleted in."""
  channelID: ID!

  """The ID of the reward being deleted."""
  rewardID: ID!

  """
  Rewards cannot be deleted while they have unfulfilled redemptions.
  All unfulfilled redemptions will be set to this new state asynchronously after the reward is deleted.
  """
  unfulfilledRedemptionsNewStatus: CommunityPointsCustomRewardRedemptionStatus = FULFILLED
}

"""
The response from deleting a custom Community Points reward in a channel.
"""
type DeleteCommunityPointsCustomRewardPayload {
  """
  An error that occurred while deleting a custom Community Points reward in a channel.
  """
  error: DeleteCommunityPointsCustomRewardError

  """The now deleted reward."""
  reward: CommunityPointsCustomReward
}

"""Delete a Competition."""
input DeleteCompetitionInput {
  """Unique Competition Id."""
  id: ID!
}

"""Result of the remove operation."""
type DeleteCompetitionPayload {
  """The deleted competition."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Delete tags associated with CLIP, STREAM, or VOD with contentID."""
input DeleteContentTagsInput {
  """ID of the channel owning the content."""
  authorID: ID!

  """
  ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  """
  contentID: ID!

  """
  Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  """
  contentType: ContentType!

  """List of tag IDs to be deleted from the content."""
  tagIDs: [ID!]!
}

"""Result of mutation is the contentID."""
type DeleteContentTagsPayload {
  """Content which tags have been deleted from."""
  content: TaggedContent
}

"""
The input required when making a request to delete a user's default payment method for a given provider.
"""
input DeleteDefaultPaymentMethodInput {
  """The payment provider we're deleting the payment method on."""
  provider: PaymentProvider!

  """The user to delete default payment method for."""
  userID: ID!
}

"""
Payload returned after deleting a default payment method for a given provider.
"""
type DeleteDefaultPaymentMethodPayload {
  """Time when payment method was deleted."""
  updatedAt: Time

  """User who had their default payment method deleted."""
  user: User
}

"""
DeleteDeviceTokenInput accepts a token and user ID and deletes that pair from the database.
"""
input DeleteDeviceTokenInput {
  """The token to be deleted."""
  deviceToken: ID!

  """ID for the user associated with the device token."""
  userID: ID!
}

"""The response from deleting a push notification token from a user."""
type DeleteDeviceTokenPayload {
  """The ID of the token that was deleted."""
  deviceToken: ID!
}

"""A deleted message sent by a user to a stream chat."""
type DeletedMessage {
  """Content of the deleted message."""
  content: RoomMessageContent!

  """UUID of the deleted message."""
  id: ID!

  """Sender of the message."""
  sender: User
}

"""
DeletedMessageDisplaySetting represents the possible settings for how deleted messages should be displayed.
"""
enum DeletedMessageDisplaySetting {
  """
  LEGACY hides deleted messages behind a clickable '<message_deleted>' chat line.
  """
  LEGACY

  """
  BRIEF removes all deleted messages and inserts a system message that reports the number of deleted messages.
  """
  BRIEF

  """
  DETAILED the deleted message is readable but strikethrough and grayed out.
  """
  DETAILED
}

"""DeleteDropCampaignInput has fields required to delete a campaign."""
input DeleteDropCampaignInput {
  """The id of the Drop campaign to be deleted."""
  campaignID: ID!
}

"""DeleteDropCampaignPayload returns the result of the deletion."""
type DeleteDropCampaignPayload {
  """
  A potential error being thrown.
  A mapped error returned by the drops management service.
  """
  error: DropsError
}

"""DeleteDropInput has fields required to delete a drop."""
input DeleteDropInput {
  """The id of the Drop to be deleted."""
  dropID: ID!
}

"""DeleteDropPayload returns the result of the deletion."""
type DeleteDropPayload {
  """
  A potential error being thrown.
  A mapped error returned by the drops management service.
  """
  error: DropsError
}

"""Error returned after attempting to delete an emote."""
type DeleteEmoteError {
  """The error code associated with this error."""
  code: DeleteEmoteErrorCode!
}

"""Possible error codes for DeleteEmoteError."""
enum DeleteEmoteErrorCode {
  """The specified emote does not exist."""
  EMOTE_NOT_FOUND

  """The user is not allowed to delete this emote."""
  PERMISSION_DENIED

  """Unknown error."""
  UNKNOWN
}

"""The input for delete emote."""
input DeleteEmoteInput {
  """ID of the emote to be deleted."""
  id: ID!
}

"""Result of delete emote."""
type DeleteEmotePayload {
  """Error returned after attempting to delete an emote."""
  error: DeleteEmoteError
}

"""Error types returned for the deleteExtension mutation."""
enum DeleteExtensionError {
  """Returned when the extension id was not specified."""
  MISSING_EXTENSION_ID

  """Returned when the id specified could not be found."""
  EXTENSION_NOT_FOUND

  """
  Returned when the calling user does not have access to delete the extension.
  """
  UNAUTHORIZED
}

"""
DeleteExtensionImageError is an error associated with the deleteExtensionImage mutation.
"""
enum DeleteExtensionImageError {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_VERSION

  """Cannot find url in the manifest."""
  CANNOT_FIND_URL_IN_MANIFEST

  """Invalid image url."""
  INVALID_IMAGE_URL
}

"""Information needed to delete images on extension."""
input DeleteExtensionImageInput {
  """The extension:version the images are for."""
  extensionID: ID!

  """Urls to be deleted."""
  urls: [String!]!
}

"""DeleteExtensionImagePayload returns the update Extension manifest."""
type DeleteExtensionImagePayload {
  """The error when the mutation fails to update an extension."""
  error: DeleteExtensionImageError

  """The updated extension manifest."""
  manifest: ExtensionManifest
}

"""Inputs for the deleteExtension mutation."""
input DeleteExtensionInput {
  """ID for the extension being deleted."""
  id: ID!
}

"""The returned payload from the deleteExtension mutation."""
type DeleteExtensionPayload {
  """
  Error response from the deleteExtension mutation.
  null if the delete was successful.
  """
  error: DeleteExtensionError
}

"""
DeleteExtensionImageError is an error associated with the deleteExtensionSecrets mutation.
"""
enum DeleteExtensionSecretsError {
  """User is unable to delete the extension secrets."""
  UNAUTHORIZED
}

"""The information we need to delete the extension's secrets."""
input DeleteExtensionSecretsInput {
  """The extensionID whose secrets should be removed."""
  extensionID: ID!
}

"""Returns nothing but an error, should one occur."""
type DeleteExtensionSecretsPayload {
  """An useful error for the user."""
  error: DeleteExtensionSecretsError
}

"""
Inputs for the mutation. Loyalty Badge to be deleted by channelID, badgeID, and channelTenureMethodID.
"""
input DeleteLoyaltyBadgeInput {
  """badgeID correlated to the badge being deleted."""
  badgeID: ID!

  """channelID correlated to the badge being deleted."""
  channelID: ID!

  """channelTenureMethodID uniquely identifies the badge being deleted."""
  channelTenureMethodID: ID!
}

"""The returned payload from the mutation for Deleting a Loyalty Badge."""
type DeleteLoyaltyBadgePayload {
  """LoyaltyBadge object that was deleted."""
  badge: LoyaltyBadge
}

"""Output from the DeleteModeratorComment mutation."""
input DeleteModeratorCommentInput {
  """ID of the comment to be deleted."""
  ID: ID!
}

"""Output from the DeleteModeratorComment mutation."""
type DeleteModeratorCommentPayload {
  """The deleted comment."""
  comment: ModLogsComment
}

"""Contains a list of IDs of content attributes that are to be deleted."""
input DeleteMultiviewContentAttributesInput {
  """A list of content attribute IDs."""
  IDs: [ID!]!
}

"""Contains the results from the delete request."""
type DeleteMultiviewContentAttributesPayload {
  """Unprocessed content attributes."""
  failedDeletes: [MultiviewContentAttribute!]!

  """Processed content attributes."""
  succeededDeletes: [MultiviewContentAttribute!]!
}

input DeleteNotificationInput {
  """The notification to delete."""
  id: ID!
}

type DeleteNotificationPayload {
  """The notification that was deleted. Only the ID is accessible."""
  notification: OnsiteNotification!
}

input DeletePanelInput {
  id: ID!
}

type DeletePanelPayload {
  panel: Panel!
}

input DeletePostInput {
  postID: ID!
}

type DeletePostPayload {
  post: Post
}

"""Data required to delete recommendation feedback."""
input DeleteRecommendationFeedbackInput {
  """The id of the feedback."""
  feedbackID: ID!

  """The page this event was fired from."""
  sourceItemPage: String!
}

"""Returns the created feedback item back to the client."""
type DeleteRecommendationFeedbackPayload {
  """The id of the feedback you just deleted."""
  feedbackID: ID!
}

input DeleteRoomInput {
  roomID: ID!
}

input DeleteRoomMessageInput {
  messageID: ID!
  roomID: ID!
}

type DeleteRoomMessagePayload {
  message: RoomMessage
}

type DeleteRoomPayload {
  room: Room
}

"""The possible errors when deleting a schedule."""
enum DeleteScheduleError {
  """Not authorized to delete this user schedule."""
  PERMISSION_DENIED
}

"""The input to delete a schedule."""
input DeleteScheduleInput {
  """The channel ID."""
  channelID: ID!

  """The schedule ID."""
  scheduleID: ID!
}

"""The payload returned after deleting a schedule."""
type DeleteSchedulePayload {
  """The channel with the deleted schedule."""
  channel: Channel

  """The possible error."""
  error: DeleteScheduleError
}

"""The possible errors when deleting a schedule segment."""
enum DeleteScheduleSegmentError {
  """Not authorized to delete this segment."""
  PERMISSION_DENIED
}

"""The input to delete a schedule segment."""
input DeleteScheduleSegmentInput {
  """The schedule id."""
  scheduleID: ID!

  """The segment id to delete."""
  segmentID: ID!
}

"""The returned payload when deleting a schedule segment."""
type DeleteScheduleSegmentPayload {
  """The possible error."""
  error: DeleteScheduleSegmentError

  """The updated schedule without the deleted segment."""
  schedule: Schedule
}

"""
Mutation input to delete a social media item by ID under the given channelID.
"""
input DeleteSocialMediaInput {
  """The ID of the channel the social media belongs to."""
  channelID: ID!

  """The ID of the social media item."""
  id: ID!
}

"""DeleteSocialMediaPayload returns an error, if any."""
type DeleteSocialMediaPayload {
  """The channel of the social media that was deleted."""
  channel: Channel
}

"""Errors from deleteSquadStreamInvitation mutation."""
type DeleteSquadStreamInvitationError {
  """Error from request to delete invitation."""
  code: DeleteSquadStreamInvitationErrorCode!
}

"""Possible errors that this mutation returns."""
enum DeleteSquadStreamInvitationErrorCode {
  """Invitation to be deleted does not exist."""
  INVITATION_NOT_FOUND

  """Squad associated with the invitation does not exist."""
  SQUAD_NOT_FOUND

  """User does not have permissions to delete invitation."""
  UNAUTHORIZED

  """Invitation not in pending or rejected state cannot be deleted."""
  INVITATION_CANNOT_BE_DELETED
}

"""Inputs to the deleteSquadStreamInvitation mutation."""
input DeleteSquadStreamInvitationInput {
  """ID of the invitation to be deleted."""
  invitationID: ID!
}

"""Outputs from the deleteSquadStreamInvitation mutation."""
type DeleteSquadStreamInvitationPayload {
  """Error from mutation if exists."""
  error: DeleteSquadStreamInvitationError

  """The deleted invitation."""
  invitation: SquadStreamInvitation
}

"""Error that may be returned by the DeleteStreamAuthorizedUser mutation."""
type DeleteStreamAuthorizedUserError {
  """Type of mutation error."""
  code: DeleteStreamAuthorizedUserErrorCode!
}

"""
DeleteStreamAuthorizedUserErrorCode is the client error type that occurred during the DeleteStreamAuthorizedUser mutation.
"""
enum DeleteStreamAuthorizedUserErrorCode {
  """
  Unable to assign the Targeted user to stream on behalf of the broadcaster.
  """
  TARGET_USER_UNRETURNABLE

  """The broadcaster is not found."""
  CHANNEL_NOT_FOUND

  """Maximum limit for adding authorized user is reached."""
  MAX_ACCOUNT_LIMIT

  """Permission denied to add an authorized user."""
  PERMISSION_DENIED

  """Invalid argument to add an authorized user."""
  INVALID_ARGUMENT
}

"""
DeleteStreamAuthorizedUserInput contains the channelID for the broadcaster and the authorized userID.
"""
input DeleteStreamAuthorizedUserInput {
  """
  authorizedUserID for an authorized user who was allowed to stream on behalf of broadcaster.
  """
  authorizedUserID: ID!

  """channelID of the broadcaster."""
  channelID: ID!
}

"""
DeleteStreamAuthorizedUserPayload contains the VideoStreamSettings with updated authorized users.
"""
type DeleteStreamAuthorizedUserPayload {
  """The updated channel of broadcaster."""
  channel: Channel

  """Error code."""
  error: AddStreamAuthorizedUserError
}

"""Inputs for the deleting clips made by user."""
input DeleteUserClipsInput {
  """userID is the user's ID."""
  userID: ID!
}

"""The returned payload from the mutation."""
type DeleteUserClipsPayload {
  """userID is the user's ID."""
  userID: ID!
}

"""Inputs for the DeleteUserColors mutation."""
input DeleteUserColorsInput {
  """The ID of the user whose creator color is being deleted."""
  userID: ID!
}

"""The returned payload from the DeleteUserColors mutation."""
type DeleteUserColorsPayload {
  """The modified user."""
  user: User
}

type DeleteVideoCommentPayload {
  """The comment that was deleted."""
  comment: VideoComment!
}

"""Inputs for the deleting videos by id mutation."""
input DeleteVideosInput {
  """The IDs of the videos to be deleted."""
  videoIDs: [ID!]!
}

"""The returned payload from the DeleteVideos mutation."""
type DeleteVideosPayload {
  """The list of videos deleted."""
  videos: [Video!]
}

"""Input information for deleting a thumbnail from a video."""
input DeleteVideoThumbnailInput {
  """The thumbnail url path."""
  path: String!

  """ID of the video the thumbnail will be deleted from."""
  videoID: ID!
}

"""Response to a request to delete a video thumbnail."""
type DeleteVideoThumbnailPayload {
  """Video representing the video from which a thumbnail was deleted."""
  video: Video
}

"""Defines ads management attributes for channel."""
type Density {
  """Ad schedule for ads management."""
  adSchedule: [AdSlot!]

  """Duration of auto ads."""
  autoAdLengthSeconds: Int

  """Period inbetween each auto ad."""
  autoAdPeriodMinutes: Int

  """If channel is a custom contract partner."""
  isCCP: Boolean!

  """Minutes elapsed since stream started."""
  minutesElapsed: Int

  """If contract is enforced on this channel."""
  shouldEnforceContract: Boolean!

  """Ad density target for a specific channel."""
  targetAdMinutes: Int

  """Total amount of ad time."""
  totalAdSeconds: Int
}

input DenyRejectedChatMessageInput {
  id: ID!
}

type DenyRejectedChatMessagePayload {
  message: RejectedChatMessage
}

"""Input to the denyRejectedCheer mutation."""
input DenyRejectedCheerInput {
  """
  Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  The server will reject any request with an ID that has already been used.
  """
  id: ID!

  """ID of the user whose message is automodded."""
  targetUserID: ID!
}

"""Payload from the denyRejectedCheer mutation."""
type DenyRejectedCheerPayload {
  """
  Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  The server will reject any request with an ID that has already been used.
  """
  id: ID!
}

"""Required input to deny an unban request on a channel."""
input DenyUnbanRequestInput {
  """ID of the unban request to be resolved."""
  id: ID!

  """Optional message from the resolver to be shown to the unban requester."""
  resolverMessage: String
}

"""Result of denying an unban request."""
type DenyUnbanRequestPayload {
  """Used for errors arising from resolving unban request."""
  error: UnbanRequestError

  """The resolved unban request."""
  unbanRequest: UnbanRequest
}

"""Inputs for deselecting a channel badge."""
input DeselectChannelBadgeInput {
  """ID of the channel this badge is selected on."""
  channelID: ID!
}

"""The output for the deselect channel badge mutation."""
type DeselectChannelBadgePayload {
  """The channel (user object of channel) this badge is deselected on."""
  user: User
}

"""The output for the deselect global badge mutation."""
type DeselectGlobalBadgePayload {
  """The user (contains the badge status)."""
  user: User
}

"""Defines AutoMod category levels for a Channel."""
type DetailedAutoModConfiguration {
  """This field will be a value between 0 and 4, inclusive."""
  ableismLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  aggressionLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  homophobiaLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  misogynyLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  nameCallingLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  profanityLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  racismLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  sexualityLevel: Int

  """
  DEPRECATED: nWordLevel is the level of "nWord" category. Will be deprecated when inference is upgraded to V4.
  """
  nWordLevel: Int @deprecated

  """
  DEPRECATED: whiteNationalistLevel is the level of "whiteNationalist" category.
  Will be deprecated when inference is upgraded to V4.
  """
  whiteNationalistLevel: Int @deprecated
}

"""Defines AutoMod category levels for a Channel."""
input DetailedAutoModLevelsInput {
  """This field will be a value between 0 and 4, inclusive."""
  ableismLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  aggressionLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  homophobiaLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  misogynyLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  nameCallingLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  profanityLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  racismLevel: Int

  """This field will be a value between 0 and 4, inclusive."""
  sexualityLevel: Int
}

"""
A Directory is a container of content – Streams, Videos, and Clips – on Twitch.
"""
interface Directory {
  """
  URL to an avatar image.
  The image dimensions are specifiable via the `height` and `width` parameters.
  
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  avatarURL(width: Int, height: Int): String

  """Number of broadcasters currently broadcasting in this directory."""
  broadcastersCount: Int

  """
  URL to a cover image.
  The image dimensions are specifiable via the `height` and `width` parameters.
  
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  coverURL(width: Int, height: Int): String

  """The type of directory – community or game."""
  directoryType: DirectoryType

  """The name to display for the directory."""
  displayName: String!

  """Number of users that follow this directory."""
  followersCount: Int

  """The directory's unique Twitch identifier."""
  id: ID!

  """The canonical name of the directory."""
  name: String!

  """
  Get a page of live streams broadcasting in this directory.
  If no language filters are provided all languages will be returned.
  Tags are an array of tag ID as optional filters for streams.
  """
  streams(first: Int = 10, after: Cursor, languages: [String!], tags: [String!]): StreamConnection

  """
  Number of viewers currently watching a stream which is in this directory.
  """
  viewersCount: Int
}

"""
Paginated list of Directories.
Implements the Relay cursor connections specification.
See: https://facebook.github.io/relay/graphql/connections.htm.
"""
type DirectoryConnection {
  edges: [DirectoryEdge]!
  pageInfo: PageInfo!
}

"""
Contains information about a Directory's relationship to a given page (connection),
and the Directory itself.
"""
type DirectoryEdge {
  cursor: Cursor
  node: Directory
}

"""The set of types of directory."""
enum DirectoryType {
  """A game."""
  GAME
}

"""
Disable Prerolls Ability contains the properties used by the Disable Prerolls Feature.
"""
type DisablePrerollsAbility {
  """
  DisablePrerollsFreeTime define relation of midroll-length:preroll-free-time-earned on this channel.
  """
  disablePrerollsTimeEarned: [DisablePrerollsFreeTime!]

  """
  If "disable prerolls for midrolls" feature is accessible on this channel.
  """
  hasDisablePrerollsAbilityAccess: Boolean

  """If "disable prerolls for midrolls" feature is enabled on this channel."""
  hasDisablePrerollsAbilityEnabled: Boolean

  """If disable preroll notifications are enabled on this channel."""
  hasDisablePrerollsNotificationsEnabled: Boolean

  """
  Maximum amount of preroll-free time (in seconds) that can be accumulated on this channel.
  """
  maxDisablePrerollsCapacity: Int
}

"""
Disable Prerolls Free Time maps the relationship between a specific midroll
length and amount of preroll-free time earned for a channel.
"""
type DisablePrerollsFreeTime {
  """The length (in seconds) of a midroll ad."""
  midrollLengthSeconds: Int!

  """
  The amount of preroll-free time (in seconds) earned on this channel for running midroll of related length.
  """
  prerollFreeTimeSeconds: Int!
}

"""Error returned during a invalid user request."""
type DisableTwoFactorError {
  """Error code returned by the backend."""
  code: DisableTwoFactorErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to disable two factor authentication.
"""
enum DisableTwoFactorErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a disableTwoFactor mutation."""
input DisableTwoFactorInput {
  """
  The ID of the user that is requesting to disable two factor authentication.
  """
  userID: ID!
}

"""The result of a disableTwoFactorPayload mutation."""
type DisableTwoFactorPayload {
  """error code and localized error."""
  error: DisableTwoFactorError
}

"""Error type that DisableUserAccountPayload returns."""
type DisableUserAccountError {
  """Error Code, see DisableUserAccountErrorCode."""
  code: DisableUserAccountErrorCode!
}

"""DisableUserAccountErrorCode is an error while deleting a user."""
enum DisableUserAccountErrorCode {
  """User ID is invalid."""
  INVALID_USER_ID

  """Requester is not authorized to make the requested change."""
  UNAUTHORIZED
}

"""Inputs to the disableUserAccount mutation."""
input DisableUserAccountInput {
  """Reason for a user to disable their account."""
  description: String

  """
  Permanently delete account.
  false means account will be disabled and can be reenabled in the future.
  true means the account will be disabled and will be permanently deleted after a period of time.
  default is false.
  """
  isDelete: Boolean

  """
  The ID of the user to disable or delete.
  Only the requester's user ID is allowed.
  """
  userID: ID!
}

"""Output from the disableUserAccount mutation."""
type DisableUserAccountPayload {
  """Error if operation failed from user error."""
  error: DisableUserAccountError

  """User that has been deleted or disabled."""
  user: User
}

"""DiscountBreakdown shows discounted pricing for a promotional offer."""
type DiscountBreakdown {
  """The numerical price of a discounted offer."""
  price: Int!

  """The localized tax rate of a offer."""
  tax: Int!

  """The total discounted price given price and tax."""
  total: Int!
}

"""
DEPRECATED: to be replaced by SubscriptionPromotionDiscountType.
Valid discount types for subscription products.
"""
enum DiscountType {
  """Percent discount type, eg. "50%"."""
  PERCENT_OFF
}

input DismissFriendRecommendationInput {
  """
  The recommendation to the authenticated user to become friends with a user with ID targetID will be removed.
  """
  targetID: ID!
}

type DismissFriendRecommendationPayload {
  """
  The user who was previously a friend recommendation to the target user.
  """
  user: User
}

type DismissRitualTokenError {
  code: DismissRitualTokenErrorCode!
}

enum DismissRitualTokenErrorCode {
  """Token is not in a status that can be dismissed."""
  TOKEN_NOT_AVAILABLE

  """Token does not exist."""
  TOKEN_NOT_FOUND
}

"""DismissRitualTokenInput is the input when dismissing a ritual token."""
input DismissRitualTokenInput {
  """The channel to dismiss the ritual token in."""
  channelID: ID!

  """The type of ritual token to dismiss."""
  type: RitualTokenType!
}

"""
DismissRitualTokenPayload is the response when dismissing a ritual token.
"""
type DismissRitualTokenPayload {
  error: DismissRitualTokenError
  token: RitualToken
}

"""Input for dismissing a video's suggested highlight."""
input DismissVideoSuggestedHighlightInput {
  """
  VideoID of the video whos automated highlight suggestions were dismissed.
  """
  videoID: ID!
}

"""Ouput for dismissing a video's suggested highlight."""
type DismissVideoSuggestedHighlightPayload {
  """Video whos automated highlight suggestions were dismissed."""
  video: Video
}

"""Contains all of the information about a Drop awarded to a user."""
type Drop {
  """The game that awarded the Drop."""
  game: Game @deprecated

  """The assigned ID of this drop."""
  id: ID! @deprecated

  """The image URL of the Drop. Images are 80x80 pixels."""
  imageURL: String! @deprecated

  """The developer-provided name of the Drop."""
  name: String! @deprecated
}

"""
A mapping of the client ID set to determine whether a user has set up account linking for the game.
"""
type DropAccountLink {
  """
  The associated clientID for a game used to determine if users have an account link
  created between tuid and in-game userID.
  """
  clientID: ID!

  """The date when this clientID was first added."""
  updatedAt: Time!
}

"""
Contains all of the information about a Drop's action stating what happens when a drop is triggered. //To be deprecated.
"""
type DropAction {
  """The time in seconds a user has to claim a drop after occurence."""
  claimDurationSeconds: Int! @deprecated

  """The description of this drop's action."""
  description: String! @deprecated

  """The Action ID."""
  id: ID! @deprecated

  """The type of action happening when a drop is triggered."""
  type: DropActionType! @deprecated
}

"""A list of all supported Action types. //To be deprecated."""
enum DropActionType {
  """Returned in case the action type cannot be identified."""
  UNKNOWN_ACTION_TYPE @deprecated

  """Returned in case the action starts a user claim flow."""
  USER_CLAIM_FLOW @deprecated
}

"""Data about the award of a drop to a user. // deprecated."""
type DropAward {
  """The timestamp when the Drop was awarded to the user."""
  awardedAt: Time @deprecated

  """The drop that was awarded to the user."""
  node: Drop @deprecated

  """The reason the Drop was awarded."""
  reason: String @deprecated
}

"""Contains all of the information about a Drop awarded to a user."""
type DropBenefit {
  """The redirect URL where a user can link their account."""
  accountLinkURL: String!

  """The time the benefit was created."""
  createdAt: Time!

  """The display description of this award object. //To be deprecated."""
  description: String! @deprecated

  """
  The limit of how often this benefit can globally be awarded to a user. Set to
  -1 if the drop can be entitled unlimited amounts.
  The per drop entitlementLimit of a reward is on DropObject.Drop2BenefitObject.
  """
  entitlementLimit: Int!

  """The game that awarded the Drop."""
  game: Game

  """The ID of this reward object."""
  id: ID!

  """An image asset for this reward object."""
  imageAssetURL: String!

  """
  Specifies if this benefit is considered for a game that is available on iOS.
  """
  isIosAvailable: Boolean!

  """The display name of this award object."""
  name: String!

  """The ID of the owner of the item for this reward."""
  owner: User! @deprecated(reason: "Use DropBenefit.ownerOrganization instead")

  """The (RBAC) Organization that owns the drop benefit."""
  ownerOrganization: Organization
}

"""
The DropBenefitEdge links a drop with a benefit and describes how many times that benefit
can be granted by this drop. A benefit can be granted multiple times by event based drops.
For example, a benefit could be granted every time the broadcaster gets a kill streak, up to
3 times.
"""
type DropBenefitEdge {
  """The benefit description."""
  benefit: DropBenefit!

  """The number of times a benefit has been claimed."""
  claimCount: Int

  """
  A restriction of the benefit on how often it can be claimed within a drop.
  """
  entitlementLimit: Int!
}

"""
A campaign a developer is running to give drops away to viewers of their game
To be considered live, a campaign must be enabled with the current time
being after the start but before the end times
To apply to a particular channel a campaign must be live and additionally
the channel must be playing an applicable game and either must be one of the
applicable channels or the campaign must have an empty applicable channel list
(where an empty list specifically means all channels are eligible).
"""
type DropCampaign {
  """
  The URL users who aren't linked should click on to create a link that will
  allow them create an account link for the developer of the game(s)
  this campaign is for.
  """
  accountLinkURL: String!

  """The only channels allowed to be eligible for the drop campaign."""
  allow: DropCampaignACL

  """
  If isAvailableToAllChannels is false, applicableChannels is the list of
  what channels this campaign is targeted to.  If the flag is true but the
  list is empty, that means that all whitelisted users cannot be loaded.
  An applicable channel must also be playing an applicable game for the
  campaign to apply to the channel.
  """
  applicableChannels: [User!] @deprecated

  """
  The games that this campaign is enabled on
  A channel playing one of these games must be in the applicable channels
  list or list must be empty for the campaign to apply to the channel.
  """
  applicableGames: [Game!] @deprecated

  """The drops this campaign can award."""
  awardableDrops: [Drop!] @deprecated

  """The channels blocked from being eligible for the drop campaign."""
  block: DropCampaignACL

  """
  The URL users who aren't linked should click on to create a link that will
  allow them create an account link for the developer of the game(s)
  this campaign is for.
  """
  connectionURL: String! @deprecated(reason: "Use accountLinkURL instead")

  """The description contains the full details about the campaign."""
  description: String!

  """The URL that links to the details / marketing page for this campaign."""
  detailsURL: String!

  """
  The time this campaign ends
  To be considered live, a campaign must be enabled with the current time
  being after the start but before the end times.
  """
  endAt: Time!

  """Drops triggered by in-game events."""
  eventBasedDrops: [EventBasedDrop!]

  """The Game associated with this campaign."""
  game: Game

  """GUID identifying this campaign."""
  id: ID!

  """An image asset for this campaign no larger than 160 x 160 pixels."""
  imageURL: String!

  """
  Indicates if this campaign is available to all channels or if only some.
  If false, applicableChannels should contain the channels where the campaign
  is available.
  """
  isAvailableToAllChannels: Boolean! @deprecated

  """
  If this campaign is enabled
  To be considered live, a campaign must be enabled with the current time
  being after the start but before the end times.
  """
  isEnabled: Boolean! @deprecated

  """Drops that can be triggered by manual events."""
  manualTriggerBasedDrops: [ManualTriggerBasedDrop!]

  """The name of the campaign."""
  name: String!

  """
  This is the Organization (RBAC) that has ownership of the campaign and attached drops.
  """
  owner: Organization

  """User specific data for the campaign."""
  self: DropCampaignSelfEdge!

  """
  The time this campaign starts
  To be considered live, a campaign must be enabled with the current time
  being after the start but before the end times.
  """
  startAt: Time!

  """The current status of the campaign."""
  status: DropCampaignStatus!

  """
  Test viewers can participate in campaigns while the campaign is in the test status.
  """
  testViewers: [User!]

  """Drops triggered by accumulating minutes watched on a game."""
  timeBasedDrops: [TimeBasedDrop!]

  """
  The type of a campaign defines what type of drops are allowed to be added to the campaign.
  """
  type: CampaignType!
}

"""
A toggleable access control list of channels given certain access to drop campaigns.
"""
type DropCampaignACL {
  """The channels that are either granted or denied access."""
  channels: [Channel!]

  """Whether the access list is currently in use."""
  isEnabled: Boolean!
}

"""
DropCampaignSelfEdge returns user specific information about the drops campaign.
"""
type DropCampaignSelfEdge {
  """Has the user linked their game account with the campaign."""
  isAccountConnected: Boolean!
}

"""Possible status of a drops campaign."""
enum DropCampaignStatus {
  """Drop campaign is currently active."""
  ACTIVE

  """The drop campaign is past its end date."""
  EXPIRED

  """The drop campaign is currently in testing mode."""
  TEST

  """The drop campaign is live but not yet past the start date."""
  UPCOMING

  """The drop campaign has been turned off."""
  DISABLED
}

"""Contains all of the information about the channel seetings for a Drop."""
type DropChannelSetting {
  """
  UserAccountConnected is a boolean specifying if a streamer has a connected
  account link to the game required for the game developers to send drop related
  game data for this user.
  """
  isUserAccountConnected: Boolean!
}

"""
The drop that is closest to completing for the current user that is actively earning progress.
"""
type DropCurrentSession {
  """The channelID where Progresso is currently tracking progress."""
  channel: Channel

  """
  The number of minutes that the user has accrued toward completing the drop.
  """
  currentMinutesWatched: Int!

  """
  The ID for the Drop that we're currently tracking (not surfaced; used for fulfillment).
  """
  dropID: ID!

  """The Game name that we're tracking for the currently-tracked drop."""
  game: Game

  """The total number of minutes required in order to complete the drop."""
  requiredMinutesWatched: Int!
}

"""Contains all of the information about a Drop awarded to a user."""
type DropEligibility {
  """The remaining time in which this reward can be claimed."""
  claimSecondsRemaining: Int!

  """Summary information for the drop the reward is claimed of."""
  drop: DropObject! @deprecated(reason: "No longer supported. Use dropType instead.")

  """The unique ID of this drop instance."""
  dropInstanceID: ID!

  """A single Drop. This could be either an event or time based drop."""
  dropType: DropType!

  """Rewards available to the user for this drop and their statuses."""
  rewards: [DropReward!]!

  """User eligibility for this drop instance."""
  status: DropInstanceEligibilityStatus!
}

"""
Defines a condition that must be met for an in game event to trigger a drop.
"""
type DropEventCondition {
  """Specifies the event to look for in the event payload."""
  key: String!

  """The comparator of the value to the event payload."""
  operator: DropEventConditionOperator!

  """Specifies the value to compare the event payload to."""
  value: String!
}

"""
A measurement against an in-game event to determine whether the drop should trigger.
"""
input DropEventConditionInput {
  """The key of the in-game event that can trigger the drop."""
  key: String!

  """The operator to apply to the event."""
  operator: DropEventConditionOperator!

  """The value of the in-game event that the operator is compared to."""
  value: String!
}

"""The operator used to compare the in-game event."""
enum DropEventConditionOperator {
  """
  An unknown operator, only possible before the drop condition has been set.
  """
  UNKNOWN

  """Less than."""
  SMALLER

  """Less than or equal."""
  SMALLER_EQUAL

  """Equal."""
  EQUAL

  """Greater than."""
  GREATER

  """Greater than or equal."""
  GREATER_EQUAL
}

"""
DropImageType is the list of possible uses that an image can have for drops.
"""
enum DropImageType {
  """
  Image for telling viewers that drops are available if they link accounts.
  """
  LINK_NOTIFICATION

  """Image for showing a viewer what item a developer awarded as a drop."""
  ITEM
}

"""
DropImageUploadInput has the fields required to upload a drop's image asset.
"""
input DropImageUploadInput {
  """The ownerID of the content owner."""
  ownerID: ID!

  """The ID for the referenced scope item."""
  referenceID: ID!

  """The scope of what the image gets uploaded for."""
  scope: Scope!
}

"""
SetDropCampaignStatusPayload returns the result of the creation/update.
"""
type DropImageUploadPayload {
  """The ID of the image once uploaded."""
  uploadID: ID

  """The URL to upload the image to."""
  uploadURL: String
}

"""Status enums for a drop instance."""
enum DropInstanceEligibilityStatus {
  """User can claim all rewards."""
  ELIGIBLE_FOR_ALL

  """User can claim some rewards."""
  LIMITED

  """User can not claim any of the rewards in this drop instance."""
  ENTITLEMENT_LIMIT_REACHED

  """User has already claimed this drop instance."""
  DROP_INSTANCE_ALREADY_CLAIMED

  """
  The claim duration has expired and user can no longer claim this drop instance.
  """
  EXPIRED

  """
  Unknown is returned if a status is returned from the backend that was not expected.
  """
  UNKNOWN
}

"""
Contains all of the information about a Drop awardable to a user. // deprecated
in favor of EventBasedDrop and TimeBasedDrop.
"""
type DropObject {
  """The redirect URL where a user can link their account."""
  accountLinkURL: String! @deprecated

  """The actions defining what happens after a drop is triggered."""
  actions: [DropAction!]! @deprecated

  """The description of this drop."""
  description: String! @deprecated

  """The URL that links to the details / marketing page for this drop."""
  detailsURL: String! @deprecated

  """The date at which this drop can no longer occur."""
  endDate: Time! @deprecated

  """The game associated with this drop."""
  game: Game! @deprecated

  """The Drops ID."""
  id: ID! @deprecated

  """An image asset for this drop."""
  imageURL: String! @deprecated

  """The friendly name of this drop."""
  name: String! @deprecated

  """The OrganizationID of the owner of this drop."""
  ownerID: ID! @deprecated

  """The friendly name of the owner of this drop."""
  ownerName: String! @deprecated

  """The Quest name for this specific Drop."""
  questName: String! @deprecated

  """The rules defining what needs to happen to trigger this drop."""
  rules: [DropRule!]! @deprecated

  """The date at which this drop can start to occur."""
  startDate: Time! @deprecated
}

"""
DropPrecondition is the tuple of DropID and the DropPreconditionID, which is the drop that must be attained first.
"""
input DropPrecondition {
  """The drop that can be claimed once the preconditions are met."""
  dropID: ID!

  """
  The drop that must have been claimed before you can make progress on this drop.
  """
  dropPreconditionID: ID!
}

"""Contains all of the information about a Drop awarded to a user."""
type DropReward {
  """The URL where a user can link their account for this reward."""
  accountLinkURL: String! @deprecated(reason: "use benefit.accountLinkURL")

  """An availability enum for this reward."""
  availability: DropRewardAvailability!

  """The DropBenefit that a user is claiming or get verified to."""
  benefit: DropBenefit!

  """The display description of this award object."""
  description: String! @deprecated(reason: "no longer used")

  """The ID of this reward object."""
  id: ID! @deprecated(reason: "use benefit.id")

  """An image asset for this reward object."""
  imageAssetURL: String! @deprecated(reason: "use benefit.imageAssetURL")

  """
  Specifies if this reward is considered for a game that is available on iOS.
  """
  isIosAvailable: Boolean! @deprecated(reason: "use benefit.isIosAvailable")

  """The display name of this award object."""
  name: String! @deprecated(reason: "use benefit.name")

  """The ID of the owner of the item for this reward."""
  ownerID: ID! @deprecated(reason: "use benefit.ownerOrganization.id")

  """The display name of item owner for this drop."""
  ownerName: String! @deprecated(reason: "use benefit.ownerOrganization.name")
}

"""Availability enum for Drop Rewards."""
enum DropRewardAvailability {
  """User can claim this item."""
  AVAILABLE

  """User has claimed this item already the maximum number of times."""
  LIMIT_REACHED

  """
  Unknown is returned when an unexpected status is received from the backend.
  """
  UNKNOWN
}

"""
Contains all of the information about a Drop's rule stating what a broadcaster
has to do to trigger a drop. //To be deprecated.
"""
type DropRule {
  """The description of this drop's rule."""
  description: String! @deprecated

  """The Rule ID."""
  id: ID! @deprecated
}

"""The type of drop rule you're creating. Event vs Minutes Watched."""
enum DropRuleType {
  """A drop that is triggered by an in-game event."""
  EVENT_BASED

  """
  A drop that is granted based on the user's minutes-watched of the drop's game.
  """
  TIME_BASED

  """A drop that is triggered by an manual triggered event."""
  MANUAL_TRIGGER_BASED
}

"""
An error that has been mapped from a DropsManagementService twirp error. Can sometimes include messages.
"""
type DropsError {
  """The error code."""
  code: DropsErrorCode!

  """The error message string."""
  message: String
}

"""Enum for Drops2 errors."""
enum DropsErrorCode {
  """The error code is unknown."""
  UNKNOWN

  """
  The user is either not authenticated or not authorized to perform the request.
  """
  UNAUTHORIZED

  """
  A request field either was not present or did not meet validation requirements.
  """
  INVALID_ARGUMENT

  """The drops2 object is not in the right state to perform this operation."""
  FAILED_PRECONDITION

  """The object you wish to query / modify is not found."""
  NOT_FOUND

  """The object you're trying to create, already exists."""
  ALREADY_EXISTS
}

"""
An interface to handle shared Drop data. The `Drop` type is already in use (although deprecated) so we can't use that name.
"""
interface DropType {
  """The rewards for this drop and how often those rewards can be awarded."""
  benefitEdges: [DropBenefitEdge!]

  """The campaign this drop belongs to."""
  campaign: DropCampaign!

  """The time this drop becomes unavailable."""
  endAt: Time!

  """A unique identifier."""
  id: ID!

  """The name of this drop."""
  name: String!

  """The time this drop becomes available."""
  startAt: Time!
}

"""
A possibly signed sequence of decimal numbers, each with optional fraction
and a unit suffix, such as "300ms", "-1.5h" or "2h45m".
Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
"""
scalar Duration

"""Paginated list of channels a user is an editor for."""
type EditableChannelConnection {
  """The elements of the list."""
  edges: [EditableChannelEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""Points to a editable channel with the editor."""
type EditableChannelEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The user whose channel has the editor."""
  node: User
}

"""Paginated list of editors of a channel."""
type EditorConnection {
  """The elements of the list."""
  edges: [EditorEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""
Points to a user with the editor status, with metadata regarding the relationship.
"""
type EditorEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """Timestamp of when the editor status was granted."""
  grantedAt: Time!

  """The user who has the editor status."""
  node: User
}

input EditRoomMessageInput {
  message: String!
  messageID: ID!
  roomID: ID!
}

type EditRoomMessagePayload {
  message: RoomMessage
}

"""
The list of payment methods that are supported for web checkout for a user.
"""
type EligiblePaymentMethod {
  """Availability status of the underlying payment gateway."""
  availabilityStatus: PaymentMethodAvailabilityStatus!

  """Name of the payment method."""
  name: EligiblePaymentMethodName!
}

"""
The list of names of payment methods that are supported for web checkout.
"""
enum EligiblePaymentMethodName {
  """Amazon Pay payment method."""
  AMAZON_PAY

  """Paypal payment method."""
  PAYPAL

  """Credit card payment method."""
  CREDIT_CARD

  """Xsolla payment method."""
  XSOLLA

  """Twitch Wallet balance payment method."""
  WALLET

  """Direct Debit payment method."""
  DIRECT_DEBIT
}

"""
EmbeddedEmote is an encoding format used to describe an emote embedded in a string of text.

Example:
  body = "hey KappaHD"
  from = 4
  to = 10

  "KappaHD" will be replaced with the KappaHD emote image.
"""
type EmbeddedEmote {
  """The emote's identifier, for example "115847" -> KappaHD."""
  emoteID: ID

  """from is the index of the string where replacement starts."""
  from: Int
  id: ID

  """setID is the identifier of the set this emote is in."""
  setID: ID

  """to is the index of the string where replacement ends."""
  to: Int
}

"""
EmitCampaignDiscoveryEventInput contains the campaign objective type of the event being emitted
and the channelID from which this event is born.
"""
input EmitCampaignDiscoveryEventInput {
  """The channelID from the channel this event is taking place on."""
  channelID: ID!

  """The campaign objective type of the event."""
  discoveryType: CampaignDiscoveryEventType!
}

"""
EmitCampaignDiscoveryEventPayload is the success response for emitting a campaign discovery event.
"""
type EmitCampaignDiscoveryEventPayload {
  """Whether the call succeeded or not."""
  isSuccess: Boolean!
}

type Emote {
  """The type of image asset of the emote (static, animated, etc.)."""
  assetType: EmoteAssetType

  """
  The Bits Badge Tier metadata associated with this Bits Badge Tier Emote. Nil for other emote types.
  """
  bitsBadgeTierSummary: EmoteBitsBadgeTierSummary

  """The timestamp at which this emote was created."""
  createdAt: Time

  """
  The emote's identifier.
  For example, "115847".
  """
  id: ID

  """The list of modifiers a user is entitled to use for an emote."""
  modifiers: [EmoteModifier!]

  """
  A priority order for displaying this emote among others in the same group.
  """
  order: Int

  """The user who owns the subscription product that this emote belongs to."""
  owner: User

  """Identifies which set this emote belongs to."""
  setID: ID

  """The state of an emote. Can be either active or pending."""
  state: EmoteState!

  """The subscription product this emote belongs to. Nil for globals."""
  subscriptionProduct: SubscriptionProduct

  """
  The subscription info for this emote (if the emote is obtainable via subscription).
  """
  subscriptionSummaries: [SubscriptionSummary!]

  """
  This is very sparsely populated at present (only when subscription summaries are populated).
  This is subscription tier that is associated with this emote (if one exists)
  and if the emote and subscription shares an owner.
  """
  subscriptionTier: SubscriptionSummaryTier

  """
  For subscription and bits badge tier emotes, this is the user generated suffix.
  For example, for "lirikLUL" suffix would be "LUL".
  """
  suffix: String

  """
  The visual representation of the emote.
  For example, "O_o" instead of "(O|o)_(o|O)".
  """
  text: String

  """
  The text token of the emote.
  For example, "KappaHD".
  """
  token: String

  """
  The type of emote that this is.
  For example, a global emote, a turbo emote, a prime emote, a sub emote, etc.
  """
  type: EmoteType
}

"""The asset type of the emote (static, animated, etc.)."""
enum EmoteAssetType {
  """The emote's asset is animated (e.g. GIF)."""
  ANIMATED

  """The emote's asset is static (e.g. PNG)."""
  STATIC

  """The emote's asset type is unknown."""
  UNKNOWN
}

"""Bits Badges Tier metadata for emotes."""
type EmoteBitsBadgeTierSummary {
  """The Bits Badge Tier Summary data that is user-dependent."""
  self: EmoteBitsBadgeTierSummarySelfEdge

  """The amount of bits any user must cheer to achieve this tier."""
  threshold: Int!
}

"""The Bits Badge Tier Summary data that is user-dependent."""
type EmoteBitsBadgeTierSummarySelfEdge {
  """Is true if the user has unlocked this emote."""
  isUnlocked: Boolean!

  """
  The number of bits that this user must use in order to unlock this emote. 0 if already unlocked.
  """
  numberOfBitsUntilUnlock: Int!
}

"""The possible emote group asset types."""
enum EmoteGroupAssetType {
  """STATIC type groups only contain static emotes."""
  STATIC

  """ANIMATED type groups only contain animated emotes."""
  ANIMATED
}

"""The ID, Size and AssetType of a previously uploaded emote."""
input EmoteImageAssetInput {
  """The asset type of the image."""
  assetType: EmoteAssetType!

  """Image ID generated by Mako for image."""
  id: ID!

  """Size of the image."""
  size: EmoteImageSize!
}

"""Enum of supported image sizes."""
enum EmoteImageSize {
  """Lowest supported resolution."""
  SIZE_1X

  """Resolution used for kinda high density displays."""
  SIZE_2X

  """Highest density display support."""
  SIZE_4X

  """Original size, used for resizing functionality."""
  SIZE_ORIGINAL
}

"""
Represents the data needed to continue the upload of an emoticon image asset.
"""
type EmoteImageUploadConfiguration {
  """
  The id used by upload service to publish updates via pubsub about the uploaded image.
  """
  uploadID: ID

  """The url in s3 for where the front-end should post the image asset."""
  uploadURL: String
}

"""The name of an emote modifier and it's abbreviated code."""
type EmoteModifier {
  """The code to use the emote modifier in chat."""
  code: String!

  """The name of the emote modifier."""
  name: PermanentEmoteModifier!

  """Subscription tier associated with modifier (if known and applicable)."""
  subscriptionTier: SubscriptionSummaryTier
}

"""A set of modifications to apply to a tier of emotes for a creator."""
input EmoteModifierGroupInput {
  """The modifiers to set."""
  modifiers: [PermanentEmoteModifier!]!

  """The ID of the product to set the modifiers for."""
  productID: ID!
}

"""
A set of modifiers that have been set on a tier of emotes for a creator.
"""
type EmoteModifierGroupPayload {
  """The modifiers that were set."""
  modifiers: [PermanentEmoteModifier!]

  """The product the modifiers were set for."""
  product: SubscriptionProduct
}

"""The new order for the specified emote in a particular emote group."""
input EmoteOrder {
  """The ID of this emote."""
  emoteID: ID!

  """
  The ID of the group we are setting this emote's order in. When emotes can exist in multiple groups they may have different
  order values in each group (as the other emotes in each group will be
  different) so we must specify which group we are operating on.
  """
  groupID: ID!

  """The new order value for this emote."""
  order: Int!
}

"""Enum of supported resizing plans."""
enum EmoteResizePlan {
  """Resize a provided SIZE_ORIGINAL_IMAGE."""
  AUTO_RESIZE

  """Don't resize, use the image as is for 1x, 2x or 4x."""
  NO_RESIZE
}

"""Represents a group of emotes."""
type EmoteSet {
  """The list of emotes which belong to this set."""
  emotes: [Emote]

  """The emote set's identifier."""
  id: ID

  """
  The channel associated with the emote set. Nil for emote sets not associated
  with an owner (prime, fuel, rewards, etc.).
  """
  owner: User

  """The asset type of the emotes within the emote group."""
  assetType: EmoteGroupAssetType
}

"""Deprecated: Domains that emotes belong to."""
enum EmoteSetDomain {
  """Emotes that were granted via Twitch crates."""
  CRATE
}

"""The state of an emote."""
enum EmoteState {
  """Emote has been approved and is active."""
  ACTIVE

  """Emote has been uploaded and is awaiting approval."""
  PENDING

  """Emote is only available in the emote library."""
  ARCHIVED

  """
  Emote has been uploaded into the emote library and is awaiting approval.
  """
  PENDING_ARCHIVED

  """Emote is inactive."""
  INACTIVE

  """Emote has an unknown state."""
  UNKNOWN
}

"""Used to filter emotes by state."""
enum EmoteStateFilter {
  """Show all emotes, including active and pending."""
  ALL

  """Show only active emotes."""
  ACTIVE
}

enum EmoteType {
  """Emote is a channel points reward."""
  CHANNEL_POINTS

  """Emote is a bits badge tier reward."""
  BITS_BADGE_TIERS

  """Emote is a subscription product benefit."""
  SUBSCRIPTIONS

  """Emote is a Twitch Prime benefit."""
  PRIME

  """Emote is a Twitch Turbo benefit."""
  TURBO

  """Two Factor authorization enabled reward emotes."""
  TWO_FACTOR

  """Emote is one of the robot, monkey, or glitch smilies sets."""
  SMILIES

  """Emote is a global emote."""
  GLOBALS

  """
  Limited time emotes are from a limited window event like FUEL or Esports (like OWL or Heathstone).
  """
  LIMITED_TIME

  """Limited time emote from a hype train campaign."""
  HYPE_TRAIN

  """Limited time emote from a megacommmerce/megacheer campaign."""
  MEGA_COMMERCE

  """
  Emotes which have intentionally been given no associated feature because they are only available in the Emotes Library.
  """
  ARCHIVE

  """Emote has an unknown type."""
  UNKNOWN
}

"""
Represents an emote that is currently in the process of being uploaded.
"""
type EmoteUploadConfiguration {
  """The relevant metadata for the 1X image asset."""
  imageUploadConfig1X: EmoteImageUploadConfiguration

  """The relevant metadata for the 2X image asset."""
  imageUploadConfig2X: EmoteImageUploadConfiguration

  """The relevant metadata for the 4X image asset."""
  imageUploadConfig4X: EmoteImageUploadConfiguration
}

"""Channels have emoticon prefixes."""
type EmoticonPrefix {
  """If the prefix can be edited or not."""
  isEditable: Boolean!

  """Name of the prefix."""
  name: String!

  """If the prefix has been approved or not."""
  state: EmoticonPrefixState!
}

"""State to track if the emote prefix is approved or not."""
enum EmoticonPrefixState {
  """Unknown."""
  UNKNOWN

  """No prefix has been submitted."""
  UNSET

  """Prefix is approved and active."""
  ACTIVE

  """Prefix was rejected by Twitch."""
  REJECTED

  """Prefix is waiting moderation by Twitch."""
  PENDING
}

"""
Paginated list of endorsed channels using the Relay cursor specification.
"""
type EndorsedChannelConnection {
  """The endorsed channels."""
  edges: [EndorsedChannelEdge!]

  """Pagination information for this connection."""
  pageInfo: PageInfo!
}

"""Element in a list of endorsed channels."""
type EndorsedChannelEdge {
  """Cursor identifying the position of this edge for future queries."""
  cursor: Cursor!

  """The information about the endorsed channel."""
  node: Channel!

  """
  Unique id per channel item, used by the client to attribute display/clicks of items.
  """
  trackingID: ID!
}

"""The required input for an EndUseBitsInExtension mutation."""
input EndUseBitsInExtensionInput {
  """The transaction ID of this bits spend event."""
  transactionID: ID!
}

"""The result of a EndUseBitsInExtension mutation."""
type EndUseBitsInExtensionPayload {
  """The user's new bits balance."""
  balance: Int
}

"""
EnhancedExperiencesClient is an OAuth app that is authorized to use
the Enhanced Experiences (E2) API for game integrations.
"""
type EnhancedExperiencesClient {
  """The client ID of the OAuth app."""
  id: ID!

  """The name of the client."""
  name: String!

  """
  The timestamp when the the client was onboarded to the Enhanced Experiences (E2) API.
  """
  onboardedAt: Time
}

"""Episode metadata."""
type EpisodeDetails {
  """Total length of the content."""
  durationSeconds: Int

  """The episode number."""
  episode: Int

  """The season number."""
  season: Int

  """The name of the series."""
  series: String
}

"""
EquipHeroAssetsError contains details about an error that occured when equipping assets.
"""
type EquipHeroAssetsError {
  """The type of error that occured when equipping hero assets."""
  code: EquipHeroAssetsErrorCode!
}

"""
EquipHeroAssetsErrorCode defines a client error that occurs when equipping hero assets.
"""
enum EquipHeroAssetsErrorCode {
  """The requesting user did not have permission to equip the assets."""
  FORBIDDEN

  """One of the requested asset IDs was not valid."""
  INVALID_ASSET_ID

  """Multiple assets were specified in a single asset type."""
  MULTIPLE_ASSETS_PER_TYPE

  """Some other unexpected error occured."""
  UNKNOWN_ERROR
}

"""
EquipHeroAssetsInput contains the parameters to equip assets on a hero.
"""
input EquipHeroAssetsInput {
  """The IDs of the assets to equip."""
  assetIDs: [ID!]!
}

"""
EquipHeroAssetsPayload is the response after equipping the assets on the hero.
"""
type EquipHeroAssetsPayload {
  """
  The error that occured.
  Null if the operation was successful.
  """
  error: EquipHeroAssetsError

  """The hero after equipping - null if error."""
  hero: Hero
}

"""ESRBRating for a given game."""
enum ESRBRating {
  """Game category that has not set an ESRB Rating."""
  UNSET

  """Game category that has ESRB Rating of Rating Pending (RP)."""
  RP

  """Game category that has ESRB Rating of EC."""
  EC

  """Game category that has ESRB Rating of E."""
  E

  """Game category that has ESRB Rating of E10."""
  E10

  """Game category that has ESRB Rating of T."""
  T

  """Game category that has ESRB Rating of M."""
  M

  """Game category that has ESRB Rating of AO."""
  AO
}

"""Drop triggered by an in-game event."""
type EventBasedDrop implements DropType {
  """The rewards for this drop and how often those rewards can be awarded."""
  benefitEdges: [DropBenefitEdge!]

  """The campaign this drop belongs to."""
  campaign: DropCampaign!

  """
  Amount of time the viewer has to claim the drop after the rule is completed.
  """
  claimDurationSeconds: Int!

  """The event conditions which must be met for this drop to be earned."""
  conditions: [DropEventCondition!]!

  """The time this drop becomes unavailable."""
  endAt: Time!

  """A unique identifier."""
  id: ID!

  """Describes how the event will be accomplished."""
  missionDescription: String!

  """Name of the mission a streamer has to achieve."""
  missionName: String!

  """The name of this drop."""
  name: String!

  """The time this drop becomes available."""
  startAt: Time!
}

"""Settings for a given event."""
type EventNotificationSetting {
  """The setting category."""
  category: String!

  """Settings for individual platforms."""
  platforms: [PlatformEventSetting!]!
}

"""
Experimental properties that should NOT be used outside of experiments.
When your property is no longer in use, please mark as deprecated and then formally delete it.
"""
type Experiment {
  """The selected promoted Stream for placement experiments."""
  promotedStream(promoLocation: Int!): Stream
}

"""Data about an inactive subscription to a broadcaster."""
type ExpiredSubscription {
  """The channel that the expired subscription belongs to."""
  channelOwner: User

  """The unique identifier."""
  id: ID!

  """Resolves the product that the expired subscription is to."""
  product: SubscriptionProduct

  """The total tenure of a user to a broadcaster."""
  tenure: SubscriptionTenure!
}

"""A paginated list of expired subscriptions."""
type ExpiredSubscriptionConnection {
  """The list of expired subscriptions."""
  edges: [ExpiredSubscriptionEdge!]

  """Information about this page of expired subs."""
  pageInfo: PageInfo!
}

"""An element in a paginated list of expired subscriptions."""
type ExpiredSubscriptionEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The element node."""
  node: ExpiredSubscription
}

"""Input information for exporting a video to Youtube."""
input ExportVideoToYoutubeInput {
  """The description of the exported video."""
  description: String

  """Determines whether to split the video into smaller segments."""
  doSplit: Boolean

  """Determines viewability of the video."""
  private: Boolean

  """The tags of the exported video."""
  tags: [String!]

  """The title of the exported video."""
  title: String

  """ID of the exported video."""
  videoID: ID!
}

"""Response to a request to export a video to Youtube."""
type ExportVideoToYoutubePayload {
  """Video representing the exported video."""
  video: Video
}

"""Twitch Extension."""
type Extension {
  """The anchor point the extension expects to render into on the client."""
  anchor: ExtensionAnchor!

  """
  A list of assets which the extension must have uploaded to the Twitch Extensions CDN.
  """
  assetURLs: [String!]!

  """
  The author of the extension as specified by the developer's extension manifest.
  """
  authorName: String!

  """
  The bits support level required by the broadcaster for the extension to operate.
  """
  bitsSupportLevel: ExtensionBitsSupportLevel!

  """The list of categories that the developer has set for the extension."""
  categories: [ExtensionCategory!]!

  """A single challenge condition associated with the specified extension."""
  challengeCondition(input: ExtensionChallengeConditionByIDInput!): ChallengeCondition

  """
  The list of challenge condition participants that are associated with this
  extension for a particular condition participant owner and condition owner.
  """
  challengeConditionParticipants(first: Int = 100, after: Cursor, input: ExtensionChallengeConditionParticipantsInput!): ExtensionChallengeConditionParticipantConnection

  """
  The list of challenge conditions that are associated with this extension.
  """
  challengeConditions(first: Int = 100, after: Cursor, input: ExtensionChallengeConditionsInput!): ExtensionChallengeConditionConnection

  """
  The client ID of the extension. Also used as the non-composite, non-unique ID of an extension internally.
  """
  clientID: ID!

  """
  The URL which is used to preset the configuration experience of the extension.
  """
  configURL: String! @deprecated(reason: "configURL should be captured from the config ExtensionView: Extension.views.config.viewerURL")

  """
  The list of games that an extension is content-matched to. This list is managed internally by Twitch.
  """
  contentMatchedGames: [Game!]

  """
  The description of the extension specified by the developer's extension manifest
  (max-length: 1024 characters).
  """
  description: String!

  """
  The list of games that an extension is associated to. This list is managed by the extension developer.
  """
  games: [Game!]

  """
  Whether the extension developer has turned on chat support for this extension.
  """
  hasChatSupport: Boolean!

  """
  Represents whether or not the developer of the extension would like to provide users with
  the ability to link their identity with the extension.
  """
  hasIdentityLinking: Boolean!

  """The extension icon URLs used to visually represent the extension."""
  iconURLs: ExtensionIcons!

  """The extension ID which is a composite form of <clientID>:<version>."""
  id: ID!

  """Represents whether or not the extension supports bits monetization."""
  isBitsEnabled: Boolean!

  """
  The URL which is used to preset the live-dashboard experience of the extension.
  """
  liveConfigURL: String! @deprecated(reason: "liveConfigURL should be captured from the liveConfig ExtensionView: Extension.views.liveConfig.viewerURL")

  """
  The name of the extension specified by the developer's extension manifest
  (max-length: 40 characters).
  """
  name: String!

  """
  The panel height specified by the developer's extension manifest -or- 300.
  """
  panelHeight: Int! @deprecated(reason: "panelHeight should be captured from the panel ExtensionView: Extension.views.panel.height")

  """
  The link to the extension's privacy policy as specified by the developer's extension manifest.
  """
  privacyPolicyURL: String!

  """
  Screenshots of the URL used to showcase the extension on extension details pages.
  """
  screenshotURLs: [String!]!

  """
  Represents whether the requesting user is able to install the extension.
  """
  self: ExtensionSelfConnection

  """The sku of the extension for monetizable extensions."""
  sku: String!

  """The current state of the extension in our approval process."""
  state: ExtensionState!

  """
  The subscription support level required by the broadcaster for the extension to operate.
  """
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel!

  """
  The summary of the extension specified by the developer's extension manifest
  (max-length: 140 characters).
  """
  summary: String!

  """
  The support contact email as specified by the developer's extension manifest.
  """
  supportEmail: String!

  """End-user license agreement terms of service URL."""
  termsURL: String!

  """The vendor code of the extension for monetizable extensions."""
  vendorCode: String!

  """
  The current version of the extension specified by the developer's extension manifest.
  """
  version: String!

  """
  The URL which is used to preset the viewer experience of the extension.
  """
  viewerURL: String! @deprecated(reason: "viewerURL should be captured from the ExtensionView corresponding with the Extension's specified anchor")

  """The UI configurations of each supported view of the extension."""
  views: ExtensionViews!

  """
  The list of URLs an extension can link to while loaded in the configuration experience.
  """
  whitelistedConfigURLs: [String!]!

  """
  The list of URLs a panel extension can link to while loaded in the viewer experience.
  """
  whitelistedPanelURLs: [String!]!
}

"""The current activation configuration for an installed extension."""
type ExtensionActivationConfig {
  """
  The anchor that the installation has been activated into. If not activated into a slot,
  the value will be null.
  """
  anchor: ExtensionAnchor

  """
  The slot that the installation has been activated into. If not activated into a slot,
  the value will be null.
  """
  slot: String

  """The activation state of the extension installation."""
  state: ActivationState!

  """
  The horizontal positioning of the left side of the component extension from the left side
  of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  """
  x: Int

  """
  The vertical positioning of the top side of the component extension from the top side
  of the visible video space as a fixed-point percentage (ie: 5742 would represent 57.42 percent).
  """
  y: Int
}

"""
Represents the action which should be taken on the provided installation ID. If no
anchor configuration is provided, the installation will be deactivated.
"""
input ExtensionActivationInput {
  """
  The required activation input to apply activation state to a component anchor.
  """
  component: ComponentActivationInput

  """
  The installation ID of the component extension you're attempting to activate.
  """
  installationID: ID!

  """
  The required activation input to apply activation state to a panel anchor.
  """
  panel: PanelActivationInput

  """
  The required activation input to apply activation state to a video overyla anchor.
  """
  videoOverlay: VideoOverlayActivationInput
}

"""The possible values for an Extension Anchor."""
enum ExtensionAnchor {
  """Component extension anchor."""
  COMPONENT

  """Hidden extensions are used currently for load tests."""
  HIDDEN

  """Panel extension anchor."""
  PANEL

  """Video overlay extension anchor."""
  VIDEO_OVERLAY
}

"""ExtensionAssetManifest is data related to the assets of an extension."""
type ExtensionAssetManifest {
  """Hash of the asset zip file."""
  assetHash: String!

  """Base URI used for extensions out of local test."""
  baseURI: String

  """The name of the file that was uploaded."""
  fileName: String

  """The size of the file that was uploaded."""
  fileSize: String

  """The time that the assets were uploaded."""
  uploadedAt: Time

  """The user that uploaded the assets."""
  uploader: User
}

"""
ExtensionAssetManifestInput is data related to the assets of an extension.
"""
input ExtensionAssetManifestInput {
  """Hash of the asset zip file."""
  assetHash: String!
}

"""The support levels for Bits features."""
enum ExtensionBitsSupportLevel {
  """This extension doesn't have any support for bit features."""
  NONE

  """
  This extension has support for bit features but can operate in the event
  the broadcaster disables the permissions.
  """
  OPTIONAL

  """
  This extension requires support for bit features and cannot operate in the event
  the broadcaster disables the permissions.
  """
  REQUIRED
}

"""
ExtensionCapabilities contains data about what an Extension can do, in general, and at the time of interaction.
"""
type ExtensionCapabilities {
  """
  The bit support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  """
  bitsSupportLevel: ExtensionBitsSupportLevel!

  """Location of configuration."""
  configurationLocation: ExtensionConfigurationLocation!

  """Does this extension use bits."""
  hasBitsSupport: Boolean!

  """Does this extension support chat."""
  hasChatSupport: Boolean!

  """Required configuration string."""
  requiredConfiguration: String!

  """
  The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  """
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel!

  """Whitelists for restricting extension access and behavior."""
  whitelists: ExtensionWhitelists

  """Will this extension request an identity link."""
  willRequestIdentityLink: Boolean!
}

"""
ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction.
"""
input ExtensionCapabilitiesInput {
  """
  The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  """
  bitsSupportLevel: ExtensionBitsSupportLevel = NONE

  """Location of configuration."""
  configurationLocation: ExtensionConfigurationLocation!

  """Does this extension use bits."""
  hasBitsSupport: Boolean!

  """Does this extension support chat."""
  hasChatSupport: Boolean!

  """Required configuration string."""
  requiredConfiguration: String!

  """
  The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  """
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel

  """Whitelists for restricting extension access and behavior."""
  whitelists: ExtensionWhitelistsInput!

  """Will this extension request an identity link."""
  willRequestIdentityLink: Boolean!
}

"""An extension carousel."""
type ExtensionCarousel {
  """List of entries associated with the carousel."""
  entries: [ExtensionCarouselEntry!]!

  """Unique ID of the carousel."""
  id: ID!
}

"""An extension carousel entry."""
type ExtensionCarouselEntry {
  """URL the user is directed to when clicking the carousel entry."""
  clickThroughURL: String!

  """Unique ID of the entry."""
  id: ID!

  """URL of the image to display for the carousel entry."""
  imageURL: String!

  """Text associated with the carousel entry."""
  title: String!
}

"""An extension category."""
type ExtensionCategory {
  """Description for what kind of extensions this category represents."""
  description: String!

  """The paginated list of extensions in the category."""
  extensions(first: Int = 10, after: Cursor): ExtensionConnection

  """The category ID which is uniquely generated."""
  id: ID!

  """Boolean value representing whether a category has been deleted."""
  isDeleted: Boolean!

  """
  Denotes that no updates can be made to the category and no extensions can be added to it.
  """
  isReadOnly: Boolean!

  """
  Boolean value representing whether this category should be hidden from listings.
  """
  isVisible: Boolean!

  """Human readable name for the Category."""
  name: String!

  """
  Display order for this category. Categories are returned in ascending order.
  """
  order: Float!

  """
  The URL-safe slug for the category. This slug may be used as the identifier to retrieve
  categories from the root Query.
  """
  slug: ID

  """
  Enumerated value specifying how this category's content should be ordered. Popularity, manual, etc.
  """
  sortKey: ExtensionCategorySortKey!

  """Category Type which can be curated or developer."""
  type: ExtensionCategoryType!
}

"""A paginated list of extension categories, and their metadata."""
type ExtensionCategoryConnection {
  """The list of extension categories in this page."""
  edges: [ExtensionCategoryEdge!]!

  """Information about this page of extension categories."""
  pageInfo: PageInfo!

  """The total number of extension categories."""
  totalCount: Int!
}

"""
An element in a paginated list of extension categories and its metadata.
"""
type ExtensionCategoryEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the extension category for the current edge."""
  node: ExtensionCategory!
}

"""
Enumeration of the different sort keys to sort extensions within a category.
"""
enum ExtensionCategorySortKey {
  """Manual sort key refers to an arbitrary sorting of extensions."""
  MANUAL

  """Popularity sort key refers to sorting of extensions by popularity."""
  POPULARITY

  """Time sort key refers to sorting of extensions from newest to latest."""
  TIME
}

"""
Enumeration of the different category types that are currently supported.
"""
enum ExtensionCategoryType {
  """Curated Category Type is Twitch controlled."""
  CURATED

  """Developer Category Type is developer controlled."""
  DEVELOPER

  """
  Pseudo Categories are categories whose extensions are generated. Slugs are required
  on pseudo categories and are often the best way to retrieve them. Example pseudo categories
  and slugs include "new-releases" and "whitelisted".
  """
  PSEUDO
}

"""Parameters for filtering ChallengeConditionParticipants."""
input ExtensionChallengeConditionByIDInput {
  """The ID of the condition for the specified owner."""
  conditionID: ID!

  """TUID of condition participant's associated condition's owner."""
  conditionOwnerID: ID!
}

"""A paginated list of extension challenge conditions."""
type ExtensionChallengeConditionConnection {
  """The elements of the paginated list."""
  edges: [ExtensionChallengeConditionEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""An element in a paginated list of extension challenge conditions."""
type ExtensionChallengeConditionEdge {
  """
  An opaque cursor identifying the edge's position in the paginated list.
  """
  cursor: Cursor!

  """The element node."""
  node: ChallengeCondition!
}

"""A paginated list of extension challenge conditionParticipants."""
type ExtensionChallengeConditionParticipantConnection {
  """The elements of the paginated list."""
  edges: [ExtensionChallengeConditionParticipantEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""
An element in a paginated list of extension challenge conditionParticipants.
"""
type ExtensionChallengeConditionParticipantEdge {
  """
  An opaque cursor identifying the edge's position in the paginated list.
  """
  cursor: Cursor!

  """The element node."""
  node: ChallengeConditionParticipant!
}

"""Parameters for filtering ChallengeConditionParticipants."""
input ExtensionChallengeConditionParticipantsInput {
  """TUID of condition participant's associated condition's owner."""
  conditionOwnerID: ID!

  """TUID of condition participant owner."""
  conditionParticipantOwnerID: ID!

  """Filter condition participants with this state."""
  endState: ChallengeConditionParticipantEndState!
}

"""Parameters for filtering ChallengeConditions."""
input ExtensionChallengeConditionsInput {
  """
  TUID of condition owner. This will typically be the broadcaster's user ID.
  """
  conditionOwnerID: ID!

  """Filter conditions with this state."""
  state: ChallengeConditionState!
}

"""ExtensionClient is the authorization component of an extension."""
type ExtensionClient {
  """
  A organization member assigned as a billing manager for this extension. Null
  when extension is not an organization or the extension is not monetized.
  """
  assignedBillingManager: OrganizationMember

  """CreatedAt is the timestamp at which this client was created."""
  createdAt: Time!

  """ID is the OAuth ID representing the extension."""
  id: ID!

  """Name is the name of the extension."""
  name: String!

  """
  Organization is the Organization entity of the extension, it means which organization the extension belongs to.
  """
  organization: Organization

  """RedirectURI is the URI used for client redirect on OAuth login."""
  redirectURI: String!
}

"""A paginated list of extension clients."""
type ExtensionClientConnection {
  """The list of extension clients in this page."""
  edges: [ExtensionClientEdge!]!

  """Information about this page of extension clients."""
  pageInfo: PageInfo!
}

"""An element in a paginated list of extension clients."""
type ExtensionClientEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the extension client for the current edge."""
  node: ExtensionClient!
}

"""
ExtensionComment contains the data for the comment of an extension review.
"""
type ExtensionComment {
  """The review comment text provided by the user."""
  content: String!

  """The ID of the recorded comment."""
  id: ID!
}

"""
The hosted configuration for an extension that comes from config service.
"""
type ExtensionConfiguration {
  """
  The broadcaster-set, per-channel segment of the extension configuration.
  """
  broadcaster: ExtensionConfigurationRecord

  """The developer-set, per-channel segment of the extension configuration."""
  developer: ExtensionConfigurationRecord

  """The id of the extension that this configuration document belongs to."""
  extensionID: ID!

  """
  The developer-set segment of the extension configuration that affects all
  installs of the extension.
  """
  global: ExtensionConfigurationRecord
}

"""Possible locations for Extension Configuration to be hosted."""
enum ExtensionConfigurationLocation {
  """Configuration not required for activation of this extension."""
  NONE

  """Configuration hosted by Twitch using Extensions Configuration service."""
  HOSTED

  """Custom/Own service hosted configuration."""
  CUSTOM
}

"""A single segment from the extensions configuration service."""
type ExtensionConfigurationRecord {
  """The content of the configuration segment."""
  content: String!

  """The version of the configuration segment."""
  version: String!
}

"""A paginated list of extensions, and its metadata."""
type ExtensionConnection {
  """The list of extensions in this page."""
  edges: [ExtensionEdge!]!

  """Information about this page of extensions."""
  pageInfo: PageInfo!

  """The total number of extensions in the larger collection."""
  totalCount: Int!
}

"""ExtensionDeveloperManifest is the developer specific extension data."""
type ExtensionDeveloperManifest {
  """Author email."""
  authorEmail: String!

  """Time when an extension was created."""
  createdAt: String!

  """Time when an extensions version was last transitioned."""
  lastTransitionedAt: Time

  """Testing uri for extension development."""
  testingBaseURI: String!

  """Current state of this version in the development timeline."""
  versionState: ExtensionState!
}

"""
ExtensionDeveloperManifestInput is the developer specific extension data.
"""
input ExtensionDeveloperManifestInput {
  """Author email."""
  authorEmail: String!

  """Testing uri for extension development."""
  testingBaseURI: String!
}

"""Extension metadata used for discovery."""
type ExtensionDiscoveryManifest {
  """Name of the extension author."""
  authorName: String!

  """Extension categories."""
  categories: [ExtensionCategory!]!

  """
  Games that an extension is content-matched to. This list is managed internally by Twitch.
  """
  contentMatchedGames: [Game!]

  """Extension descriprion. 1024 character limit."""
  description: String!

  """
  Games that an extension is associated to. This list is managed by the extension developer.
  """
  games: [Game!]!

  """Icon urls for extensions."""
  iconURLs: ExtensionIcons

  """name of the extension."""
  name: String!

  """Url to an extensions privacy policy."""
  privacyPolicyURL: String!

  """Extension screenshot urls."""
  screenshotURLs: [String!]!

  """Extension summary. 140 character limit."""
  summary: String!

  """Extension developers support email."""
  supportEmail: String!

  """Extension eula/tos url."""
  termsURL: String!

  """Extension viewer summary."""
  viewerSummary: String!
}

"""Extension metadata used for discovery."""
input ExtensionDiscoveryManifestInput {
  """Name of the extension author."""
  authorName: String!

  """Extension categories."""
  categories: [ID!]!

  """Extension descriprion. 1024 character limit."""
  description: String!

  """games an extension is associated with."""
  games: [ID!]!

  """name of the extension."""
  name: String!

  """Url to an extensions privacy policy."""
  privacyPolicyURL: String!

  """Extension summary. 140 character limit."""
  summary: String!

  """Extension developers support email."""
  supportEmail: String!

  """Extension eula/tos url."""
  termsURL: String!

  """
  A summary of the extension's functionality from a viewer's perspective.
  """
  viewerSummary: String
}

"""
ExtensionDynamicManagementInput represents the game ID and whether it is dynamically managed or not on an extension.
"""
input ExtensionDynamicManagementInput {
  """The discovery game ID."""
  gameID: ID!

  """If the game has been marked as dynamically managed or not."""
  isManaged: Boolean!
}

"""An element in a paginated extensions of videos, and its metadata."""
type ExtensionEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the extension for the current edge."""
  node: Extension!
}

"""
The complete set of potential icons provided by a developer to represent their Extension on the site.
"""
type ExtensionIcons {
  """300x200 splash image used in extension discovery & management."""
  discoverySplash: String!

  """Square 100x100 icon used in extension discovery & management."""
  square100: String!

  """Square 24x24 icon used in video player taskbar."""
  square24: String!
}

"""Url and UploadId provided by Upload Service."""
type ExtensionImageUploadResponse {
  """Upload ID."""
  uploadID: ID!

  """Upload URL."""
  url: String!
}

"""
Extension Installation are models which contain an Extension and it's associated installation metadata.
"""
type ExtensionInstallation {
  """
  The abilities this extension can use for the channel it is installed on.
  """
  abilities: ExtensionInstallationAbilities!

  """The current activation metadata for the extension."""
  activationConfig: ExtensionActivationConfig!

  """The extension which the installation record is for."""
  extension: Extension!

  """
  The the composite extension installation ID in the form of <clientID>:<version>:<channelID>.
  """
  id: ID!

  """
  The installer's decision whether to allow an extension to use a particular feature.
  """
  permittedFeatures: ExtensionInstallationFeatureFlags!

  """The required, if any, for the installed extension after an activation."""
  requiredActions: [ExtensionRequiredAction!]

  """The self connection of the extension installation."""
  self: ExtensionInstallationSelfConnection
}

"""The set of abilities an extension is authorized to use."""
type ExtensionInstallationAbilities {
  """Whether the extension can use bits in the current context."""
  isBitsEnabled: Boolean!

  """Whether the extension can send chat messages in the current context."""
  isChatEnabled: Boolean!

  """
  Whether the extension has access to subscription status in the current context.
  """
  isSubscriptionStatusAvailable: Boolean!
}

"""
The dynamic management setting for a content-matched game on an extension installation.
"""
type ExtensionInstallationDynamicManagement {
  """The game that the setting is for."""
  game: Game

  """Whether or not dynamic management is turned on for this extensions."""
  isManaged: Boolean!
}

"""The set of extension features an installer can opt in or out of."""
type ExtensionInstallationFeatureFlags {
  """
  Whether the installer has granted the extension access to their subscriptions list.
  """
  canRetrieveSubscriptionStatus: Boolean!

  """
  Whether the installer has opted in or out of chat capabilities in extensions.
  """
  canSendChat: Boolean!

  """
  Whether the installer has opted in or out of bit capabilities in extensions.
  """
  canUseBits: Boolean!

  """The dynamic management settings for the extension installation."""
  dynamicManagement: [ExtensionInstallationDynamicManagement!]
}

"""The connection a user has to an Installed Extension."""
type ExtensionInstallationSelfConnection {
  """Represents whether the requesting user can activate the extension."""
  canActivate: Boolean!
}

"""
The data that links the active user with a particular extension
installation on a channel.
"""
type ExtensionInstallationSelfEdge {
  """The extension installation."""
  installation: ExtensionInstallation

  """
  Authentication information that links the active user and the installation.
  """
  token: ExtensionToken

  """Configurations set for this extension/user pair."""
  configuration: ExtensionConfiguration

  """
  The time this response was issuedAt, so the client can set a timer for when
  the token needs to be refreshed.
  """
  issuedAt: Time
}

"""Extension Link User Error."""
type ExtensionLinkUserError {
  """The error code."""
  code: ExtensionLinkUserErrorCode
}

"""Extension Link User Error Code."""
enum ExtensionLinkUserErrorCode {
  """The current user is not authorized to link / unlink this extension."""
  UNAUTHORIZED

  """The request body was invalid."""
  BAD_REQUEST

  """An unexpected error occurred."""
  UNKNOWN
}

"""The required input for an ExtensionLinkUser mutation."""
input ExtensionLinkUserInput {
  """The id of the channel the extension is currently installed on."""
  channelID: ID!

  """The ID of the extension that the user would like to link/unlink with."""
  extensionID: ID!

  """The current extension jwt for the user being linked/unlinked."""
  jwt: String

  """Whether to link or unlink the user from this extension."""
  showUser: Boolean!
}

"""The result of a ExtensionLinkUser mutation."""
type ExtensionLinkUserPayload {
  """Error from an Extension Link User Call."""
  error: ExtensionLinkUserError

  """The user's new token reflecting their now linked/unlinked status."""
  token: ExtensionToken
}

"""
ExtensionManifest is the data that represents an entire extension manfiest.
"""
type ExtensionManifest {
  """ExtensionAssetManifest is data related to the assets of an extension."""
  assetManifest: ExtensionAssetManifest!

  """
  Data about what an Extension can do, in general, and at the time of interaction.
  """
  capabilities: ExtensionCapabilities!

  """ExtensionDeveloperManifest is the developer specific extension data."""
  developerManifest: ExtensionDeveloperManifest!

  """Extension metadata used for discovery."""
  discoveryManifest: ExtensionDiscoveryManifest!

  """Extension id."""
  id: ID!

  """Extension version."""
  version: String!

  """Extension views."""
  views: ExtensionViews!
}

"""A paginated list of extension manifests."""
type ExtensionManifestConnection {
  """The list of extension manifests in this page."""
  edges: [ExtensionManifestEdge!]!

  """Information about this page of extension manifests."""
  pageInfo: PageInfo!
}

"""An element in a paginated list of extension manifests."""
type ExtensionManifestEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the extension manifest for the current edge."""
  node: ExtensionManifest
}

"""A summary of extension state and the associated manifests."""
type ExtensionManifestsSummary {
  """The global deleted state of the extension."""
  isDeleted: Boolean!

  """The list of extension manifests."""
  manifests: ExtensionManifestConnection
}

"""
ExtensionPanel is a placeholder in the panel list for arbitrary iframed content.
"""
type ExtensionPanel implements Panel {
  """id is a unique identifier for the panel."""
  id: ID!

  """
  slotID is an identifier to map extensions content from `User.extensions` to the proper place in the `User.panels` list.
  """
  slotID: ID!

  """type is `PanelType.EXTENSION`."""
  type: PanelType!
}

"""
ExtensionRating contains the information of a user's rating of a Twitch extension.
"""
type ExtensionRating {
  """The ID of the recorded rating."""
  id: ID!

  """Whether the user recommended the extension or not."""
  isRecommended: Boolean!

  """Where the user submitted the rating."""
  location: ExtensionRatingLocation!
}

"""Enumerates where the user can submit an extension rating."""
enum ExtensionRatingLocation {
  """The global notifications popout."""
  NOTIFICATION
}

"""A holder for the presigned S3 URL for an extension ratings report."""
type ExtensionRatingsCSVReportPresignedURL {
  """The presigned URL, if one is ready.  Otherwise empty string."""
  presignedURL: String
}

"""Extension recommendation."""
type ExtensionRecommendation {
  """The recommended extension."""
  extension: Extension
}

"""
The action a user must take to complete an activation of an extension installation.
"""
type ExtensionRequiredAction {
  """On PROMPT_FOR_PERMISSIONS the redirectURI to load for OAuth."""
  redirectURI: String @deprecated(reason: "PROMPT_FOR_PERMISSIONS is no longer a valid required action")

  """The action the user must take in order to complete the activation."""
  type: ExtensionRequiredActionType!
}

"""
The possible types of required actions after attempting to activate an extension.
"""
enum ExtensionRequiredActionType {
  """
  The user must accept the permissions in order to complete the activation.
  """
  PROMPT_FOR_PERMISSIONS

  """
  The user must configure the extension in order to complete the activation.
  """
  REQUIRES_CONFIGURATION
}

"""
The shared secret between the extension and the extension validator service.
"""
type ExtensionSecret {
  """When the secret was activated."""
  activeAt: Time!

  """The actual content of the secret."""
  content: String!

  """When the secret expires."""
  expiresAt: Time!
}

"""The extensions secrets information."""
type ExtensionSecretsInfo {
  """A user-friendly error, should one occur."""
  error: GetExtensionSecretsError

  """A list of secrets."""
  secrets: [ExtensionSecret!]
}

"""The connection a user has to an Extension object."""
type ExtensionSelfConnection {
  """Represents whether the requesting user is able to install extensions."""
  canInstall: Boolean!
}

"""The possible values for ExtensionState."""
enum ExtensionState {
  """IN_TEST extensions are currently being worked on by a developer."""
  IN_TEST

  """
  READY_FOR_REVIEW extensions are currently being examined by a developer for their readiness
  to be reviewed (assets hosted on CDN).
  """
  READY_FOR_REVIEW

  """IN_REVIEW extensions are being looked at by Twitch."""
  IN_REVIEW

  """
  REJECTED extensions are permanently rejected; no action by the  developer will make them acceptable.
  """
  REJECTED

  """
  APPROVED extensions are ready to be released, at the developer's convenience.
  """
  APPROVED

  """
  RELEASED extensions are currently available to users.  Only one version of an extension
  can be in this state at any time.
  """
  RELEASED

  """
  DEPRECATED extensions were once released, but a newer version now exists.
  """
  DEPRECATED

  """
  PENDING_ACTION extensions are ones that were reviewed by Twitch and returned to the developer for fixing.
  """
  PENDING_ACTION

  """
  UPLOADING extensions are in the process of having their assets loaded onto S3.
  """
  UPLOADING

  """
  ASSETS_UPLOADED extensions have had their assets uploaded already to S3. This state mirrors
  the existing READY_FOR_REVIEW state, but doesn't incur an implicit upload.
  """
  ASSETS_UPLOADED

  """
  DELETED extensions have been deleted; this is a soft delete so we can undelete things.
  """
  DELETED
}

"""
ExtensionStateFilter contains all the valid states to filter the list of extensions by.
"""
enum ExtensionStateFilter {
  """Released extension."""
  RELEASED
}

"""The support levels for subscriptions features."""
enum ExtensionSubscriptionsSupportLevel {
  """This extension doesn't have any support for subscriptions features."""
  NONE

  """
  This extension has support for subscriptions features but can operate in the event
  the broadcaster disables the permissions.
  """
  OPTIONAL
}

"""The user-specific token for an installed extension on a channel."""
type ExtensionToken {
  """The ID of the extension associated with this token."""
  extensionID: ID!

  """The JWT token for the requesting user."""
  jwt: String!
}

"""
ExtensionVersionDiscoveryManifest is the data that represents an extension discovery manifest.
"""
type ExtensionVersionDiscoveryManifest {
  """Extension metadata used for discovery."""
  discoveryManifest: ExtensionDiscoveryManifest!

  """Extension id."""
  id: ID!

  """Extension version."""
  version: String!
}

"""
ExtensionView is the interface which every anchor-specific extension view extends from.
"""
interface ExtensionView {
  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""The potential anchor-specific configurations and extension can have."""
type ExtensionViews {
  """
  The developer configuration of the extension as a component extension, if supported.
  """
  component: ComponentView

  """
  The developer configuration of the extension's configuration view, if supported.
  """
  config: ConfigView

  """
  The configuration for a hidden extension. The only hidden extension is used for load testing.
  """
  hidden: HiddenView

  """
  The developer configuration of the extension's live configuration dashboard view, if supported.
  """
  liveConfig: LiveConfigView

  """
  The developer configuration of the extension as a mobile extension, if supported.
  """
  mobile: MobileView

  """
  The developer configuration of the extension as a panel extension, if supported.
  """
  panel: PanelView

  """
  The developer configuration of the extension as a video overlay extension, if supported.
  """
  videoOverlay: VideoOverlayView
}

"""The potential anchor-specific configurations and extension can have."""
input ExtensionViewsInput {
  """
  The developer configuration of the extension as a component extension, if supported.
  """
  component: ComponentViewInput

  """
  The developer configuration of the extension's configuration view, if supported.
  """
  config: ConfigViewInput

  """
  The developer configuration of the extension's live configuration dashboard view, if supported.
  """
  liveConfig: LiveConfigViewInput

  """
  The developer configuration of the extension as a mobile extension, if supported.
  """
  mobile: MobileViewInput

  """
  The developer configuration of the extension as a panel extension, if supported.
  """
  panel: PanelViewInput

  """
  The developer configuration of the extension as a video overlay extension, if supported.
  """
  videoOverlay: VideoOverlayViewInput
}

"""Whitelists for restricting extension access and behavior."""
type ExtensionWhitelists {
  """
  List of broadcaster account IDs allowed to install an extension after release.
  If this is empty or missing, all broadcasters can use this extension.
  """
  broadcasters: [ID!]!

  """URLs which are permitted to be opened from the configuration dialog."""
  configURLs: [String!]!

  """
  URLs which are permitted to be opened from an extension set as a panel.
  """
  panelURLs: [String!]!

  """
  List of account IDs which should have access to a version of an extension.
  Users in this list are ignored by the broadcaster whitelist check.
  """
  testers: [ID!]!
}

"""
ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior.
"""
input ExtensionWhitelistsInput {
  """
  List of broadcaster account IDs allowed to install an extension after release.
  If this is empty or missing, all broadcasters can use this extension.
  """
  broadcasters: [ID!]!

  """URLs which are permitted to be opened from the configuration dialog."""
  configURLs: [String!]!

  """
  URLs which are permitted to be opened from an extension set as a panel.
  """
  panelURLs: [String!]!

  """
  List of account IDs which should have access to a version of an extension.
  Users in this list are ignored by the broadcaster whitelist check.
  """
  testers: [ID!]!
}

"""Url and UploadId provided by Upload Service."""
type ExtensionZipUploadResponse {
  """Upload ID."""
  uploadID: ID!

  """Upload URL."""
  url: String!
}

"""ExternalChargeModel defines a 3P managed SKU for a given offer."""
type ExternalChargeModel {
  """
  Externally managed default/static SKU identifier. This is specifically for
  discovery and preview flows. Use `self -> checkoutSKU` for purchase flows.
  """
  previewSKU: String!

  """The provider for this externally managed SKU."""
  provider: String!

  """
  Externally managed default/static SKU identifier. For mobile checkouts, use
  `self` for dynamically vended SKU for the user.
  """
  sku: String! @deprecated(reason: "Use 'previewSKU' instead")

  """The authenticated user's relationship with the external charge model."""
  self: ExternalChargeModelSelfEdge
}

"""The authenticated user's relationship with the internal charge model."""
type ExternalChargeModelSelfEdge {
  """
  The final checkout SKU of this offer available for the authenticated user.
  """
  checkoutSKU: String!
}

"""
FeaturedContentSections contain the a set of FeaturedItems that should be shown
together in a particular section of Twitch apps.
"""
type FeaturedContentSection {
  """
  A combination of the type and style for a given section, i.e. spotlight-previews.
  """
  id: ID!
  items: [FeaturedItem!]
}

type FeaturedItem {
  """The featured item's content."""
  content: FeaturedItemContent

  """
  An markdown description of the item, available when a item is featured.
  """
  description: String!

  """ID used for tracking interactions."""
  id: ID!

  """A URL for a special thumbnail image, when this item is featured."""
  imageURL: String!

  """Is this item featured because it is scheduled?"""
  isScheduled: Boolean!

  """Is this item featured because it is sponsored?"""
  isSponsored: Boolean!

  """A lower priority level means the item is higher priority."""
  priorityLevel: Int!

  """When featured, the title of the item."""
  title: String!
}

union FeaturedItemContent = Stream | User | Video

"""
FeaturedStream contains extra metadata for presenting a featured Stream.
"""
type FeaturedStream {
  """The featured stream's broadcaster."""
  broadcaster: User

  """The featured channel."""
  channel: Channel @deprecated(reason: "Use featuredStream.broadcaster instead.")

  """
  A markdown description of the stream, available when a stream is featured.
  """
  description: String

  """
  An HTML description of the stream, available when a stream is featured.
  """
  descriptionHTML: String @deprecated(reason: "Use featuredStream.description instead")

  """A URL for a special thumbnail image, when this stream is featured."""
  imageURL: String

  """Is this stream featured because it is scheduled?"""
  isScheduled: Boolean

  """Is this stream featured because it is sponsored?"""
  isSponsored: Boolean

  """A lower priority level means the stream is higher priority."""
  priorityLevel: Int

  """The featured live steam."""
  stream: Stream

  """When featured, the title of the stream."""
  title: String
}

"""
DEPRECATED: do not use, it is subject to change.
FeaturedVideo contains extra metadata for presenting a featured video.
"""
type FeaturedVideo {
  """
  An markdown description of the video, available when a video is featured.
  """
  description: String!

  """A URL for a special thumbnail image, when this video is featured."""
  imageURL: String!

  """Is this video featured because it is scheduled?"""
  isScheduled: Boolean!

  """Is this video featured because it is sponsored?"""
  isSponsored: Boolean!

  """A lower priority level means the stream is higher priority."""
  priorityLevel: Int!

  """When featured, the title of the video."""
  title: String!

  """The featured video."""
  video: Video
}

type FeatureFlags {
  isPulseEnabled: Boolean @deprecated(reason: "Enabled for everyone.")
}

"""Feed is twitch's pulse product of content a user may enjoy."""
type Feed {
  id: ID!
  items(first: Int = 5, after: Cursor): FeedItemConnection
}

"""FeedEmbed describes the types of items contained in a Feed."""
union FeedEmbed = Clip | LinkOEmbed | PhotoOEmbed | RichOEmbed | Video | VideoOEmbed

"""
FeedItem is the units of a feed.
They do not have an identifier because you cannot look them up by identifier.
"""
type FeedItem {
  content: FeedItemContent
  reasons: [FeedItemReason]
  tracking: FeedItemTracking
}

type FeedItemConnection {
  edges: [FeedItemEdge]
  pageInfo: PageInfo
}

"""
FeedItemContent is the supported content types that may appear in a feed.
"""
union FeedItemContent = Clip | Post | Share | Stream | Video

type FeedItemEdge {
  cursor: Cursor
  node: FeedItem
}

"""FeedItemReason explains why an item is in your feed."""
type FeedItemReason {
  reason: String
}

"""FeedItemTracking contains the tracking info of a feeditem."""
type FeedItemTracking {
  batchID: String
  cardImpressionID: String
  recGenerationID: String
  recGenerationIndex: Int
}

"""
FinalizeCompetitionLobbyInput contains the inputs required to change a lobby's status to done.
"""
input FinalizeCompetitionLobbyInput {
  """The competition id of the competition."""
  competitionID: ID!

  """The lobbyID of the competition that we want to mark done."""
  lobbyID: ID!

  """The phase id of the competition that this lobby belongs to."""
  phaseID: ID!
}

"""
FinalizeCompetitionLobbyPayload is the success response for updating a lobby to done.
"""
type FinalizeCompetitionLobbyPayload {
  """The new state of competition after marking the lobby as done."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Settings specific to the first cheer tutorial."""
type FirstCheerTutorial {
  """
  Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience.
  """
  hasAbandoned: Boolean

  """
  Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button.
  """
  hasSkipped: Boolean
}

"""Information about the flagged track of copyrighted music."""
type FlaggedTrack {
  """Title of the album of the flagged track."""
  albumTitle: String!

  """The appeal for track's usage."""
  appeal: FlaggedTrackAppeal

  """ID of the flagged track."""
  id: ID!

  """
  Duration in seconds of the mute. Standard length is 360 (6 mins).
  This can be null if the flagged track was succesfully appealed.
  """
  muteDurationSeconds: Int

  """
  Offset is how many seconds into the video the mute begins. 0 indicates the beginning of the video is muted.
  This can be null if the flagged track was succesfully appealed.
  """
  muteOffsetSeconds: Int

  """Performer of the flagged track."""
  performer: String!

  """Title of the flagged track."""
  title: String!
}

"""The appeal information associated with the flagged track."""
type FlaggedTrackAppeal {
  """ID of the track appeal."""
  id: ID!

  """Reason for the track appeal."""
  reason: String!

  """Status of the track appeal, ie. PENDING, RESOLVED, UNKNOWN."""
  status: FlaggedTrackAppealStatus!
}

"""The status of the track appeal."""
enum FlaggedTrackAppealStatus {
  """The track appeal has not yet been resolved."""
  PENDING

  """The track appeal has a resolved at time."""
  RESOLVED
}

"""
Data about the relationship between one User and a User they are following.
"""
type Follow {
  """Whether to disable notifications for this relationship."""
  disableNotifications: Boolean

  """Represents when this relationship was established."""
  followedAt: Time

  """The user who is followed."""
  user: User
}

"""A paginated list of follows relationships."""
type FollowConnection {
  """The elements of the paginated list."""
  edges: [FollowEdge]

  """Information about this page."""
  pageInfo: PageInfo

  """The total number of followers."""
  totalCount: Int
}

"""A list of followed games."""
type FollowedGameConnection {
  """The elements of the paginated list."""
  nodes: [Game!]
}

enum FollowedGamesType {
  """Only games which are currently being streamed will be returned."""
  LIVE

  """All followed games."""
  ALL
}

"""
An element in a paginated list of follows relationships.
Contains metadata about the follow relationship between two users.
"""
type FollowEdge {
  """An opaque cursor identifying the edge's position in the paginted list."""
  cursor: Cursor!

  """Whether to disable notifications for this relationship."""
  disableNotifications: Boolean @deprecated(reason: "use notificationSettings.isEnabled instead.")

  """Represents when this relationship was established."""
  followedAt: Time

  """The user who is followed."""
  node: User

  """Notification settings for this relationship."""
  notificationSettings: ChannelNotificationSettings
}

"""
A list of broadcasters followed by a user and hosting live broadcasters.
"""
type FollowedHostConnection {
  """The broadcasters."""
  nodes: [User]
}

"""A list of live-streaming broadcasters followed by a user."""
type FollowedLiveUserConnection {
  """The live broadcasters."""
  edges: [FollowedLiveUserEdge]!

  """The live broadcasters."""
  nodes: [User] @deprecated(reason: "Use FollowedLiveUserConnection.edges instead for pagination support")

  """Pagination."""
  pageInfo: PageInfo!
}

"""A live streaming broadcaster with cursor."""
type FollowedLiveUserEdge {
  cursor: Cursor!
  node: User
}

"""A paginated list of followers relationships."""
type FollowerConnection {
  """The elements of the paginated list."""
  edges: [FollowerEdge]

  """Metadata about this page."""
  pageInfo: PageInfo

  """The total number of followers."""
  totalCount: Int
}

"""
An element in a paginated list of followers.
Contains metadata about the follower relationship between two users.
"""
type FollowerEdge {
  """An opaque cursor identifying the edge's position in the paginted list."""
  cursor: Cursor!

  """Whether to disable notifications for this relationship."""
  disableNotifications: Boolean

  """Represents when this relationship was established."""
  followedAt: Time

  """The user who is a follower."""
  node: User

  """Notification settings for this relationship."""
  notificationSettings: ChannelNotificationSettings
}

input FollowGameInput {
  """The identifier of the game to follow."""
  gameID: ID!
}

type FollowGamePayload {
  """The game that was followed if the operation was successful."""
  game: Game
}

enum FollowsFilter {
  """All users the user is following."""
  ALL

  """
  Users the user is following to which the user can subscribe.
  this is authenticated so only a logged in user can filter by SUBBABLE.
  """
  SUBBABLE
}

"""Information to communicate to the user about an error state."""
type FollowUserError {
  """Error code."""
  code: FollowUserErrorCode!
}

"""Enum for follow errors."""
enum FollowUserErrorCode {
  """Used when fromUser is being blocked by targetUser."""
  FORBIDDEN

  """Used when user has reached their follow cap."""
  TOO_MANY_FOLLOWS
}

input FollowUserInput {
  """
  disableNotifications, when true, prevents the followed user's stream from sending email and push notifications to
  the authenticated user when it goes live.
  """
  disableNotifications: Boolean!
  targetID: ID!
}

type FollowUserPayload {
  """Used for user blocked errors."""
  error: FollowUserError

  """The new follow relationship."""
  follow: Follow
}

"""The format type signifies the format the competition will run from."""
enum FormatType {
  """Double elimination bracket format."""
  DOUBLE_ELIM

  """Single elimination bracket format."""
  SINGLE_ELIM

  """Round robin format."""
  ROUND_ROBIN

  """Leaderboard format."""
  LEADERBOARD

  """Custom format."""
  CUSTOM

  """Unknown format."""
  UNKNOWN
}

"""
The details of different formats. Currently there is only 1 detail type.
"""
union FormatTypeDetails = LeaderboardDetails

"""
FragmentContent contains the parse content of a fragment, and can be an emote or a mention.
NOTE: should have been called RoomMessageFragmentContent.
"""
union FragmentContent = AutoMod | CheermoteToken | Emote | RoomMessageGroupMention | User

"""A list of a user's friend relationships."""
type FriendConnection {
  """The friend elements of this list."""
  edges: [FriendEdge]

  """The total number of friends this user has."""
  totalCount: Int!
}

"""The friendship between the authenticated user and another user."""
type FriendEdge {
  """An action that a user or session is performing."""
  activity: Activity

  """The computed state of a user or session."""
  availability: Availability!

  """The last time the friend's availability or activity changed."""
  lastStatusChangeAt: Time

  """The friend user."""
  node: User
}

"""
The friend-type relationship between the authenticated user and another user.

If this field is a FriendEdge, the authenticated user and the other user are Friends.

If it is an IncomingFriendRequestEdge, the other user has an open friend request with authenticated user.

If it is an OutgoingFriendRequestEdge, the authenticated user has an open friend request with the other user.
"""
union FriendRelationship = FriendEdge | IncomingFriendRequestEdge | OutgoingFriendRequestEdge

"""Decides how to sort Friendship-related responses."""
enum FriendSort {
  """Sort from oldest to newest."""
  ASC

  """Sort from newest to oldest."""
  DESC
}

"""A Game is often the subject of a Stream on Twitch."""
type Game implements Directory {
  """What campaigns are active for this game."""
  activeDropCampaigns: [DropCampaign!] @deprecated(reason: "Functionality not supported in Drops 2.0")

  """
  URL to an avatar image.
  The image dimensions are specifiable via the `height` and `width` parameters.
  
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  avatarURL(width: Int, height: Int): String

  """
  URL to a box art image.
  The image dimensions are specifiable via the `height` and `width` parameters.
  
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  boxArtURL(width: Int, height: Int): String

  """Number of broadcasters streaming this game."""
  broadcastersCount: Int

  """Number of channels currently streaming this game."""
  channelsCount: Int @deprecated(reason: "Use broadcastersCount instead.")

  """
  A paginated list of clips featuring this game, ordered by view count descending.
  When criteria is not specified, the default values are used.
  """
  clips(first: Int = 10, after: Cursor, criteria: GameClipsInput): ClipConnection

  """
  URL to a cover image.
  The image dimensions are specifiable via the `height` and `width` parameters.
  
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  coverURL(width: Int, height: Int): String

  """The game's description."""
  description: String

  """The game's developers."""
  developers: [String!]

  """The type of directory – in this case, always GAME."""
  directoryType: DirectoryType

  """
  The translated game name used for display purposes.
  Use name for tracking props or URLs.
  """
  displayName: String!

  """
  The associated clientID for a game used to determine if users have an account link
  created between tuid and in-game userID as well as the timestamp of when this link was created.
  """
  dropAccountLink: DropAccountLink

  """
  A list of clients that use the Enhanced Experiences (E2) API for
  Twitch integrations with this game.
  """
  enhancedExperiencesClients(organizationID: ID!): [EnhancedExperiencesClient!]

  """The game's ESRB rating."""
  esrbRating: ESRBRating!

  """The game's ESRB descriptions."""
  esrbDescriptions: [String!]

  """A list of extension recommendations, according to the game."""
  extensionRecommendations: [ExtensionRecommendation!]

  """Number of users that follow this game."""
  followersCount: Int

  """The franchises the game belongs to."""
  franchises: [String!]

  """The game's unique GiantBomb identifier."""
  giantBombID: ID @deprecated

  """
  The game's unique Twitch identifier.
  It is used to associate games with product offers.
  """
  id: ID!

  """
  URL to a game logo image.
  The image dimensions are specifiable via the `height` and `width` parameters.
  
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  logoURL(width: Int, height: Int): String

  """
  The name of the game. This string is untranslated.
  This field should only be used in limited occassions, like tracking and URLs.
  You should use displayName for all all game names shown to the users.
  """
  name: String!

  """
  The original release date of the game. Date string is formatted as yyyy-mm-ddThh:mm:ssZ.
  """
  originalReleaseDate: String

  """The platforms the game is on."""
  platforms: [String!]

  """A measure of the games popularity."""
  popularityScore: Int

  """The game's unique Presto identifier."""
  prestoID: ID

  """The game's publishers."""
  publishers: [String!]

  """The authenticated user's relationship with this Game."""
  self: GameSelfConnection

  """
  Get a page of live streams broadcasting this game.
  The languages param can be used to filter the streams. Otherwise all languages will be returned.
  The filters param contains additional metadata filters, for example {hearthstoneGameMode: "arena"}.
  The sort param can be used to change the default sorting, which sometimes is specific to specific games.
  The tags param are an array of tag ID as optional filters for streams.
  DEPRECATED field arguments: languages, requestID, sort, tags
  Use GameStreamOptions instead.
  """
  streams(first: Int = 10, after: Cursor, options: GameStreamOptions, languages: [String!], filters: StreamMetadataFilterInput, sort: StreamSort = VIEWER_COUNT, requestID: ID, tags: [String!]): StreamConnection

  """List of recommeded tags in the corresponding category."""
  tags(limit: Int = 5, tagType: TagType!): [Tag!]

  """A paginated list of top videos for this game."""
  videos(first: Int = 10, after: Cursor, languages: [String!], types: [BroadcastType!], sort: VideoSort = TIME): VideoConnection

  """
  Number of viewers currently watching a stream which features this game.
  """
  viewersCount: Int
}

"""
GameApplication is an application to associate a game with an organization.
"""
type GameApplication {
  """Creation time."""
  createdAt: Time!

  """Game that is added in the application."""
  game: Game!

  """ID of the game application, stored in RBAC."""
  id: ID!

  """Organization that is going to be associated with the game."""
  organization: Organization!
}

"""Moment Details specific to a game change."""
type GameChangeMomentDetails {
  """The game that the user changed to."""
  game: Game
}

"""Filtering criteria for paginated game clips results."""
input GameClipsInput {
  """The ID of the broadcaster to filter results by."""
  broadcasterID: ID

  """The ID of the curator to filter results by."""
  curatorID: ID

  """
  Overrides the period. if startAt is provided, but endAt isn't, the endAt value will be the day when the query was made.
  """
  endAt: Time

  """
  DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
  A filter which restricts results.
  """
  filter: ClipsFilter

  """
  Clip results will be filtered by this language.
  Omit this input field to get results by all languages.
  """
  languages: [Language!]

  """The time period to restrict clips based on creation time."""
  period: ClipsPeriod = LAST_WEEK

  """The sort order for the clips results."""
  sort: ClipsSort = VIEWS_DESC

  """
  Overrides the period param. If endAt is provided, but startAt isn't, 2015-01-01 will be used for it.
  """
  startAt: Time
}

"""
Paginated list of Games.
Implements the Relay cursor connections specification.
See: https://facebook.github.io/relay/graphql/connections.htm.
"""
type GameConnection {
  """The list of games to display."""
  edges: [GameEdge!]
  pageInfo: PageInfo!
}

"""
Contains information about a Game's relationship to a given page (connection),
and the Game itself.
"""
type GameEdge {
  cursor: Cursor
  node: Game

  """
  Unique id per game response item, used by clients to attribute displays/clicks to items.
  """
  trackingID: ID
}

"""Game followed by a User."""
type GameFollow {
  """Represents when this relationship was established."""
  followedAt: Time!

  """The game that is followed."""
  game: Game

  """The user who is following."""
  user: User
}

"""
Optional input to filter categories.
Add any additional optional fields to this input.
"""
input GameOptions {
  """The locale of the user."""
  locale: String

  """
  If sorted by relevance, this provides additional context used to influence recommendations.
  """
  recommendationsContext: RecommendationsContext

  """
  A GUID that is created by the caller for tracking. This should be globally
  unique per request and is required if sort=RELEVANCE.
  """
  requestID: ID

  """The sort param can be used to change the default sorting of results."""
  sort: GameSort = VIEWER_COUNT

  """Tags are an array of tag IDs as optional filters for categories."""
  tags: [String!]
}

"""Game that my viewers also like to watch."""
type GameOverlap {
  """How much my viewers like to watch this game."""
  score: Float!

  """Game that my viewers also like to watch."""
  viewersAlsoWatch: Game
}

"""The relationship between the authenticated user and a game."""
type GameSelfConnection {
  """The current user's follow relationship with this game."""
  follow: GameFollow

  """
  Whether or not the current user has a link to this game that can be used
  for Drops.
  """
  isDropsLinked: Boolean
}

"""Possible ways of sorting collections of categories."""
enum GameSort {
  """Sort by number of concurrent viewers, descending (most viewers first)."""
  VIEWER_COUNT

  """Sort by relevance to the current user."""
  RELEVANCE
}

"""
Optional input to filter game specific streams.
add additional optional fields to this input.
"""
input GameStreamOptions {
  """Filter streams based on restriction types."""
  includeRestricted: [StreamRestrictionType!]

  """
  Broadcaster languages to filter streams by.
  Deprecated: use language tags instead.
  """
  languages: [String!]

  """The locale of the user."""
  locale: String

  """
  If sorted by relevance, this provides additional context used to influence recommendations.
  """
  recommendationsContext: RecommendationsContext

  """RequestID must be specified if sort=RELEVANCE."""
  requestID: ID

  """
  The sort param can be used to change the default sorting, which sometimes is specific to specific games.
  """
  sort: StreamSort = VIEWER_COUNT

  """The tags param are an array of tag ID as optional filters for streams."""
  tags: [String!]
}

"""GDPR Consent contains user consent on different tracking vendors."""
input GDPRConsent {
  """Whether Amazon has user GDPR consent."""
  allowAmazon: Boolean

  """Whether Comscore has user GDPR consent."""
  allowComscore: Boolean

  """Whether Google has user GDPR consent."""
  allowGoogle: Boolean

  """Whether Nielson has user GDPR consent."""
  allowNielsen: Boolean

  """Whether Salesforce has user GDPR consent."""
  allowSalesforce: Boolean
}

"""
GDPR cookie vendors either support TCF Strings or dont, hence two types of GDPR Vendors.
"""
union GDPRCookieVendor = NonTCFCookieVendor | TCFCookieVendor

"""List of GDPR cookie vendors."""
type GDPRVendorConsent {
  """status for vendors."""
  status: [GDPRCookieVendor!]!
}

"""Input to the animateEmote mutation."""
input GenerateAnimatedEmoteInput {
  """The ID for the input image. Must be the 4x size."""
  image4xID: ID!

  """The preset animation to apply on the provided static emote."""
  preset: AnimatedEmotePreset!
}

"""Payload from the animateEmote mutation."""
type GenerateAnimatedEmotePayload {
  """
  The ID of the generate request. Pubsub messages will contain this ID to match up the message with the generate request.
  """
  id: ID

  """The animated emote assets."""
  animatedAssets: [AnimatedImageAsset!]
}

"""
GenerateExtensionRatingsCSVInput takes an extensionID and some time range info for generating a CSV of extension ratings
data for an extension developer.
Authenticated on UserID via oauth token and OWL (via the ExtensionRatings backend).
"""
input GenerateExtensionRatingsCSVReportInput {
  """
  endAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD.
  """
  endAt: Time!

  """extensionID to generate a CSV of ratings data for."""
  extensionID: ID!

  """
  startAt is expected to be RFC3339 UTC and is inclusive in the results when truncated to YYYY-MM-DD.
  """
  startAt: Time!
}

"""
GenerateExtensionRatingsCSVPayload returns the filename that the CSV report will have when it is completed, and gives
the caller something to poll for.
"""
type GenerateExtensionRatingsCSVReportPayload {
  """reportFilename is the filename for the generated report."""
  reportFilename: String
}

"""Error returned during a invalid user request."""
type GenerateSecondFactorQRCodeError {
  """Error code returned by the backend."""
  code: GenerateSecondFactorQRCodeErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to generate a second factor QR code.
"""
enum GenerateSecondFactorQRCodeErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """
  The user does not have two factor enabled and cannot generate a QR code.
  """
  NO_TWO_FACTOR

  """The user has requested too many second factor QR codes."""
  REQUEST_THROTTLED

  """The user does not exist."""
  USER_NOT_FOUND

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a generateSecondFactorQRCode mutation."""
input GenerateSecondFactorQRCodeInput {
  """The ID of the user that is requesting a new second factor QR code."""
  userID: ID!
}

"""The result of a generateSecondFactorQRCode mutation."""
type GenerateSecondFactorQRCodePayload {
  """error code and localized error."""
  error: GenerateSecondFactorQRCodeError

  """qrCode will be a base64 encoded png file."""
  qrCode: String
}

"""
GenerateSubscribersCSVInput takes a channelID to generate a CSV of subscribers for.
Authenticated on channelID.
"""
input GenerateSubscribersCSVInput {
  """channelID to generate a CSV of subscribers for."""
  channelID: String!
}

"""
GenerateSubscribersCSVPayload returns the channelID it currently generating
a CSV for.
"""
type GenerateSubscribersCSVPayload {
  """channelID that a subscribers CSV is being generated for."""
  channelID: ID!
}

"""The input for getting upload config."""
input GetEmoteUploadConfigInput {
  """The type of asset to be uploaded."""
  assetType: EmoteAssetType

  """
  If the asset type is "animated", whether to generate the static versions from the first frame.
  """
  generateStaticVersionOfAnimatedAssets: Boolean

  """Resizing plan to use."""
  resizePlan: EmoteResizePlan!

  """Sizes to provide upload URLs for."""
  sizes: [EmoteImageSize!]
}

"""Response payload."""
type GetEmoteUploadConfigPayload {
  """Upload config for resizing/original."""
  uploadConfig: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")

  """Upload config for 1x image resouce."""
  uploadConfig1x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")

  """Upload config for 2x image resource."""
  uploadConfig2x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")

  """Upload config for 4x image resource."""
  uploadConfig4x: UploadConfig @deprecated(reason: "Use uploadConfigs instead.")

  """Upload configs for all sizes and asset types."""
  uploadConfigs: [UploadConfig!]
}

"""An error describing why the issue happened, when relevant."""
enum GetExtensionSecretsError {
  """User has indicated an invalid extension id."""
  INVALID_CLIENT

  """User is unable to read the extension secrets."""
  UNAUTHORIZED

  """Something went wrong on our side that we need to fix."""
  INTERNAL
}

"""
GiftCardCode that can be claimed to add a monetary balance to a user's account.
"""
type GiftCardCode implements Claimable {
  """A description of what is claimable for the code."""
  description: String!

  """The ID of the Gift Card code."""
  id: ID!

  """The field that gives us claim information for the logged in user."""
  self: SelfClaimEdge

  """The type is `ClaimableType.GIFT_CARD_CODE`."""
  type: ClaimableType!
}

"""User edge relating the pin's status to the user."""
type GiftCardCodeSelfClaimEdge implements SelfClaimEdge {
  """If the user is eligible to claim the key code."""
  canClaim: Boolean!

  """Nullable field for the country where the user redeemed the claimable."""
  countryOfResidence: String

  """The user ID that is claiming the code."""
  id: ID!

  """Nullable status code for if the user cannot claim the key code."""
  statusCode: String
}

"""Types of a gift offer."""
enum GiftType {
  """A single recipient gift type."""
  SINGLE_RECIPIENT

  """A community gift type."""
  COMMUNITY
}

"""
GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available.
"""
type GlobalCheerConfig {
  """
  The CheermoteDisplayConfig provides information about how Cheermotes can be displayed
  This includes things like the possible sizes, colors, backgrounds, and display order.
  """
  displayConfig: CheermoteDisplayConfig!

  """The Cheermote Groups containing the Global Cheermotes."""
  groups: [CheermoteGroup!]!
}

"""Analytics associated with a given notification."""
type GoLiveNotification {
  """Custom notification text, e.g., "Summit1g playing Hearthstone today"."""
  customText: String!

  """Number of followers that engaged with the notification."""
  engagements: Int!

  """Number of followers at the time the notification was sent."""
  followerCount: Int!

  """Number of followers that were sent the notification."""
  followersNotified: Int!

  """Time that the associated stream went live."""
  streamStartTime: Time!
}

"""
GoLiveNotificationConnection represents GoLiveNotification edges and page metadata.
"""
type GoLiveNotificationConnection {
  """
  Each GoLiveNotificationEdge contains the GoLiveNotification node and cursor data.
  """
  edges: [GoLiveNotificationEdge!]!

  """Page metadata includes hasNextPage/hasPreviousPage."""
  pageInfo: PageInfo!
}

"""
GoLiveNotificationEdges are returned by a given GoLiveNotificationConnection.
"""
type GoLiveNotificationEdge {
  """
  A GoLiveNotification cursor is represented by an exclusive stream start time.
  """
  cursor: Cursor!

  """The actual GoLiveNotification payload associated with a given edge."""
  node: GoLiveNotification
}

"""Analytics associated with go live notification timeseries."""
type GoLiveNotificationTimeseries {
  """
  Grouping of notification timeseries items with timestamp and engagements.
  """
  items: [GoLiveNotificationTimeseriesItem!]

  """Sum of all notification engagements for a given date range."""
  total: Int!
}

"""
Single go live notification timeseries item. Represents day, or week/monthly aggregation.
"""
type GoLiveNotificationTimeseriesItem {
  """Number of engagements for a single set of go live notifications."""
  engagements: Int!

  """First timestamp for a single set of go live notifications."""
  timestamp: Time!
}

"""GoRaidError is the error associated with a goRaid."""
type GoRaidError {
  """The associated error code."""
  code: GoRaidErrorCode!
}

"""GoRaidErrorCode are the possible errors that this mutation returns."""
enum GoRaidErrorCode {
  """The request is missing valid channel parameters."""
  INVALID_CHANNEL

  """The user tries to unraid without an active raid."""
  NO_ACTIVE_RAID
}

"""Inputs to the goRaid mutation."""
input GoRaidInput {
  """Source ID."""
  sourceID: ID!
}

"""Outputs from the goRaid mutation."""
type GoRaidPayload {
  """The possible error returned from the service."""
  error: GoRaidError

  """The raid then just went."""
  raid: Raid
}

"""Set based on the auth input type."""
enum GrantType {
  """Used for the initial flow after LWA, one-time usage."""
  AUTHORIZATION_CODE

  """Used for follow up refreshes, can be used as many times as needed."""
  REFRESH_TOKEN
}

"""GrantVIPError contains details about a client error that occurred."""
type GrantVIPError {
  """The type of error that occurred when granting VIP status."""
  code: GrantVIPErrorCode!
}

"""
GrantVIPErrorCode defines a client error that occurred while granting the VIP status.
"""
enum GrantVIPErrorCode {
  """The channel does not exist."""
  CHANNEL_NOT_FOUND

  """
  The granter does not have permission to grant VIP status in this channel.
  """
  FORBIDDEN

  """
  The user who is to be granted the VIP status actually already has the VIP status.
  """
  GRANTEE_ALREADY_VIP

  """
  The user who is to be granted the VIP status is banned or timed out in this channel.
  """
  GRANTEE_CHAT_BANNED

  """The user who is to be granted the VIP status does not exist."""
  GRANTEE_NOT_FOUND

  """
  The channel has reached the maximum number of users with the VIP status and cannot grant the status to any more users.
  """
  MAX_VIPS_REACHED

  """
  The channel has not completed the VIP Achievement to unlock the VIP feature.
  """
  VIP_ACHIEVEMENT_INCOMPLETE
}

"""
GrantVIPInput contains the parameters to grant the VIP status to a user for a channel.
"""
input GrantVIPInput {
  """The channel for which the VIP status of a user will be granted."""
  channelID: ID!

  """
  The ID of the user who will be granted the VIP status.
  Either granteeID or granteeLogin must be provided.
  """
  granteeID: ID

  """
  The login of the user who will be granted the VIP status.
  Either granteeID or granteeLogin must be provided.
  """
  granteeLogin: String
}

"""
GrantVIPPayload is the response after attemping to grant the VIP status to a user.
"""
type GrantVIPPayload {
  """The channel for which the VIP status of the user was granted."""
  channel: User

  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: GrantVIPError

  """The user who was granted the VIP status."""
  grantee: User
}

"""Different types of granularities supported."""
enum Granularity {
  """Bucketed by five minute intervals."""
  FIVE_MINUTE

  """Bucketed by twenty minute intervals."""
  TWENTY_MINUTE

  """Bucketed by forty minute intervals."""
  FORTY_MINUTE

  """Bucketed by day intervals."""
  DAY

  """Bucketed by week intervals."""
  WEEK

  """Bucketed by month intervals."""
  MONTH
}

"""The hearthstone game mode that was played."""
type HearthsoneMomentGameMode {
  """The game type (e.g. Ranked, Casual, Arena, Pack Opening, etc.)."""
  type: String!

  """
  The value for the game type (e.g. 0-11 for Arena, Priest vs Warlock for Ranked).
  """
  value: String
}

"""Moment Details specific to the hearthstone game."""
type HearthstoneMomentDetails {
  """The broadcasters hero, can be null."""
  broadcasterHero: HearthstoneMomentHero

  """The game mode that was played, can be null."""
  gameMode: HearthsoneMomentGameMode

  """The oponents hero, can be null."""
  opponentHero: HearthstoneMomentHero
}

"""The hero that either the broadcaster or opponent played."""
type HearthstoneMomentHero {
  """The hero's (capitalized) class."""
  class: String!

  """The hero's id."""
  id: ID!

  """The hero's (capitalized) name."""
  name: String!
}

"""Represents the user's Hero."""
type Hero {
  """A unique ID for this hero."""
  id: ID!

  """The URI to the pre-composited, full-resolution hero image."""
  imageURI: String!

  """The configuration of that hero, to be used by the editor."""
  self: HeroConfiguration
}

"""Representation of a Hero asset."""
type HeroAsset {
  """User colorization of the asset, if any."""
  color: String

  """URI to the asset's color mask image."""
  colorMaskURI: String

  """When does this asset expire."""
  expiresAt: Time

  """Is this asset new to the requesting user."""
  isNew: Boolean

  """URI to the asset's line art image."""
  lineArtURI: String

  """
  What skeletons does this asset function properly on.  A NULL entry here
  indicates that the asset will function on all skeletons.
  """
  supportedSkeletons: [HeroSkeleton!]

  """The type of the asset."""
  type: HeroAssetType!
}

"""Represents the position of an asset relative to a skeleton."""
type HeroAssetPosition {
  """Which type of asset this position refers to."""
  assetType: HeroAssetType!

  """x coordinate of the position."""
  x: Int!

  """y coordinate of the position."""
  y: Int!
}

"""The complete list of asset types."""
enum HeroAssetType {
  """Background asset."""
  BACKGROUND

  """Hat asset."""
  HAT

  """Hair asset."""
  HAIR

  """Eyebrow asset."""
  EYEBROWS

  """Eye asset."""
  EYES

  """Glasses asset."""
  GLASSES

  """Nose asset."""
  NOSE

  """Mouth asset."""
  MOUTH

  """Facial hair asset."""
  FACIAL_HAIR

  """Freckles asset."""
  FRECKLES

  """Undershirt asset."""
  UNDERSHIRT

  """Jacket asset."""
  JACKET

  """Gloves asset."""
  GLOVES

  """Pants asset."""
  PANTS

  """Socks asset."""
  SOCKS

  """Shoes asset."""
  SHOES
}

"""Represents the user's Hero configuration."""
type HeroConfiguration {
  """What assets the user has equipped."""
  assets: [HeroAsset!]

  """Which skeleton the user employed."""
  skeleton: HeroSkeleton

  """What color was applied to that skeleton."""
  skeletonColor: String
}

"""The hero preset."""
enum HeroPreset {
  """The first preset."""
  PRESET_1

  """The second preset."""
  PRESET_2
}

"""Represents a Hero skeleton."""
type HeroSkeleton {
  """
  List of x,y offsets for the assets to be properly composited on this skeleton.
  """
  assetPositions: [HeroAssetPosition!]!

  """URI to the color mask for the skeleton."""
  colorMaskURI: String!

  """The UUID for this skeleton."""
  id: ID!

  """URI to the line art for the skeleton."""
  lineArtURI: String!
}

"""
HiddenView holds the view configuration of an extension if it is a hidden load test extension.
"""
type HiddenView implements ExtensionView {
  """
  Specifies whether or not the extension has the ability to link to external websites.
  """
  canLinkExternalContent: Boolean!

  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
HiddenView holds the view configuration of an extension if it is a hidden load test extension.
"""
input HiddenViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
Input to describe a single continuous time range of the source VOD to be included in the highlight.
"""
input HighlightRange {
  """The end time offset in milliseconds into the VOD."""
  endMs: Int!

  """The start time offset in milliseconds into the VOD."""
  startMs: Int!

  """The ID of the source VOD to create a Highlight from."""
  vodID: ID!
}

"""
An minimal version of a DONE CompetitionLobby focusing on the outcome of a lobby
"""
type HistoricalCompetitionLobby {
  """id is the unique id of the HistoricalCompetitionLobby."""
  id: ID!

  """
  The participant who had a higher score, if scores are equal and the lobby is done, the lobby ended in a tie.
  """
  winner: CompetitionLobbyParticipant
}

"""Paginated list of Users hosting a particular target User."""
type HostConnection {
  """Users hosting a target User."""
  edges: [HostEdge!]

  """Pagination information for this connection."""
  pageInfo: PageInfo!

  """The total number of users hosting a target."""
  totalCount: Int
}

"""Edge between Users hosting a target."""
type HostEdge {
  """Unique identifier for each Users hosting."""
  cursor: Cursor!

  """A User hosting."""
  node: User
}

"""HostTargetChannelError contains a error code."""
type HostTargetChannelError {
  """The type of error that occurred when trying to host."""
  code: HostTargetChannelErrorCode!
}

"""HostTargetChannelErrorCode are the list of thrown errors."""
enum HostTargetChannelErrorCode {
  """The target channel is already being hosted."""
  TARGET_CHANNEL_ALREADY_HOSTED

  """
  The target channel is unhostable because the target channel has ignored/banned
  the channel attempting to host, the target channel is blocked from hosting, etc.
  """
  UNHOSTABLE_CHANNEL

  """
  The target channel is a TOS/DMCA/suspended channel and cannot be hosted.
  """
  TARGET_CHANNEL_IN_BAD_STANDING

  """A channel cannot host itself."""
  CANNOT_HOST_SELF
}

"""
HostTargetChannelInput contains the necessary inputs to host a target channel.
"""
input HostTargetChannelInput {
  """Channel ID where host was initiated on."""
  channelID: ID!

  """Target channel ID to host."""
  targetID: ID!
}

"""HostTargetChannelPayload is the response after attempting to host."""
type HostTargetChannelPayload {
  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: HostTargetChannelError

  """The channel that is hosting."""
  source: User

  """The target channel that is hosted."""
  target: User
}

"""
The wrapper structure that contains information regarding a Hype Train.
"""
type HypeTrain {
  """
  Configuration for Hype Trains for a channel, normally loaded this way when configuring the Hype Train from the
  Broadcaster's perspective.
  """
  config: HypeTrainConfig

  """
  Information pertaining to executions of Hype Trains in a channel. This is loaded on channel page load.
  """
  execution: HypeTrainExecution
}

"""The Hype Train reward that's a Badge."""
type HypeTrainBadgeReward implements HypeTrainReward {
  """The badge that is to be entitled."""
  badge: Badge

  """The identifier of the reward."""
  id: ID!

  """The type of reward, which will be HypeTrainRewardType.BADGE."""
  type: HypeTrainRewardType!
}

"""A conductor of the Hype Train."""
type HypeTrainConductor {
  """The participation that made them the Hype Train conductor."""
  participation: [HypeTrainParticipation!]!

  """The conductor source."""
  source: HypeTrainParticipationSource!

  """The user object that is the conductor."""
  user: User!
}

"""The configured conductor rewards for a given participation source."""
type HypeTrainConductorReward {
  """
  The rewards entitled for being the conductor and contributing from this source.
  """
  rewards: [HypeTrainReward!]!

  """The source that the conductor participated from."""
  source: HypeTrainParticipationSource!

  """The type of conductor that gets this reward."""
  type: HypeTrainConductorType!
}

"""The conductor type of the Hype Train reward."""
enum HypeTrainConductorType {
  """The current conductor of an active hype train."""
  CURRENT

  """The former conductor of a hype train."""
  FORMER

  """An unknown conductor type."""
  UNKNOWN
}

"""The Hype Train config for a channel."""
type HypeTrainConfig {
  """
  A custom setting that will be an emote that the user has chosen (or PogChamp
  if not set) to display in their Hype Train events.
  """
  calloutEmote: Emote

  """The conductor rewards for a Hype Train successful execution."""
  conductorRewards: [HypeTrainConductorReward!]!

  """The cooldown period between Hype Train executions."""
  cooldownPeriodMinutes: Int!

  """The difficulty of the Hype Train."""
  difficulty: HypeTrainDifficulty!

  """The configured levels of the Hype Train."""
  difficultySettings: [HypeTrainDifficultySettings!]!

  """The identifier for the hype train."""
  id: ID!

  """The boolean flag that denotes if the Hype Train is enabled or not."""
  isEnabled: Boolean!

  """
  The structure that holds the parameters for tweaking how a Hype Train gets kicked off.
  """
  kickoff: HypeTrainKickoffConfig!

  """The duration a Hype Train level executes for."""
  levelDurationSeconds: Int!

  """The threshold for a notification to be displayed."""
  notificationThresholds: [HypeTrainNotificationThreshold!]!

  """
  The conversion rates for all the actions that contribute to Hype Train progress.
  """
  participationConversionRates: [HypeTrainParticipationConversionRate!]!

  """
  Hex color for the current hype train. Null if not enabled or no theme color is set.
  """
  primaryHexColor: String

  """
  A boolean flag that indicates if the hype train settings should be personalized by Twitch.
  """
  shouldUsePersonalizedSettings: Boolean!

  """
  A custom setting for using the creators color as the base color of hype trains.
  """
  willUseCreatorColor: Boolean!
}

"""The difficulty a Hype Train can be set to."""
enum HypeTrainDifficulty {
  """Easy, the easiest difficulty level."""
  EASY

  """Medium, the middle difficulty level."""
  MEDIUM

  """Hard, the hard difficulty level."""
  HARD

  """Super Hard, the harder difficulty level."""
  SUPER_HARD

  """Insane, the hardest difficulty level."""
  INSANE

  """An unknown difficulty."""
  UNKNOWN
}

"""A mapping between a difficulty and the levels that correspond."""
type HypeTrainDifficultySettings {
  """The difficulty of the level."""
  difficulty: HypeTrainDifficulty!

  """The levels associated with the difficulty."""
  levels: [HypeTrainLevel!]!
}

"""The Hype Train reward that's an Emote."""
type HypeTrainEmoteReward implements HypeTrainReward {
  """The emote that is to be entitled."""
  emote: Emote

  """The identifier of the reward."""
  id: ID!

  """The type of reward, which will be HypeTrainRewardType.EMOTE."""
  type: HypeTrainRewardType!
}

"""The enumerated end reasons for a Hype Train."""
enum HypeTrainEndReason {
  """
  The Hype Train expired, which means that the Hype Train never completed level 1 after being started.
  """
  EXPIRED

  """The Hype Train is in progress, which means it has not ended."""
  IN_PROGRESS

  """
  The Hype Train was completed, which means that any level was completed.
  """
  COMPLETED

  """An unknown ending reason."""
  UNKNOWN
}

"""An enumeration of event types for Hype Train Activity Feeds."""
enum HypeTrainEventType {
  """Event of when a Hype Train started for the given channel."""
  HYPE_TRAIN_STARTED

  """Event of when a Hype Train ended for the given channel."""
  HYPE_TRAIN_ENDED

  """Notification of when another Hype Train can start."""
  HYPE_TRAIN_COOL_DOWN_EXPIRED
}

"""The structure that defines Hype Train Execution in a channel."""
type HypeTrainExecution {
  """The conductors of the Hype Train."""
  conductors: [HypeTrainConductor!]!

  """The Hype Train config that the train was started with."""
  config: HypeTrainConfig!

  """The reason the Hype Train was ended, if it has been ended."""
  endReason: HypeTrainEndReason

  """
  The time the Hype Train was ended, if the Hype Train was a previous execution.
  """
  endedAt: Time

  """The time that the Hype Train will expire at."""
  expiresAt: Time!

  """The identifier of the execution."""
  id: ID!

  """Boolean flag that denotes if the Hype Train is active or not."""
  isActive: Boolean!

  """The participation events in the Hype Train."""
  participations: [HypeTrainParticipation!]!

  """
  The progress structure that contains relevant information about how much progress the Hype Train acheived.
  """
  progress: HypeTrainProgress!

  """The time that the Hype Train started."""
  startedAt: Time!

  """The last time the Hype Train was updated."""
  updatedAt: Time!
}

"""The Hype Train kickoff configuration."""
type HypeTrainKickoffConfig {
  """What quantity of current commerce events can trigger a Hype Train."""
  eventsThreshold: Int!

  """
  The minimum value of points that the combined events have to equal to kick off a Hype Train.
  """
  minPoints: Int!

  """
  The period of time that is required for these commerce events to occur in to execute a Hype Train.
  """
  periodSeconds: Int!
}

"""HypeTrainKickoffInput specifies settings for kicking off hype trains."""
input HypeTrainKickoffInput {
  """The number of qualifying events needed to kickoff a hype train."""
  eventsThreshold: Int
}

"""
The Hype Train level configuration, which includes information about level completion and associated rewards.
"""
type HypeTrainLevel {
  """The value of participation that will take to complete the level."""
  goal: Int!

  """The level ID."""
  id: ID!

  """The associated rewards for completing the level."""
  rewards: [HypeTrainReward!]!

  """The value of the level, like Level 1, 2, etc. Can be configurable."""
  value: Int!
}

"""The notification threshold for an action / source combination."""
type HypeTrainNotificationThreshold {
  """The action performed."""
  action: HypeTrainParticipationAction!

  """The source of the action."""
  source: HypeTrainParticipationSource!

  """The value that is the theshold for displaying a notification."""
  value: Int!
}

"""
The Hype Train participation structure that contains relevant information about the participation event.
"""
type HypeTrainParticipation {
  """The type of participation."""
  action: HypeTrainParticipationAction!

  """
  The amount that the participation is valued in the Hype Train progress.
  """
  quantity: Int!

  """The participation source."""
  source: HypeTrainParticipationSource!
}

"""The participation action of events in a Hype Train."""
enum HypeTrainParticipationAction {
  """A Cheer event."""
  CHEER

  """A use of bits in extensions."""
  BITS_ON_EXTENSION

  """A poll bits usage."""
  POLLS

  """A tier 1 sub purchase."""
  TIER_1_SUB

  """A tier 2 sub purchase."""
  TIER_2_SUB

  """A tier 3 sub purchase."""
  TIER_3_SUB

  """A tier 1 sub gift."""
  TIER_1_GIFTED_SUB

  """A tier 2 sub gift."""
  TIER_2_GIFTED_SUB

  """A tier 3 sub gift."""
  TIER_3_GIFTED_SUB

  """An unkonwn action."""
  UNKNOWN
}

"""
The participation conversion rate for what an action will count towards the Hype Train.
"""
type HypeTrainParticipationConversionRate {
  """The action performed."""
  action: HypeTrainParticipationAction!

  """The source of the action."""
  source: HypeTrainParticipationSource!

  """
  The rate that it will be converted as in the Hype Train progress calculations.
  """
  value: Int!
}

"""
The Hype Train participation source that denotes the commerce types that can occur.
"""
enum HypeTrainParticipationSource {
  """Bits source, like cheering."""
  BITS

  """Subs source, like subbing to twitch.tv/michael on stream."""
  SUBS

  """An unknown source."""
  UNKNOWN
}

"""
The structure that contains relevant information about the current progress in the Hype Train.
"""
type HypeTrainProgress {
  """The goal value that the Hype Train is trying to complete."""
  goal: Int!

  """The Level that the Hype Train is currently on."""
  level: HypeTrainLevel!

  """The current progression that the channel has made in the level."""
  progression: Int!

  """The number of seconds left until this Hype Train execution ends."""
  remainingSeconds: Int!

  """
  The total progression overall that has occurred in the Hype Train across all levels.
  """
  total: Int!
}

"""
The hype train reward interface, which has to implement an identifier and the hype train reward type.
"""
interface HypeTrainReward {
  """The identifier of the reward."""
  id: ID!

  """The type of reward that is entitled."""
  type: HypeTrainRewardType!
}

"""The enumerated types of rewards that can be entitled."""
enum HypeTrainRewardType {
  """Emote rewards."""
  EMOTE

  """Badge rewards."""
  BADGE

  """An unknown reward type."""
  UNKNOWN
}

type Image {
  """The original height of the image in pixels."""
  height: Int!

  """The URL source of the image."""
  imageURL: String! @deprecated(reason: "Use the 'url' query instead.")

  """The URL source of the image."""
  url(width: Int, height: Int): String!

  """The original width of the image in pixels."""
  width: Int!
}

input ImageOptions {
  """The height of the image in pixels."""
  height: Int

  """The width of the image in pixels."""
  width: Int
}

"""Friend requests sent from other users to this user."""
type IncomingFriendRequestConnection {
  """The friend request elements of this list."""
  edges: [IncomingFriendRequestEdge!]!

  """
  The most recent incoming friend request received by this user, if any exist. This field is provided as a
  convenience, as edges is not strictly time-ordered. The incoming friend request's presence in this field does not
  prevent it from also occurring in edges.
  """
  newestEdge: IncomingFriendRequestEdge

  """Information about this page."""
  pageInfo: PageInfo!

  """The total number of incoming friend requests."""
  totalCount: Int!

  """
  The total number of unseen incoming friend requests. Use the ClearUnreadFriendRequests mutation to set this to 0.
  """
  totalUnreadCount: Int!
}

"""A friend request sent from another user to this user."""
type IncomingFriendRequestEdge {
  """The time at which the friend request was sent."""
  createdAt: Time!

  """
  An opaque cursor identifying the edge's position in the paginated list.
  """
  cursor: Cursor!

  """The user who sent the friend request."""
  node: User
}

"""Determines what other channels can raid this channel."""
enum IncomingRaidsPolicy {
  """This user cannot be radied by anyone."""
  NONE

  """This user can be raided by other people in their network."""
  NETWORK

  """This user can be raided by anyone."""
  ALL
}

"""
IngestFrameDrop represent an event where a video frame is dropped while ingesting a video stream.
"""
type IngestFrameDrop {
  """Duration of events in seconds."""
  durationSeconds: Float!

  """Start time of the event."""
  startedAt: Time!
}

"""IngestSession is a set of stream metadata related to ingest events."""
type IngestSession {
  """Type of live stream."""
  broadcastFormat: BroadcastFormat!

  """
  Staff-only field. Hostname for the session where ingest stream was received.
  """
  ingestHost: String

  """Name of Ingest Server PoP that received the broadcast. Ex) IAD or PDX."""
  ingestProxy: String!

  """
  How many seconds were intentionally delayed in stream as requested by the broadcaster.
  """
  streamDelaySeconds: Int!

  """The time when the stream was ended."""
  streamDownAt: Time

  """The time when the stream was started."""
  streamUpAt: Time
}

"""
IngestStarvationEvent represent an event where an expected video frame from broadcaster does not arrive.
"""
type IngestStarvationEvent {
  """Duration of events in seconds."""
  durationSeconds: Float!

  """Starr time of the event."""
  startedAt: Time!
}

"""
Set of codes to warn the broadcaster about what is wrong with the stream.
"""
type IngestStreamHealth {
  """Reasons why the stream is unstable."""
  reasons: [IngestStreamHealthReason!]

  """Indicate whether the stream is at okay, warning or unstable status."""
  status: IngestStreamHealthStatus!
}

"""Reason of why the stream is unstable."""
enum IngestStreamHealthReason {
  """Reason not set."""
  UNKNOWN

  """Stream is behaving normally."""
  ALL_GOOD

  """Broadcaster's encoder is sending an incompatible audio codec."""
  INCOMP_AUDIO_CODEC

  """Broadcaster's encoder is sending an incompatible video codec."""
  INCOMP_VIDEO_CODEC

  """Broadcaster's encoder is using a deprecated MP3 audio codec."""
  INCOMP_MP3_DEPRECATED

  """The stream is unstable due to high bitrate of the stream."""
  HIGH_BITRATE

  """Some frames are being dropped by the broadcaster's encoder."""
  DROPPED_FRAMES

  """
  Ingest server expects video segments in sequence, but the server did not receive them from the client.
  """
  STARVATION

  """The interval between each key frame is too high."""
  HIGH_KEY_FRAME_INTERVAL
}

"""Health of the stream to inform the broadcaster."""
enum IngestStreamHealthStatus {
  """A misspelling of UNKNOWN."""
  UNKNWON @deprecated(reason: "Use UNKNOWN instead")

  """The stream is ingested okay."""
  OK

  """The stream is at warning level."""
  WARN

  """The stream is unstable."""
  UNSTABLE

  """Health Status not set."""
  UNKNOWN
}

"""
InstallExtensionError is wrapper for error associated with the installExtension mutation.
"""
type InstallExtensionError {
  """Error code."""
  code: InstallExtensionErrorCode!

  """The installation id if got EXTENSION_ALREADY_INSTALLED error."""
  installationID: ID
}

"""
InstallExtensionErrorCode is an error code associated with InstallExtensionError.
"""
enum InstallExtensionErrorCode {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Channel id is invalid, for example, is empty."""
  INVALID_CHANNEL_ID
}

"""The required input for an installExtension mutation."""
input InstallExtensionInput {
  """The channelID the user is installing the extension on."""
  channelID: ID!

  """The composite ID of an extension <extensionID:version>."""
  extensionID: ID!
}

"""The result of an installExtension mutation."""
type InstallExtensionPayload {
  """The error when the mutation fails to install extension."""
  error: InstallExtensionError

  """The resulting extension installation record from the install."""
  installedExtension: ExtensionInstallation
}

"""
A shelf title token type that contains a number with various formatters.
"""
type IntegerToken {
  """The numerical value to display for this token."""
  value: Int!
}

"""InternalChargeModel defines a 1P price identifier for the offer."""
type InternalChargeModel {
  """
  The charge model plan. It will be omitted for consumable purchases (e.g. Bits).
  """
  plan: ChargeModelPlan

  """Preview of the price."""
  previewPrice: PriceInfo

  """The price identifier."""
  priceID: ID!

  """The authenticated user's relationship with the internal charge model."""
  self: InternalChargeModelSelfEdge
}

"""The authenticated user's relationship with the internal charge model."""
type InternalChargeModelSelfEdge {
  """Contains information on the final checkout price of this offer."""
  checkoutPrice(quantity: Int!, paymentProvider: PaymentProvider!): ProductPurchase
}

"""
InterruptScheduleBoundsError represents errors that are due to input being out of bounds.
"""
type InterruptScheduleBoundsError implements InterruptScheduleError {
  """Error code."""
  code: InterruptScheduleErrorCode!

  """
  If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
  """
  maximum: Int

  """
  If the error is related to an input out of service-defined bounds, provide the miniimum allowed value.
  """
  minimum: Int
}

"""
InterruptScheduleError is a wrapper for error associated with the CreateScheduleSegment mutation.
"""
interface InterruptScheduleError {
  """Error code."""
  code: InterruptScheduleErrorCode!
}

"""The possible errors."""
enum InterruptScheduleErrorCode {
  """Not authorized to disable the schedule."""
  FORBIDDEN

  """The schedule was not found."""
  NOT_FOUND

  """EndAt is too far in the future."""
  END_TOO_FAR_IN_FUTURE

  """The argument is invalid and does not map to a known error."""
  INVALID_ARGUMENT
}

"""The input to interrupt a schedule."""
input InterruptScheduleInput {
  """The end time when the schedule will no longer be disabled."""
  endAt: Time!

  """The reason the schedule was disabled."""
  reason: ScheduleInterruptionReason!

  """The id of the schedule."""
  scheduleID: ID!

  """The start time when the schedule will be disabled."""
  startAt: Time!

  """
  The geographic timezone of the new segment defined by IANA; i.e. "America/Los_Angeles".
  """
  timezone: String!
}

"""The payload returned when interrupting a schedule."""
type InterruptSchedulePayload {
  """The possible error."""
  error: InterruptScheduleError

  """The updated stream schedule."""
  schedule: Schedule
}

"""
InterruptScheduleStandardError represents general errors that are not related to bound errors.
"""
type InterruptScheduleStandardError implements InterruptScheduleError {
  """Error code."""
  code: InterruptScheduleErrorCode!
}

"""Arguments for the invalidation of all of a user's sessions."""
input InvalidateAuthenticatedSessionsInput {
  """Session to keep alive."""
  keepSession: String

  """Twitch user owner of the sessions."""
  userID: ID!
}

"""Payload after invalidating sessions."""
type InvalidateAuthenticatedSessionsPayload {
  """Twitch User."""
  user: User
}

"""
InvalidateEmailAssociationPayload is input required to mark a user as not owning an email address.
"""
input InvalidateEmailAssociationInput {
  """Email address that is incorrectly attributed to a user."""
  email: String!

  """
  EmailAssociationOpaqueID is the OpaqueID of the association to the above email.
  """
  emailAssociationOpaqueID: ID!
}

"""InvalidateEmailAssociationPayload is the response payload."""
type InvalidateEmailAssociationPayload {
  """HasSucceeded indicates whether or not the request has succeeded."""
  hasSucceeded: Boolean!
}

"""Contains the inventory for a particular user, which consists of drops."""
type Inventory {
  """
  The campaigns which have drops that the user is eligible for and has banked
  (or is currently earning) minutes-watched progress for.
  """
  dropCampaignsInProgress: [DropCampaign!]

  """
  The drops awarded to this user via Drops 1.0 and triggered by game publishers according to minutes watched data.
  """
  drops: UserDropAwardConnection

  """
  The drops awarded to this user via Drops 2.0 and triggered by broadcaster's game events.
  """
  gameEventDrops: [UserDropReward]
}

"""
IOSPaymentTrackingDataInput contains fields to pass in tracking data related to iOS payments.
"""
input IOSPaymentTrackingDataInput {
  """The user's device ID."""
  deviceID: ID

  """The locale of the user."""
  locale: String
}

"""
IOSReceiptDataInput contains the necessary fields to pass in iOS purchase receipt data.
"""
input IOSReceiptDataInput {
  """
  The encrypted receipt of an iOS purchase, signed by Apple. Required to process any iOS payment.
  """
  signedReceipt: String!

  """The external transaction ID."""
  extTransactionID: ID!
}

"""Associated metrics for the "It Begins" quest."""
type ItBegins {
  """Image URL for the quest's badge."""
  badgeURL: String

  """Time that this quest was completed."""
  completedAt: Time

  """Whether or not the user has streamed before."""
  hasStreamed: Boolean

  """Whether or not the user has updated their category before."""
  hasUpdatedCategory: Boolean

  """Whether or not the user has updated their stream title before."""
  hasUpdatedStreamTitle: Boolean

  """Whether or not the user has visited their stream manager."""
  hasVisitedDashboard: Boolean
}

input JoinChannelRoomsInput {
  channelID: ID!
}

type JoinChannelRoomsPayload {
  channel: User
}

"""Inputs to the joinRaid mutation."""
input JoinRaidInput {
  """The raid ID being joined by the user."""
  raidID: ID!
}

"""Outputs from the joinRaid mutation."""
type JoinRaidPayload {
  """The ID of the raid that was joined by the user."""
  raidID: ID
}

"""The connection of key batches for a given key pool."""
type KeyBatchConnection {
  """The list of key batch edges in the connection."""
  edges: [KeyBatchEdge!]!

  """
  The metadata about having more key batches to fetch, or if there is a previous page of key batches.
  """
  pageInfo: PageInfo!

  """The total number of key batches for the key pool."""
  totalCount: Int!
}

"""The key batch edge which contains our cursor and node."""
type KeyBatchEdge {
  """The cursor of the edge, which is the key batch ID."""
  cursor: Cursor!

  """
  The node of the edge, which contains all information about the key batch.
  """
  node: KeyBatchNode
}

"""The information associated with a given key batch."""
type KeyBatchNode {
  """The key batch ID, which is unique for a given key pool."""
  id: ID!

  """The number of keys in the batch."""
  numKeys: Int!

  """The status of the batch."""
  status: KeyBatchStatus!
}

"""An enumeration of key batch statuses."""
enum KeyBatchStatus {
  """The key batch is active and keys generated from it can be claimed."""
  ACTIVE

  """
  The key batch is inactive and keys generated from it cannot be claimed.
  """
  INACTIVE

  """The key batch is invalid and keys generated from it are invalidated."""
  INVALIDATED
}

"""The connection of key pools to a user."""
type KeyPoolConnection {
  """The list of key pool edges associated with the user."""
  edges: [KeyPoolEdge!]!

  """
  The metadata about having more key pools to fetch, or if there is a previous page of key pools.
  """
  pageInfo: PageInfo!

  """The total number of key pools for the given user."""
  totalCount: Int!
}

"""The key pool edge which contains our cursor and node."""
type KeyPoolEdge {
  """The cursor of the edge, which is also the key pool ID."""
  cursor: Cursor!

  """
  The node of the edge, which contains all information about the key pool.
  """
  node: KeyPoolNode
}

"""The information associated with a given key pool."""
type KeyPoolNode {
  """The key batches that have been generated in the key pool."""
  batches(after: String): KeyBatchConnection

  """The description of the key pool."""
  description: String!

  """The key pool ID, which is unique."""
  id: ID!

  """
  The product type associated with the key pool, which determines what kind of keys are generated.
  """
  productType: String!

  """The SKU associated with the key pool, which is used to redeem content."""
  sku: String!

  """Status of the key pool, which can be active, inactive, or invalidated."""
  status: KeyPoolStatus!
}

"""An enumeration of key pool statuses."""
enum KeyPoolStatus {
  """The key pool is active and can generate more key batches."""
  ACTIVE

  """The key pool is inactive and all batches are invalid."""
  INACTIVE

  """The key pool is invalid and new batches cannot be made."""
  INVALIDATED
}

"""An enumeration of broadcaster languages."""
enum Language {
  """Arabic."""
  AR

  """American Sign Language."""
  ASL

  """Bulgarian."""
  BG

  """Catalan."""
  CA

  """Czech."""
  CS

  """Danish."""
  DA

  """German."""
  DE

  """Greek."""
  EL

  """English."""
  EN

  """Spanish."""
  ES

  """Finnish."""
  FI

  """French."""
  FR

  """Hindi."""
  HI

  """Hungarian."""
  HU

  """Indonesian."""
  ID

  """Italian."""
  IT

  """Japanese."""
  JA

  """Korean."""
  KO

  """Malay."""
  MS

  """Dutch."""
  NL

  """Norwegian."""
  NO

  """Other."""
  OTHER

  """Polish."""
  PL

  """Portuguese."""
  PT

  """Romanian."""
  RO

  """Russian."""
  RU

  """Slovak."""
  SK

  """Swedish."""
  SV

  """Thai."""
  TH

  """Tagalog."""
  TL

  """Turkish."""
  TR

  """Ukrainian."""
  UK

  """Vietnamese."""
  VI

  """Chinese."""
  ZH

  """Chinese (Hong Kong)."""
  ZH_HK
}

"""
An enumeration of user language tags (shortened BCP 47) available on Twitch.
This should not be confused with Language, which is broadcaster language.
"""
enum LanguageTag {
  """Arabic."""
  AR

  """Bulgarian."""
  BG

  """Czech."""
  CS

  """Danish."""
  DA

  """German."""
  DE

  """Greek."""
  EL

  """English."""
  EN

  """English - Great Britain."""
  EN_GB

  """Spanish."""
  ES

  """Spanish - Mexico."""
  ES_MX

  """Finnish."""
  FI

  """French."""
  FR

  """Hindi."""
  HI

  """Hungarian."""
  HU

  """Italian."""
  IT

  """Japanese."""
  JA

  """Korean."""
  KO

  """Dutch."""
  NL

  """Norwegian."""
  NO

  """Polish."""
  PL

  """Portuguese."""
  PT

  """Portuguese - Brazil."""
  PT_BR

  """Romanian."""
  RO

  """Russian."""
  RU

  """Slovak."""
  SK

  """Swedish."""
  SV

  """Thai."""
  TH

  """Turkish."""
  TR

  """Vietnamese."""
  VI

  """Chinese - China."""
  ZH_CN

  """Chinese - Taiwan."""
  ZH_TW

  """Chinese."""
  ZH
}

"""The details of Leaderboard format."""
type LeaderboardDetails {
  """
  The max participant count for a lobby in phase. Valid values are 1-100.
  """
  lobbyMaxSize: Int!

  """
  The number of phases to be created for the competition. Valid values are 1-20.
  """
  phaseCount: Int!

  """
  A display string conveying how a Competition Organizer intends to resolve ties.
  """
  tiebreakerLabel: TiebreakerLabel
}

"""
LeaderboardSet contains the set of leaderboards that are active on a channel.
"""
type LeaderboardSet {
  """
  bits contains the leaderboard of top users by number of bits cheered for the channel.
  """
  bits: UserLeaderboard

  """
  subGift contains the leaderboard of top users by number of sub gifts given in the channel.
  """
  subGift: UserLeaderboard
}

"""
Partner dashboard settings for the bits cheering and sub gifting leaderboards.
"""
type LeaderboardSettings {
  """The default leaderboard the user wants to show."""
  defaultLeaderboard: LeaderboardType!

  """
  Flag that is true if the user has bits cheering leaderboards turned on.
  """
  isCheerEnabled: Boolean!

  """Flag that is true if the user has sub gifting leaderboards turned on."""
  isSubGiftEnabled: Boolean!

  """The time period the user wants the leaderboard to be displayed as."""
  timePeriod: LeaderboardTimePeriodType!
}

"""
LeaderboardTimePeriodType enumerates the various types of supported Leaderboards.
"""
enum LeaderboardTimePeriodType {
  """Daily leaderboards reset at midnight PT."""
  DAY

  """Weekly leaderboards reset at midnight PT between Sunday and Monday."""
  WEEK

  """
  Monthly leaderboards reset at midnight PT on the last day of the month.
  """
  MONTH

  """
  All time leaderboards are cumulative back to when Bits launched in June of 2016.
  """
  ALLTIME
}

"""
LeaderboardType enumerates the various types of supported Leaderboards.
"""
enum LeaderboardType {
  """Bits cheering leaderboards."""
  CHEER

  """Sub gifting leaderboards."""
  SUBGIFT
}

input LeaveChannelRoomsInput {
  channelID: ID!
}

type LeaveChannelRoomsPayload {
  channel: User
}

"""Inputs to the leaveRaid mutation."""
input LeaveRaidInput {
  """The raid ID being left by the user."""
  raidID: ID!
}

"""Outputs from the leaveRaid mutation."""
type LeaveRaidPayload {
  """The ID of the raid that was joined by the user."""
  raidID: ID
}

"""LeaveSquadStreamError is the error associated with a leaveSquadStream."""
type LeaveSquadStreamError {
  """The associated error code."""
  code: LeaveSquadStreamErrorCode!
}

"""
LeaveSquadStreamErrorCode are the possible errors that this mutation returns.
"""
enum LeaveSquadStreamErrorCode {
  """The user is not in the squad specified."""
  USER_NOT_IN_SQUAD

  """The operation is unauthorized."""
  UNAUTHORIZED
}

"""Inputs to the leaveSquadStream mutation."""
input LeaveSquadStreamInput {
  """
  The optional ID of a squad member that is leaving the squad (defaults to ID from auth token).
  """
  memberID: ID!

  """The ID of the squad stream that the caller wants to leave."""
  squadStreamID: ID!
}

"""Outputs from the leaveSquadStream mutation."""
type LeaveSquadStreamPayload {
  """The possible error returned from the service."""
  error: LeaveSquadStreamError

  """The updated squad stream."""
  squadStream: SquadStream
}

"""
LinkOEmbed is a link oEmbed.  This looks strange being empty, but mirrors the oEmbed official spec most exactly.
"""
type LinkOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
}

"""LinkSSOError is an error that occurs when account linking fails."""
type LinkSSOError {
  """The error code that describes why account linking failed."""
  code: LinkSSOErrorCode!
}

"""
LinkSSOErrorCode enumerates the possible errors that can cause account linking to fail.
"""
enum LinkSSOErrorCode {
  """The activation code is incorrect."""
  CODE_INCORRECT

  """The activation code is expired."""
  CODE_EXPIRED

  """
  The user has already linked an SSO app of the same type to their account.
  """
  ALREADY_LINKED
}

"""
LinkSSOInput links an SSO app to the authenticated user's account if the activation code is valid.
"""
input LinkSSOInput {
  """
  The code that identifies the single sign-on (SSO) app that should be linked to the authenticated user's account.
  """
  code: String!
}

"""
LinkSSOPayload returns the newly created link or an error if account linking failed.
"""
type LinkSSOPayload {
  """The error when an app cannot be linked to the user's account."""
  error: LinkSSOError

  """The new SSO link."""
  link: SSOLink
}

"""The location that a piece of text should link to."""
enum LinkType {
  """Do not link to anything."""
  NO_LINK

  """
  Link to the categories directory (on web: https://www.twitch.tv/directory).
  """
  CATEGORIES_DIRECTORY

  """
  Link to the streams directory (on web: https://www.twitch.tv/directory/all).
  """
  STREAMS_DIRECTORY
}

"""
LiveConfigView holds the view configuration of an extension if the live config dashboard page is supported.
"""
type LiveConfigView implements ExtensionView {
  """
  Specifies whether or not the extension has the ability to link to external websites.
  """
  canLinkExternalContent: Boolean!

  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported.
"""
input LiveConfigViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

type LiveRecommendationConnection {
  """The list of recommended streams with metadata to display."""
  edges: [StreamRecommendationEdge!]

  """Per-generation tracking id for identifying a recommendation model."""
  generationID: String!

  """The list of recommended streams to display."""
  nodes: [Stream]! @deprecated(reason: "To be replaced by edges which also includes a required trackingID.")

  """Unique tracking id per response."""
  responseID: String!
}

"""Information about the live up notification of a user."""
type LiveUpNotificationInfo {
  """
  Whether the user's liveUpNotification field is the default value (i.e. "<user> went live!").
  """
  isDefault: Boolean

  """
  The text that will be in the notification that sends when the user starts broadcasting.
  The default value is currently a translated version of "<user> went live!" when the user has not set a custom value.
  """
  liveUpNotification: String
}

"""The lobby state signifies the progress in the competition."""
enum LobbyState {
  """No participants are in lobby."""
  PREP

  """
  Participants have filled the lobby and can be swapped around different lobbies.
  """
  READY

  """
  Participants are currently playing in the lobby, they can be scored but cannot be swapped to different lobbies.
  """
  ACTIVE

  """Participants are all scored and no longer playing."""
  DONE

  """Lobby state is unknown."""
  UNKNOWN
}

"""An error returned from the lockPredictionEvent mutation."""
type LockPredictionEventError {
  """Code describing the error."""
  code: LockPredictionEventErrorCode!
}

"""Possible error codes from the lockPredictionEvent mutation."""
enum LockPredictionEventErrorCode {
  """The current user is forbidden from updating this Prediction Event."""
  FORBIDDEN

  """This Prediction Event is not currently in the ACTIVE state."""
  EVENT_NOT_ACTIVE

  """An unknown error occurred."""
  UNKNOWN
}

"""
Input for moving a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it.
"""
input LockPredictionEventInput {
  """
  The unique identifier of the Prediction Event to move from ACTIVE to LOCKED.
  """
  id: ID!
}

"""Payload from closing a prediciton event to new predictions."""
type LockPredictionEventPayload {
  """If present, there was an error with the request."""
  error: LockPredictionEventError

  """The updated Prediction Event."""
  predictionEvent: PredictionEvent
}

"""Communicates a Loyalty Badge (usually during upload)."""
type LoyaltyBadge {
  """
  Unique identifier the badges method of tenure by channelid and cumulative months.
  """
  channelTenureMethodID: ID!

  """The channel's loyalty badge unique identifier."""
  id: ID!

  """image1xURL to retrieve the 1x sized Badge."""
  image1xURL: String!

  """Image1xURL to retrieve the 2x sized Badge."""
  image2xURL: String!

  """image4xURL to retrieve the 4x sized Badge."""
  image4xURL: String!

  """Identifies the amount of cumulative tenure months to acquire Badge."""
  requiredTenureMonths: Int!

  """
  A localized, human-friendly title for the badge.
  Defaults to English if no translation exists for the requested locale.
  """
  title: String!
}

"""
LoyaltyBadgeUploadConfig is the upload configuration for creating loyalty badges.
"""
type LoyaltyBadgeUploadConfig {
  """The image ID of the badge image."""
  imageID: ID

  """The resulting URL of the badge image."""
  imageURL: String

  """The upload ID of the badge file."""
  uploadID: ID

  """The URL to upload the badge image to."""
  uploadURL: String
}

"""Caller should store all of these fields."""
type LWAToken {
  """Access token to pass in on subsequent requests."""
  accessToken: String!

  """TTL in seconds, default is 3600."""
  expiresIn: Int!

  """Should be stored, though generally shouldn't change."""
  refreshToken: String!
}

"""Input for creating a batch download URL for key codes."""
input MakeKeyBatchDownloadURLInput {
  """The ID of the batch to download."""
  batchID: String!
}

"""The results of creating a key batch download."""
type MakeKeyBatchDownloadURLPayload {
  """The decryption key to decrypt the batch of keys."""
  decryptionKey: String!

  """The URL created for downloading the batch of keys."""
  url: String!
}

"""An error returned from the makePrediction mutation."""
type MakePredictionError {
  """Code describing the error."""
  code: MakePredictionErrorCode!

  """
  If the error code is MAX_POINTS_PER_EVENT, this will specify how many total points the user is allowed to spend.
  """
  maxPointsPerEvent: Int

  """
  If the error code is MAX_POINTS_PER_EVENT, this will specify how many points the user has already spent.
  """
  userPointsSpent: Int
}

"""Possible error codes from the makePrediction mutation."""
enum MakePredictionErrorCode {
  """
  The current user is forbidden from making a Prediction on this Prediction Event.
  """
  FORBIDDEN

  """The provided event ID or outcome ID does not exist."""
  NOT_FOUND

  """This Prediction Event is no longer actively accepting predictions."""
  EVENT_NOT_ACTIVE

  """
  The client is retrying with a transaction id that has already been used.
  """
  DUPLICATE_TRANSACTION

  """
  The client is retrying with a transaction id that is currently being processed in another request.
  """
  TRANSACTION_IN_PROGRESS

  """The user does not have enough points to make this prediction."""
  NOT_ENOUGH_POINTS

  """
  Making this prediction would bring the user's total amount spent on this prediction above the maximum.
  """
  MAX_POINTS_PER_EVENT

  """
  The user has already made a prediction on a different Outcome, so this prediction cannot be made.
  """
  MULTIPLE_OUTCOMES

  """
  The user is restricted from full participation because their geographic
  location has a blanket ban on Prediction participation.
  """
  REGION_LOCKED

  """The user must accept the Predictions Terms of Service."""
  MUST_ACCEPT_TOS

  """
  The user's request was rate limited. They can try again after a few seconds.
  """
  RATE_LIMITED

  """
  The user is restricted from full participation because their geographic
  location has a ban on Predictions for the specific game/category being played.
  """
  CATEGORY_REGION_LOCKED

  """
  The user is restricted from full participation because they have the ability to manage Predictions on this channel.
  """
  EVENT_MANAGER

  """
  The user attempted to make a Prediction in Spectator Mode but is ineligible for that mode.
  """
  SPECTATOR_MODE_INELIGIBLE

  """
  The user attempted to make a Prediction in Spectator Mode but has already made one on this Event.
  """
  SPECTATOR_MODE_DUPLICATE

  """An unknown error occurred."""
  UNKNOWN
}

"""Input for making a Prediction."""
input MakePredictionInput {
  """
  The unique identifier of the Prediction Event to make the prediction on.
  """
  eventID: ID!

  """
  The unique identifier of the Prediction Outcome to make the prediction on.
  """
  outcomeID: ID!

  """The number of points to spend on this Prediction."""
  points: Int!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""Payload for making a prediction."""
type MakePredictionPayload {
  """If present, there was an error with the request."""
  error: MakePredictionError

  """The created or updated Prediction."""
  prediction: Prediction
}

"""A custom challenge created by the broadcaster."""
type ManualChannelChallenge implements ChannelChallenge {
  """Total bits amount contributed."""
  bitsAmount: Int!

  """Time when challenge was created."""
  createdAt: Time!

  """User that created the challenge."""
  createdBy: User

  """Amount of seconds from when the challenge starts to when it ends."""
  durationSeconds: Int!

  """ID of challenge."""
  id: ID!

  """
  User who owns this challenge. The challenge will appear on their channel.
  """
  ownedBy: User

  """
  Amount of milliseconds before the challenge times out.
  0 when the challenge has timed out.
  """
  remainingDurationMilliseconds: Int!

  """
  The authenticated user's relationship with this challenge.
  Main use case is to connect the user to a challenge to allow bit contributions.
  Null if un-authenticated user is making this query.
  """
  self: ChannelChallengeSelfEdge

  """The status of the challenge."""
  status: ChannelChallengeStatus!

  """Title of the challenge."""
  title: String!

  """Time when challenge was updated."""
  updatedAt: Time!
}

"""ManuallyTriggerDrop has fields required to update a campaign summary."""
input ManuallyTriggerDropInput {
  """The id of the campaign that includes the drop to trigger."""
  campaignID: ID!

  """The id of the drop to trigger."""
  dropID: ID!

  """
  This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
  """
  ownerID: ID!
}

"""ManuallyTriggerDropPayload returns the result of the creation/update."""
type ManuallyTriggerDropPayload {
  """A mapped error returned by the drops management service."""
  error: DropsError

  """
  Returns a list of channels the drop was tried to be triggered on and the trigger restult.
  """
  triggerResults: [TriggerResult!]
}

"""The possible return status of a drop trigger try on a channel."""
enum ManuallyTriggerDropResultStatus {
  """Returned if the trigger try was successful."""
  SUCCESS

  """
  Returned if the streamer is not eligible to have the drop triggered on it.
  """
  VERIFICATION_FAILURE

  """Returned if the drop triggered returned an error for given channel."""
  ERROR
}

"""Drop manually triggered."""
type ManualTriggerBasedDrop implements DropType {
  """The rewards for this drop and how often those rewards can be awarded."""
  benefitEdges: [DropBenefitEdge!]

  """The campaign this drop belongs to."""
  campaign: DropCampaign!

  """
  Amount of time the viewer has to claim the drop after the rule is completed.
  """
  claimDurationSeconds: Int!

  """The time this drop becomes unavailable."""
  endAt: Time!

  """A unique identifier."""
  id: ID!

  """The name of this drop."""
  name: String!

  """The time this drop becomes available."""
  startAt: Time!
}

"""Input for readAllCreatorNotifications mutation."""
input MarkAllCreatorNotificationsAsReadInput {
  """The ID of the user performing the reading."""
  userID: ID!
}

"""The result of a readAllCreatorNotifications mutation."""
type MarkAllCreatorNotificationsAsReadPayload {
  """Whether the mutation succeeded."""
  hasSucceeded: Boolean
}

"""Input for readAllViewerNotifications mutation."""
input MarkAllViewerNotificationsAsReadInput {
  """The ID of the user performing the reading."""
  userID: ID!
}

"""The result of a readAllViewerNotifications mutation."""
type MarkAllViewerNotificationsAsReadPayload {
  """Whether the mutation succeeded."""
  hasSucceeded: Boolean
}

"""Revealed Metric types that the client can filter on."""
enum MemberMetricsRevealedParams {
  """Return all members."""
  NONE

  """Return all `StatsRevealed` members."""
  STATS

  """Return all `RevenueRevealed` members."""
  REVENUE

  """Return users with both `StatsRevealed` and `RevenueRevealed`."""
  STATS_AND_REVENUE
}

"""A message from a user."""
type Message {
  """The text and emoticon content of a message."""
  content: MessageContent!

  """
  Time the message was deleted or purged. Null if the message is not deleted.
  """
  deletedAt: Time

  """UUID of the message."""
  id: ID!

  """The message of the parent if this message is a reply."""
  parentMessage: Message

  """Replies to this message."""
  replies: MessageReplyConnection

  """The user that sent the message."""
  sender: User

  """Time the message was sent."""
  sentAt: Time!
}

"""
MessageBody is a way of encoding emote annotated text.  The original text is included as content and the
parsed emotes are included which indicate the start and end indexes they should replace.
"""
type MessageBody {
  """The text content of the body."""
  content: String

  """Collection of rune indexed emotes to be replaced clientside."""
  emotes: [EmbeddedEmote]
}

"""The content of a user's message to a channel's chat."""
type MessageContent {
  """
  Parsed list of fragments in the message, include emotes, mentions, and plaintext.
  """
  fragments: [MessageFragment!]!

  """String representation of the user message."""
  text: String!
}

"""
One parsed part of a message, which may be an emote, mention, or plaintext.
"""
type MessageFragment {
  """
  Contains an emote or a mentioned user depending on the text of the fragment.
  """
  content: FragmentContent

  """Plaintext representation of the fragment."""
  text: String!
}

"""A list of messages."""
type MessageReplyConnection {
  """Nodes is the list of replies to a message."""
  nodes: [Message!]!

  """The total number of replies to a message."""
  totalCount: Int!
}

"""
Milestone is a construct is used within a tournament. For a given threshold, when the user
cheers at or past this amount, they are able to claim a reward for cheering at this level.
Rewards can be fulfilled by different platforms.
Types of milestones:
- **Global milestone**: for a given threshold, this milestone is reached when cheers from all
  users on the channel is greater than or equal to the threshold.
  This unlocks a reward for all users who have cheered.
- **Individual milestone**: for a given threshold, this milestone is reached when an individual
  user's total cheers in the channel is greater than or equal to the threshold.
  This unlocks a reward for the individual user who cheered.
- **Team milestone**: for a given threshold, this milestone is reached when an individual cheers
  for a specific team in total is greater than or equal to the threshold.
  This unlocks a reward for the individual user who cheered.

NOTE: Should have been named CheeringTournamentMilestone.
"""
type Milestone {
  """End date for when a milestone is no longer active."""
  endDate: String! @deprecated

  """GraphQL ID of the milestone."""
  id: ID! @deprecated

  """Whether the milestone is for prime users only."""
  isPrimeOnly: Boolean! @deprecated

  """The type of milestone this is for. e.g INDIVIDUAL or GLOBAL."""
  objectiveTag: String! @deprecated

  """Threshold that needs to be cheered by an individual to claim reward."""
  participationThreshold: Int! @deprecated

  """The subs that this milestone’s completion requires."""
  requiredSubscriptions: [SubscriptionProduct!] @deprecated

  """The rewards associated with milestones."""
  rewards: [TournamentReward!]! @deprecated

  """Start date for when a milestone is active."""
  startDate: String! @deprecated

  """Threshold that needs to be cheered to claim reward."""
  threshold: Int! @deprecated
}

"""MobileAdIdentityInput contains mobile device information."""
input MobileAdIdentityInput {
  """
  deviceInfo is a MobileAdDeviceInfo contains a certain number of attributes required by TIFA.
  """
  deviceInfo: MobileDeviceInfo!

  """lmt is limit ad tracking signal read from mobile device."""
  lmt: Boolean!

  """mAID is the mobile ad identifier."""
  mAID: ID!

  """platform is an enum that describes the device platform."""
  platform: AdPlatform!

  """userAgent is a string sent by mobile clients."""
  userAgent: String!
}

"""MobileDeviceInfo contains attributes required by TIFA."""
input MobileDeviceInfo {
  """Hardware brand name, ex. samsung."""
  make: String!

  """Hardware model, ex: "Galaxy S10"."""
  model: String!

  """Hardware os: ex. "Android"."""
  os: String!

  """Os version number."""
  osVersion: String!
}

"""
MobileView holds the view configuration of an extension if mobile is supported.
"""
type MobileView implements ExtensionView {
  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
MobileViewInput holds the view configuration of an extension if mobile is supported.
"""
input MobileViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""Paginated list of moderators of a channel."""
type ModConnection {
  """The elements of the list."""
  edges: [ModEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""Element in a list of moderators of a channel."""
type ModEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """Timestamp of when the moderator status was granted."""
  grantedAt: Time!

  """Whether the moderator is connected to the channel's chat."""
  isActive: Boolean

  """The user that is a moderator."""
  node: User!
}

"""
ModerationAction represents the recorded actions a channel moderator takes on a channel.
"""
enum ModerationAction {
  """Moderator changes Automod settings levels."""
  AUTOMOD_LEVEL_CHANGE

  """Moderator allows message caught by Automod."""
  ALLOW_MESSAGE

  """Moderator approves unban request."""
  APPROVE_UNBAN_REQUEST

  """Moderator bans a user."""
  BAN_USER

  """Moderator adds terms to Automod blocked list."""
  BLOCKED_TERM_ADD

  """Moderator removes terms to Automod blocked list."""
  BLOCKED_TERM_REMOVE

  """Moderator clears chat."""
  CHAT_CLEAR

  """Moderator creates a mod comment about a user."""
  COMMENT

  """Moderator deletes a chat message."""
  DELETE_MESSAGE

  """Moderator denies message caught by Automod."""
  DENY_MESSAGE

  """Moderator denies unban request."""
  DENY_UNBAN_REQUEST

  """Moderator turns emotes only chat off."""
  EMOTES_ONLY_OFF

  """Moderator turns chat to motes only."""
  EMOTES_ONLY_ON

  """Moderator turns followers only chat off."""
  FOLLOWERS_ONLY_OFF

  """Moderator turns chat to followers only."""
  FOLLOWERS_ONLY_ON

  """Moderator hosts another channel."""
  HOST

  """Default Action."""
  INVALID_ACTION

  """Moderator unmods a user."""
  UNMOD_USER

  """Moderator mods a user."""
  MOD_USER

  """Moderator adds terms to Automod permitted list."""
  PERMITTED_TERM_ADD

  """Moderator removes terms to Automod permitted list."""
  PERMITTED_TERM_REMOVE

  """Moderator raids another channel."""
  RAID

  """Moderator turns slow off in chat."""
  SLOW_OFF

  """Moderator slows chat."""
  SLOW_ON

  """Moderator turns subscribers only chat off."""
  SUBS_ONLY_OFF

  """Moderator turns chat to subscribers only."""
  SUBS_ONLY_ON

  """Moderator timeouts a user."""
  TIMEOUT_USER

  """Moderator unbans a user."""
  UNBAN_USER

  """Moderator unhosts another channel."""
  UNHOST

  """Moderator turns unique only chat off."""
  UNIQUE_OFF

  """Moderator turns unique only chat on."""
  UNIQUE_ON

  """Moderator unraids another channel."""
  UNRAID

  """Moderator untimeouts a user."""
  UNTIMEOUT_USER

  """Moderator makes user not vip."""
  UNVIP_USER

  """Moderator makes user vip."""
  VIP_USER
}

"""
An interface to query subsets of the moderation logs information for a given channel.
"""
type ModerationLogs {
  """The moderation actions that have been take in the given channel."""
  actions(first: Int = 100, after: Cursor, order: SortOrder = DESC): ChannelModerationActionConnection
}

"""
An interface to query subsets of the moderation logs information for a given channel.
"""
type ModLogs {
  """
  The comments left by moderators on a specified user on the given channel.
  """
  comments(targetID: ID!, after: Cursor, first: Int = 100, order: SortOrder = DESC): ModLogsCommentConnection

  """The chat history for an specified user on a given channel."""
  messagesBySender(senderID: ID!, first: Int = 100, after: Cursor, order: SortOrder = DESC, includeMessageCount: Boolean = true, includeTargetedActions: Boolean = true, includeAutoModCaughtMessages: Boolean = false): ModLogsMessageConnection

  """The chat moderation history on a specified user on the given channel."""
  targetedModActions(targetID: ID!, actionType: ModLogsAction!): ModLogsTargetedModActionsConnection
}

"""
ModLogsAccess defines the access level of a channel role to the channel's moderator logs.
"""
type ModLogsAccess {
  """The access level to moderator logs."""
  accessLevel: ModLogsAccessLevel!

  """The user role."""
  channelRole: ChannelUserRole!
}

"""Access levels to moderator logs."""
enum ModLogsAccessLevel {
  """User cannot read moderator logs or create new entries."""
  NONE

  """User can read moderator log entries."""
  READ

  """User can read and create moderator log entries."""
  WRITE
}

"""
ModLogsAction represents the recorded actions a channel moderator takes on a channel.
"""
enum ModLogsAction {
  """Default Action."""
  INVALID_ACTION

  """Channel Mod chat bans a user."""
  BAN_USER

  """Channel Mod chat timeouts a user."""
  TIMEOUT_USER

  """Channel Mod chat unbans a user."""
  UNBAN_USER

  """Channel Mod sets chat mode."""
  SET_CHANNEL_MODE

  """Channel Mod changes."""
  CHANGE_CHANNEL_RULES

  """Channel Mod approves an automod caught message."""
  ALLOW_MESSAGE

  """Channel Mod denies an automod caught message."""
  DENY_MESSAGE

  """Channel Mod updates mod terms."""
  UPDATE_MODERATED_TERMS

  """Channel Mod creates a mod comment about a user."""
  COMMENT

  """Channel Mod chat untimeouts a user."""
  UNTIMEOUT_USER
}

"""
ModLogsCommentsEntry defines an entry of a user's moderation history on a channel.
"""
type ModLogsComment {
  """Author is the moderator that created the comment."""
  author: User

  """Channel is where the moderator comment was created."""
  channel: User

  """Details about the moderator comment."""
  details: ModLogsCommentDetails

  """UUID of the moderator comment."""
  id: ID!

  """Target is the target user of the moderator comment."""
  target: User

  """Timestamp when comment was created."""
  timestamp: Time!
}

"""Paginated list of moderator comments on a user in a channel."""
type ModLogsCommentConnection {
  """The elements of the list."""
  edges: [ModLogsCommentEdge!]

  """Information about this page of mod logs."""
  pageInfo: PageInfo!
}

"""ModLogsCommentDetails contains the details of a moderator comment."""
type ModLogsCommentDetails {
  """Body of the comment."""
  text: String
}

"""Element in a list of moderator comments on a user in a channel."""
type ModLogsCommentEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A moderator comment on a user in a channel."""
  node: ModLogsComment
}

"""A message sent from a user to a room."""
type ModLogsMessage {
  """The text and emoticon content of a message."""
  content: ModLogsMessageContent!

  """UUID of the message."""
  id: ID!

  """The user that sent the message."""
  sender: User

  """Time the message was sent."""
  sentAt: Time!
}

"""Paginated list of messages from a single sender in a channel."""
type ModLogsMessageConnection {
  """The elements of the list."""
  edges: [ModLogsMessageEdge!]!

  """
  The partial count of messages (up to 1000).
  Empty if includeMessageCount was not set when the query was requested.
  """
  messageCount: Int

  """Information about this page."""
  pageInfo: PageInfo!
}

"""The content of a user's message to a room."""
type ModLogsMessageContent {
  """
  Parsed list of fragments in the message, include emotes, mentions, and plaintext.
  """
  fragments: [ModLogsMessageFragment!]!

  """String representation of the user message."""
  text: String!
}

"""Element in a list of messages."""
type ModLogsMessageEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The message or targeted moderation action."""
  node: ModLogsMessageResult
}

"""
One parsed part of a message, which may be an emote, mention, or plaintext.
"""
type ModLogsMessageFragment {
  """
  Contains an emote or a mentioned user depending on the text of the fragment.
  """
  content: FragmentContent

  """Plaintext representation of the fragment."""
  text: String!
}

"""
ModLogsMessageResult defines the types of entries that appear as mod log
messages: Mod Logs (Chat) Messages and Targeted Mod Actions.
"""
union ModLogsMessageResult = AutoModCaughtMessage | ModLogsMessage | ModLogsTargetedModActionsEntry

"""Paginated list of mod logs of a user on a channel."""
type ModLogsTargetedModActionsConnection {
  """
  The partial count of targeted mod actions (bans or timeouts), up to 100.
  Does not count undo actions (unbans or untimeouts).
  """
  actionCount: Int!

  """The elements of the list."""
  edges: [ModLogsTargetedModActionsEdge!]

  """Information about this page of mod logs."""
  pageInfo: PageInfo!
}

"""Element in a list of mod logs of a user on a channel."""
type ModLogsTargetedModActionsEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """A mod log of the user."""
  node: ModLogsTargetedModActionsEntry
}

"""
ModLogsTargetedModActionsEntry defines an entry of a user's moderation history on a channel.
"""
type ModLogsTargetedModActionsEntry {
  """Action is the mod action of the entry."""
  action: ModLogsAction!

  """Channel is where the mod action was taken."""
  channel: User

  """Details about the mod action."""
  details: TargetedModActionDetails

  """The UUID of the entry."""
  id: ID!

  """Target is the target user of the mod action."""
  target: User

  """Timestamp when entry was created."""
  timestamp: Time!

  """User is the mod that created the action."""
  user: User
}

"""ModUserError contains details about a client error that occurred."""
type ModUserError {
  """The enum indicating what error has occurred."""
  code: ModUserErrorCode!
}

"""
ModUserErrorCode defines a client error that occurred while adding a moderator.
"""
enum ModUserErrorCode {
  """
  The requesting user does not have permission to add a moderator in this channel.
  """
  FORBIDDEN

  """The target user does not exist or has a suspended account."""
  TARGET_NOT_FOUND

  """The channel does not exist."""
  CHANNEL_NOT_FOUND

  """The target user is banned or timed out in this channel."""
  TARGET_IS_CHAT_BANNED

  """The target user is already a moderator."""
  TARGET_ALREADY_MOD
}

"""
ModUserInput contains the parameters to add a user as a moderator to a channel.
"""
input ModUserInput {
  """The channel that the user will be added as a moderator to."""
  channelID: ID!

  """
  The ID of the user that will be added as a moderator.
  Either targetID or targetLogin must be provided.
  """
  targetID: ID

  """
  The login of the user that will be added as a moderator.
  Either targetID or targetLogin must be provided.
  """
  targetLogin: String
}

"""ModUserPayload is the response when adding a user as a moderator."""
type ModUserPayload {
  """The channel that the user is added as a moderator to."""
  channel: User

  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: ModUserError

  """The user that is added as a moderator."""
  target: User
}

"""
ModViewNewsfeedEntry is an entry that displays content for the Mod View page's "What's New" feed.
"""
type ModViewNewsfeedEntry {
  """content is localized text content for the changelog entry."""
  content: String!

  """iconURL is the url for the entry's icon image."""
  iconURL: String

  """id is a unique human readable slug for the entry e.g. "squad-stream"."""
  id: ID!

  """linkText is the text that the linkURL should display."""
  linkText: String

  """linkURL is an optional link for more content for this changelog entry."""
  linkURL: String

  """
  position is where entry should be located within changelog entries of the same date.
  """
  position: Int!

  """publishedAt is the timestamp that the changelog entry was published."""
  publishedAt: Time

  """title is the localized title of the changelog entry."""
  title: String!
}

"""Settings for Mod View Page."""
type ModViewSettings {
  """
  Date that tuorial was SEEN (nullable when tutorial is dismissed or unseen).
  """
  tutorialSeenAt: Time

  """Setting to store whether the user has completed the mod view tutorial."""
  tutorialState: TutorialState
}

"""
Data containing a layout definition for the
Mosaic algorithm. Should only be parsed or modified by Mosaic.
"""
scalar MosaicData

"""Movie metadata."""
type MovieDetails {
  """Total length of the content."""
  durationSeconds: Int
}

"""A multiplayer ad offer is an ad offer."""
type MultiplayerAdOffer {
  """The duration of the ad in seconds."""
  adDurationSeconds: Int!

  """The name of the brand associated with the ad."""
  brandName: String

  """The message to be display to the broadcaster."""
  broadcasterMessage: String

  """
  How much preroll free time will be credited to the creator for running this ad offer.
  """
  creditDurationSeconds: Int

  """When the offer expires."""
  expiresAt: Time!

  """The offer's unique identifier."""
  id: ID!

  """
  If offer has reward, the max rate for reward. (e.g. vote per bits for polling).
  """
  rewardsMaxRate: Float

  """
  If offer has reward, the min rate for reward. (e.g. vote per bits for polling).
  """
  rewardsMinRate: Float
}

"""
Multi-view content attribute(s) are used to augment the multi-view experience.
they are used for filterings and groupings of chanlets to help viewers find content that they are interested in.
"""
type MultiviewContentAttribute {
  """childIDs is an optional list of child content attribute ids."""
  childIDs: [ID!]

  """Time when this content attribute is created."""
  createdAt: Time

  """id is a unique identifier generated on the server side."""
  id: ID!

  """URL to the image (icon) of the content attribute."""
  imageURL: String

  """key is a grouping identifier for content attributes of the same type."""
  key: String!

  """name is a human-readable string of the content attribute type."""
  name: String!

  """
  ownerChannel is the channel that this content attribute is created under.
  """
  ownerChannel: Channel

  """parentID is an optional pointer to specify the parent attribute."""
  parentID: ID

  """
  parentKey is an optional pointer to specifiy the key of the parent attribute.
  """
  parentKey: String

  """Time when this content attribute is last modified."""
  updatedAt: Time

  """value is the human-readble value of the attribute value."""
  value: String!

  """valueShortName is an optional abbreviation of value."""
  valueShortName: String
}

"""Contains all information to create a new content attribute."""
input MultiviewContentAttributeParams {
  """Optional list of child content attribute ids."""
  childIDs: [ID!]

  """Unique identifier."""
  id: ID

  """Optional an URL to the icon of this content attribute."""
  imageURL: String

  """Indicates the type of the attribute."""
  key: String!

  """Human-readable name of the attribute."""
  name: String!

  """The channel that the content attribute is created under."""
  ownerChannelID: ID

  """Optional pointer to a parent content attribute instance."""
  parentID: ID

  """Optional pointer to a parent content attribute key."""
  parentKey: String

  """value of the attribute."""
  value: String!

  """Optional abbreviation of value."""
  valueShortName: String
}

"""Operations to update data in the Twitch API."""
type Mutation {
  """
  acceptFriendRequest accepts a friend request from the target user to the
  authenticated user, creating a new Friend relationship.
  """
  acceptFriendRequest(input: AcceptFriendRequestInput!): AcceptFriendRequestPayload

  """
  AcceptOrganizationInvite accepts an invite to an organization and the user is added as member to that organization.
  """
  acceptOrganizationInvite(input: AcceptOrganizationInviteInput!): AcceptOrganizationInvitePayload

  """Accept program agreement during payout onboarding."""
  acceptProgramAgreement(input: AcceptProgramAgreementInput!): AcceptProgramAgreementPayload

  """
  acceptSquadStreamInvitation allows a user that has recieved a squad stream invitation to accept and join
  the squad stream.
  """
  acceptSquadStreamInvitation(input: AcceptSquadStreamInvitationInput!): AcceptSquadStreamInvitationPayload

  """
  Acknowledge the result of a Prediction. Only the user who made the Prediction can acknowledge the result.
  This should be triggered automatically when the result of a Prediction is displayed on screen, either from a
  User Notice or by viewing the Channel Points panel. Because this has the potential to trigger a thundering herd, as
  every participant in a Prediction Event will see the results at the same time, clients should automatically jitter
  this call by waiting a random duration between 0-60 seconds before making this mutation.
  """
  acknowledgePredictionResult(input: AcknowledgePredictionResultInput!): AcknowledgePredictionResultPayload

  """
  acknowledgeSubscriptionState allow to apply Acknowledged status to the provided subscription.
  """
  acknowledgeSubscriptionState(input: AcknowledgeSubscriptionStateInput!): AcknowledgeSubscriptionStatePayload

  """
  acknowledgeUnbanRequest allows a user to acknowledge their unban request has been approved, and can now
  rejoin a channel's chat after being unbanned.
  """
  acknowledgeUnbanRequest(input: AcknowledgeUnbanRequestInput!): AcknowledgeUnbanRequestPayload

  """Activate an extension which has been installed on a channel."""
  activateExtension(input: ActivateExtensionInput!): ActivateExtensionPayload @deprecated(reason: "Should use applyExtensionActivations instead")

  """Adds to a user's list of channelIDs to autohost."""
  addAutohostChannels(input: AddAutohostChannelsInput!): AddAutohostChannelsPayload

  """
  addBrowserPushSubscription adds a browser push subscription for receiving browser (desktop) push notifications.
  The client must retrieve the input fields from the browser's push notification API. Client's will
  call this when the user opts-in. A browser push subscription is tied to a user's browser (device).
  Twitch will use these push subscriptions to send browser push notifications.
  
  Spec: https://www.w3.org/TR/push-api/#push-subscription.
  """
  addBrowserPushSubscription(input: AddBrowserPushSubscriptionInput!): AddBrowserPushSubscriptionPayload

  """Adds a blocked term to a channel."""
  addChannelBlockedTerm(input: AddChannelBlockedTermInput!): AddChannelBlockedTermPayload

  """Adds a permitted term to a channel."""
  addChannelPermittedTerm(input: AddChannelPermittedTermInput!): AddChannelPermittedTermPayload

  """addCollectionItem adds an item to a collection."""
  addCollectionItem(input: AddCollectionItemInput!): AddCollectionItemPayload

  """Add CompetitionPhase to a competition."""
  addCompetitionPhase(input: AddCompetitionPhaseInput!): AddCompetitionPhasePayload

  """Add CompetitionPlayer to a competition."""
  addCompetitionPlayer(input: AddCompetitionPlayerInput!): AddCompetitionPlayerPayload

  """Add CompetitionTeam to a competition."""
  addCompetitionTeam(input: AddCompetitionTeamInput!): AddCompetitionTeamPayload

  """
  addDeviceToken associates a new push notification token to the given user.
  """
  addDeviceToken(input: AddDeviceTokenInput!): AddDeviceTokenPayload

  """
  addDropToCampaign allows an organization to add a new drop record to an existing campaign.
  """
  addDropToCampaign(input: AddDropToCampaignInput!): AddDropToCampaignPayload

  """Grant a user the editor status for a given channel."""
  addEditor(input: AddEditorInput!): AddEditorPayload

  """Register a radio content play start."""
  addRadioRecentlyPlayed(input: AddRadioRecentlyPlayedInput!): AddRadioRecentlyPlayedPayload

  """
  addReaction allows a user to create a reaction for any reactable item in a feed.
  """
  addReaction(input: AddReactionInput!): AddReactionPayload @deprecated

  """
  addRecommendationFeedback allows a user to add feedback about a recommendation they've received.
  """
  addRecommendationFeedback(input: AddRecommendationFeedbackInput!): AddRecommendationFeedbackPayload

  """Adds a user to stream on behalf of broadcaster."""
  addStreamAuthorizedUser(input: AddStreamAuthorizedUserInput!): AddStreamAuthorizedUserPayload

  """
  Allocates product keys that a broadcaster may need to complete the bounty.
  """
  allocateKeysForBounty(input: AllocateKeysForBountyInput!): AllocateKeysForBountyPayload

  """Allows a message rejected on a channel chat."""
  allowRejectedChatMessage(input: AllowRejectedChatMessageInput!): AllowRejectedChatMessagePayload

  """Allows a cheer rejected on a channel chat."""
  allowRejectedCheer(input: AllowRejectedCheerInput!): AllowRejectedCheerPayload @deprecated(reason: "logic handled by allowRejectedChatMessage")

  """
  Apply activation state to a subset of installed extensions. In order to deactivate an installed extension,
  simply pass a null value in the anchor.
  """
  applyExtensionActivations(input: ApplyExtensionActivationsInput!): ApplyExtensionActivationsPayload

  """Approve a request to be unbanned from a channel-banned user."""
  approveUnbanRequest(input: ApproveUnbanRequestInput!): ApproveUnbanRequestPayload

  """Archives a chanlet to remove the chanlet from the parent channel."""
  archiveChanlet(input: ArchiveChanletInput!): ArchiveChanletPayload

  """
  archiveCommunityPointsCommunityGoal archives a Community Points Community Goal.
  """
  archiveCommunityPointsCommunityGoal(input: ArchiveCommunityPointsCommunityGoalInput!): ArchiveCommunityPointsCommunityGoalPayload

  """Archive a poll with the given poll id."""
  archivePoll(input: ArchivePollInput!): ArchivePollPayload

  """Archive the current poll in a channel."""
  archivePollInChannel(input: ArchivePollInChannelInput!): ArchivePollInChannelPayload

  """Assign an emote to a bits tier."""
  assignEmoteToBitsTier(input: AssignEmoteToBitsTierInput!): AssignEmoteToBitsTierPayload

  """Assign an emote to a subscription product."""
  assignEmoteToSubscriptionProduct(input: AssignEmoteToSubscriptionProductInput!): AssignEmoteToSubscriptionProductPayload

  """
  Assign a billing manager to an extension.
  The billing manager is the organization's Owner or member with Billing_Manager role that is ready to receive
  payments for the monetized extension within an organization.
  """
  assignExtensionBillingManager(input: AssignExtensionBillingManagerInput!): AssignExtensionBillingManagerPayload

  """
  Bans a user from chat room permanently or for an specified period of time.
  """
  banUserFromChatRoom(input: BanUserFromChatRoomInput!): BanUserFromChatRoomPayload

  """banVideoCommenter bans a user from commenting on a video."""
  banVideoCommenter(input: BanVideoCommenterInput!): BanVideoCommenterPayload

  """beginUseBitsInExtension starts a bits transaction in an extension."""
  beginUseBitsInExtension(input: BeginUseBitsInExtensionInput!): BeginUseBitsInExtensionPayload

  """Blocks target user from communicating with the current user."""
  blockUser(input: BlockUserInput!): BlockUserPayload

  """Approve a list of unban requests on a channel."""
  bulkApproveUnbanRequest(input: BulkApproveUnbanRequestInput!): BulkApproveUnbanRequestPayload

  """Deny a list of unban requests on a channel."""
  bulkDenyUnbanRequest(input: BulkDenyUnbanRequestInput!): BulkDenyUnbanRequestPayload

  """Cancel all active boosts on a channel."""
  cancelActiveBoostOrders(input: CancelActiveBoostOrdersInput!): CancelActiveBoostOrdersPayload

  """
  cancelBounty allows a user to cancel a claimed bounty.
  If the user has not met the requirements to cancel the bounty, an error will be returned.
  """
  cancelBounty(input: CancelBountyInput!): CancelBountyPayload

  """
  cancelFriendRequest destroys a friend request relationship from the authenticated user to the target user.
  """
  cancelFriendRequest(input: CancelFriendRequestInput!): CancelFriendRequestPayload

  """Cancel a current payout onboarding workflow."""
  cancelPayoutOnboardingWorkflow(input: CancelPayoutOnboardingWorkflowInput!): CancelPayoutOnboardingWorkflowPayload

  """Cancel a Prediction Event."""
  cancelPredictionEvent(input: CancelPredictionEventInput!): CancelPredictionEventPayload

  """Cancel a raid."""
  cancelRaid(input: CancelRaidInput!): CancelRaidPayload

  """
  cancelSubscriptionGift allows the current user to cancel their gifted subscription to a channel.
  """
  cancelSubscriptionGift(input: CancelSubscriptionGiftInput!): CancelSubscriptionGiftPayload

  """
  cancelUnbanRequest allows the user to cancel their provided unban request.
  """
  cancelUnbanRequest(input: CancelUnbanRequestInput!): CancelUnbanRequestPayload

  """changeUsername allows a user to update their username(login)."""
  changeUsername(input: ChangeUsernameInput!): ChangeUsernamePayload

  """
  claimBounty allows a user to claim a bounty from a campaign (e.g. Stream a Game Campaign).
  If the user has not met the requirements to claim it, an error will be returned.
  """
  claimBounty(input: ClaimBountyInput!): ClaimBountyPayload

  """
  claimCommunityPoints allows a user to claim community points that they have available in a channel.
  If the user does not have a claim available, an error will be returned.
  """
  claimCommunityPoints(input: ClaimCommunityPointsInput!): ClaimCommunityPointsPayload

  """
  claimDropRewards allows a user to attempt to claim their rewards from a Drops 2.0 drop.
  """
  claimDropRewards(input: ClaimDropRewardsInput!): ClaimDropRewardsPayload

  """
  claimPrimeOffer allows a user to create their entitlement to the given offer/content.
  """
  claimPrimeOffer(input: ClaimPrimeOfferInput!): ClaimPrimeOfferPayload

  """
  clearUnreadFriendRequests marks all friend requests for the authenticated user as read.
  """
  clearUnreadFriendRequests: ClearUnreadFriendRequestsPayload

  """
  cloneExtensionDiscoveryData copies the discovery data of an extension from one version to another.
  """
  cloneExtensionDiscoveryData(input: CloneExtensionDiscoveryDataInput!): CloneExtensionDiscoveryDataPayload

  """
  cloneExtensionManifest creates a new version of an extension that is a clone of a previous version.
  """
  cloneExtensionManifest(input: CloneExtensionManifestInput!): CloneExtensionManifestPayload

  """
  connectAdIdentity creates an Amazon ad identity for the authenticated user.
  """
  connectAdIdentity(input: ConnectAdIdentityInput!): ConnectAdIdentityPayload

  """
  contributeCommunityPointsCommunityGoal contributes Community Points towards a Community Goal.
  """
  contributeCommunityPointsCommunityGoal(input: ContributeCommunityPointsCommunityGoalInput!): ContributeCommunityPointsCommunityGoalPayload

  """
  contributeToChallenge allows the user to contribute Bits towards a Challenge.
  """
  contributeToChallenge(input: ContributeToChallengeInput!): ContributeToChallengePayload

  """
  createArchivedEmote creates an archived emote object, which is not associated
  with any products, and associates that emote with a set of image assets.
  """
  createArchivedEmote(input: CreateArchivedEmoteInput!): CreateArchivedEmotePayload

  """
  createBadgeFlair creates a custom badge flair asset for a creator's channel and specified tier.
  """
  createBadgeFlair(input: CreateBadgeFlairInput!): CreateBadgeFlairPayload

  """
  createBitsChallengeConditionForExtension creates a Bits condition on behalf of a user by an extension.
  """
  createBitsChallengeConditionForExtension(input: CreateBitsChallengeConditionForExtensionInput!): CreateBitsChallengeConditionForExtensionPayload

  """
  createBitsChallengeConditionParticipantForExtension creates a Bits condition
  participant on behalf of a user by an extension.
  """
  createBitsChallengeConditionParticipantForExtension(input: CreateBitsChallengeConditionParticipantForExtensionInput!): CreateBitsChallengeConditionParticipantForExtensionPayload

  """createBountyCampaign creates a campaign for Bounty Board."""
  createBountyCampaign(input: CreateBountyCampaignInput!): CreateBountyCampaignPayload

  """
  createBountyCampaignUploadConfig creates a upload configuration for assets for bounty campaigns.
  """
  createBountyCampaignUploadConfig(input: CreateBountyCampaignUploadConfigInput!): CreateBountyCampaignUploadConfigPayload

  """createCelebration creates a new celebration for a channel."""
  createCelebration(input: CreateCelebrationInput!): CreateCelebrationPayload

  """createChanlet creates a new chanlet for a Channel."""
  createChanlet(input: CreateChanletInput!): CreateChanletPayload

  """
  createClip creates a new clip with the authenticated user as the curator.
  """
  createClip(input: CreateClipInput!): CreateClipPayload

  """createCollection creates a collection with a provided collection name."""
  createCollection(input: CreateCollectionInput!): CreateCollectionPayload

  """
  createCommunityPointsCommunityGoal creates a Community Points Community Goal.
  """
  createCommunityPointsCommunityGoal(input: CreateCommunityPointsCommunityGoalInput!): CreateCommunityPointsCommunityGoalPayload

  """Create a custom Community Points reward in a channel."""
  createCommunityPointsCustomReward(input: CreateCommunityPointsCustomRewardInput!): CreateCommunityPointsCustomRewardPayload

  """
  Generate image upload information (URL and upload ID) for uploading a Community Points image.
  Can upoload a new Community Points icon, an automatic reward icon, or a custom reward icon.
  """
  createCommunityPointsImageUploadInfo(input: CreateCommunityPointsImageUploadInfoInput!): CreateCommunityPointsImageUploadInfoPayload

  """Create a Competition."""
  createCompetition(input: CreateCompetitionInput!): CreateCompetitionPayload

  """
  createContentTags creates the tags specified and associates it with the piece of content specified.
  """
  createContentTags(input: CreateContentTagsInput!): CreateContentTagsPayload

  """
  createDropBenefit creates a benefit that can be used within a drop campaign.
  """
  createDropBenefit(input: CreateDropBenefitInput!): CreateDropBenefitPayload

  """createDropCampaign creates a Drop Campaign owned by an organization."""
  createDropCampaign(input: CreateDropCampaignInput!): CreateDropCampaignPayload

  """
  createDropImageUploadURL creates and returns a url to use on the client side to upload drops images.
  """
  createDropImageUploadURL(input: CreateDropImageUploadURLInput!): CreateDropImageUploadURLPayload @deprecated(reason: "use dropImageUpload")

  """createExtensionClient creates an extension with a provided name."""
  createExtensionClient(input: CreateExtensionClientInput!): CreateExtensionClientPayload

  """
  createExtensionImageUploadInfo creates and returns a url and uploadId to use
  on the client side to upload extension logo, taskbar, discovery and screenshot images.
  """
  createExtensionImageUploadInfo(input: CreateExtensionImageUploadInfoInput!): CreateExtensionImageUploadInfoPayload

  """
  createExtensionZipUploadInfo creates and returns a url and uploadId to use on the client side to upload zip files.
  """
  createExtensionZipUploadInfo(input: CreateExtensionZipUploadInfoInput!): CreateExtensionZipUploadInfoPayload

  """
  createFriendRequest creates a friend request relationship between the authenticated user and the target user.
  """
  createFriendRequest(input: CreateFriendRequestInput!): CreateFriendRequestPayload

  """
  createGameApplication creates an application request to add game to a certain organization.
  """
  createGameApplication(input: CreateGameApplicationInput!): CreateGameApplicationPayload

  """
  createGameBoxArtUploadURL returns a URL that can be used to upload the game
  box art asset, for developers with access to the game box art image.
  """
  createGameBoxArtUploadURL(input: CreateGameBoxArtUploadURLInput!): CreateGameBoxArtUploadURLPayload

  """CreateLoyaltyBadge creates a new badge with these settings."""
  createLoyaltyBadge(input: CreateLoyaltyBadgeInput!): CreateLoyaltyBadgePayload

  """
  createLoyaltyBadgeUploadConfig creates a config with URL to upload the badge image to.
  """
  createLoyaltyBadgeUploadConfig(input: CreateLoyaltyBadgeUploadConfigInput!): CreateLoyaltyBadgeUploadConfigPayload

  """
  createModeratorComment creates and returns a comment on the target user in the given channel.
  Requester must be a moderator or higher in the channel.
  """
  createModeratorComment(input: CreateModeratorCommentInput!): CreateModeratorCommentPayload

  """
  Creates a new custom Mosaic layout with the specified properties for the current user.
  """
  createDashboardViewMosaicLayout(input: CreateDashboardViewMosaicLayoutInput!): CreateDashboardViewMosaicLayoutPayload

  """
  createMultiVideoHighlight creates a video of type Highlight with multi-segment support from an Archive type video.
  """
  createMultiVideoHighlight(input: CreateMultiVideoHighlightInput!): CreateMultiVideoHighlightPayload

  """
  createMultiviewContentAttributeImageUploadConfig creates and returns a upload
  configuration for uploading and retrieving content attribute images.
  """
  createMultiviewContentAttributeImageUploadConfig(input: CreateMultiviewContentAttributeImageUploadConfigInput!): CreateMultiviewContentAttributeImageUploadConfigPayload

  """
  createMultiviewContentAttributes creates new content attributes with server assigned IDs.
  """
  createMultiviewContentAttributes(input: CreateMultiviewContentAttributesInput!): CreateMultiviewContentAttributesPayload

  """
  CreateOrganizationApplicaton creates a new Twitch Developer Organization
  application with the authenticated user as the submitter.
  """
  createOrganizationApplication(input: CreateOrganizationApplicationInput!): CreateOrganizationApplicationPayload

  """
  CreateOrganizationInvite creates a new invitation to join an existing Twitch Developer Organization.
  """
  createOrganizationInvite(input: CreateOrganizationInviteInput!): CreateOrganizationInvitePayload

  """Creates JWT to be used in subsequent drops calls."""
  createOrganizationJWT(input: CreateOrganizationJWTInput!): CreateOrganizationJWTPayload

  """Adds a user to a developer organization."""
  createOrganizationMember(input: CreateOrganizationMemberInput!): CreateOrganizationMemberPayload

  """createPanel removes a panel."""
  createPanel(input: CreatePanelInput!): CreatePanelPayload

  """Creates the url that a panel image gets uploaded to."""
  createPanelImageUploadInfo(input: CreatePanelImageUploadInfoInput!): CreatePanelImageUploadInfoPayload

  """
  createPartnershipApplication allows a user to create partnership application.
  """
  createPartnershipApplication(input: CreatePartnershipApplicationInput!): CreatePartnershipApplicationPayload

  """createPoll creates a poll."""
  createPoll(input: CreatePollInput!): CreatePollPayload

  """createPost creates a new post."""
  createPost(input: CreatePostInput!): CreatePostPayload @deprecated

  """Create a new Prediction Event."""
  createPredictionEvent(input: CreatePredictionEventInput!): CreatePredictionEventPayload

  """Create a raid."""
  createRaid(input: CreateRaidInput!): CreateRaidPayload

  """
  createRewardedVideoToken creates a token used to initialize the truex client application.
  """
  createRewardedVideoToken(input: CreateRewardedVideoTokenInput!): CreateRewardedVideoTokenPayload

  """Creates a new chatroom."""
  createRoom(input: CreateRoomInput!): CreateRoomPayload @deprecated

  """Create a new schedule."""
  createSchedule(input: CreateScheduleInput!): CreateSchedulePayload

  """Create a new schedule segment."""
  createScheduleSegment(input: CreateScheduleSegmentInput!): CreateScheduleSegmentPayload

  """createSocialMedia creates new social media items for a Channel."""
  createSocialMedia(input: CreateSocialMediaInput!): CreateSocialMediaPayload

  """Creates an invitation to a new or existing squad stream."""
  createSquadStreamInvitation(input: CreateSquadStreamInvitationInput!): CreateSquadStreamInvitationPayload

  """createStucco allows a user to create a stucco."""
  createStucco(input: CreateStuccoInput!): CreateStuccoPayload

  """
  createStuccoPack allows the creation a new stucco pack for the channel.
  """
  createStuccoPack(input: CreateStuccoPackInput!): CreateStuccoPackPayload

  """
  createUnbanRequest allows a channel-banned user to submit a request to channel moderators to be unbanned.
  """
  createUnbanRequest(input: CreateUnbanRequestInput!): CreateUnbanRequestPayload

  """
  createVideoAppeal creates an appeal for the tracks that have been flagged for copyrighted music in the video.
  """
  createVideoAppeal(input: CreateVideoAppealInput!): CreateVideoAppealPayload

  """createVideoBookmark creates a video bookmark."""
  createVideoBookmark(input: CreateVideoBookmarkInput!): CreateVideoBookmarkPayload

  """createVideoComment creates a video comment."""
  createVideoComment(input: CreateVideoCommentInput!): CreateVideoCommentPayload

  """
  createVideoHighlight creates a video of type Highlight from an Archive type video.
  """
  createVideoHighlight(input: CreateVideoHighlightInput!): CreateVideoHighlightPayload

  """
  createVideoThumbnailUploadRequest creates a thumbnail upload request url.
  """
  createVideoThumbnailUploadRequest(input: CreateVideoThumbnailUploadRequestInput!): CreateVideoThumbnailUploadRequestPayload

  """Deactivate an extension which has been installed on a channel."""
  deactivateExtension(input: DeactivateExtensionInput!): DeactivateExtensionPayload @deprecated(reason: "Should use applyExtensionActivations instead")

  """
  DeclineOrganizationInvite declines an invite to an organization and the invitation is deleted.
  """
  declineOrganizationInvite(input: DeclineOrganizationInviteInput!): DeclineOrganizationInvitePayload

  """
  deleteAllChannelVideos deletes all videos for a given channel id for the authenticated users.
  """
  deleteAllChannelVideos(input: DeleteAllChannelVideosInput): DeleteAllChannelVideosPayload

  """Deletes a bits badge tier emoticon."""
  deleteBitsBadgeTierEmoticon(input: DeleteBitsBadgeTierEmoticonInput!): DeleteBitsBadgeTierEmoticonPayload

  """Deletes a celebration from the channel."""
  deleteCelebration(input: DeleteCelebrationInput!): DeleteCelebrationPayload

  """Deletes a blocked term from a channel."""
  deleteChannelBlockedTerm(input: DeleteChannelBlockedTermInput!): DeleteChannelBlockedTermPayload

  """Deletes clips from a channel."""
  deleteChannelClips(input: DeleteChannelClipsInput!): DeleteChannelClipsPayload

  """Deletes a permitted term from a channel."""
  deleteChannelPermittedTerm(input: DeleteChannelPermittedTermInput!): DeleteChannelPermittedTermPayload

  """deleteChatMessage deletes a single message from stream chat."""
  deleteChatMessage(input: DeleteChatMessageInput!): DeleteChatMessagePayload

  """Deletes a custom cheermote tier from a channel."""
  deleteCheermoteTier(input: DeleteCheermoteTierInput!): DeleteCheermoteTierPayload

  """
  deleteClips allows a user to delete clips by slugs, video id, or broadcast id.
  Only the slug and id can be accessed from the list of deleted clips.
  """
  deleteClips(input: DeleteClipsInput!): DeleteClipsPayload

  """
  deleteCollection performs a delete on the collection with the provided ID.
  """
  deleteCollection(input: DeleteCollectionInput!): DeleteCollectionPayload

  """
  deleteCommunityPointsCommunityGoal deletes a Community Points Community Goal.
  """
  deleteCommunityPointsCommunityGoal(input: DeleteCommunityPointsCommunityGoalInput!): DeleteCommunityPointsCommunityGoalPayload

  """Deletes a custom Community Points reward from a channel."""
  deleteCommunityPointsCustomReward(input: DeleteCommunityPointsCustomRewardInput): DeleteCommunityPointsCustomRewardPayload

  """Delete a Competition."""
  deleteCompetition(input: DeleteCompetitionInput!): DeleteCompetitionPayload

  """
  deleteContentTags removes the tags specified and associates it with the piece of content specified.
  """
  deleteContentTags(input: DeleteContentTagsInput!): DeleteContentTagsPayload

  """
  Deletes the default payment method for a user.
  Currently supports the Zuora (credit card) and Recurly (credit card, Pay-with-Amazon, PayPal) payment providers.
  """
  deleteDefaultPaymentMethod(input: DeleteDefaultPaymentMethodInput!): DeleteDefaultPaymentMethodPayload

  """
  deleteDeviceToken deletes a previously added device token by user and device token ID.
  """
  deleteDeviceToken(input: DeleteDeviceTokenInput!): DeleteDeviceTokenPayload

  """
  deleteDrop allows a drop organization owner to delete a drop from their organization.
  """
  deleteDrop(input: DeleteDropInput!): DeleteDropPayload

  """
  deleteDropCampaign allows a drop campaign owner to delete a drop campaign.
  """
  deleteDropCampaign(input: DeleteDropCampaignInput!): DeleteDropCampaignPayload

  """Deletes a specified emote."""
  deleteEmote(input: DeleteEmoteInput!): DeleteEmotePayload

  """deleteExtension allows an extension owner to delete an extension."""
  deleteExtension(input: DeleteExtensionInput!): DeleteExtensionPayload

  """deleteExtensionImage delete extension image assets of the given urls."""
  deleteExtensionImage(input: DeleteExtensionImageInput!): DeleteExtensionImagePayload

  """
  Delete all secrets associated with an extension; this will immediately break all clients until
  both a new secret rotate is executed and the clients manually refresh themselves. Only use this
  if a secret is compromised and must be immediately removed from circulation.
  """
  deleteExtensionSecrets(input: DeleteExtensionSecretsInput!): DeleteExtensionSecretsPayload

  """Deletes a Loyalty Badge of a Channel."""
  deleteLoyaltyBadge(input: DeleteLoyaltyBadgeInput!): DeleteLoyaltyBadgePayload

  """
  deleteModeratorComment deletes a moderator comment with the given ID.
  The comment must have been created on the requester's channel.
  """
  deleteModeratorComment(input: DeleteModeratorCommentInput!): DeleteModeratorCommentPayload

  """
  deleteMultiviewContentAttributes deletes content attributes with the provided IDs.
  """
  deleteMultiviewContentAttributes(input: DeleteMultiviewContentAttributesInput!): DeleteMultiviewContentAttributesPayload

  """
  deleteNotification deletes an onsite notification of the authenticated user.
  """
  deleteNotification(input: DeleteNotificationInput!): DeleteNotificationPayload

  """deletePanel removes a panel."""
  deletePanel(input: DeletePanelInput!): DeletePanelPayload

  """deletePost deletes a old post."""
  deletePost(input: DeletePostInput!): DeletePostPayload @deprecated

  """
  deleteRecommendationFeedback deletes all the recommendation feedback that matches the given input.
  """
  deleteRecommendationFeedback(input: DeleteRecommendationFeedbackInput!): DeleteRecommendationFeedbackPayload

  """Deletes a chatroom."""
  deleteRoom(input: DeleteRoomInput!): DeleteRoomPayload @deprecated

  """Deletes an existing message in a chatroom."""
  deleteRoomMessage(input: DeleteRoomMessageInput!): DeleteRoomMessagePayload

  """Delete the entire schedule of a user."""
  deleteSchedule(input: DeleteScheduleInput!): DeleteSchedulePayload

  """Delete a segment of a schedule of a user."""
  deleteScheduleSegment(input: DeleteScheduleSegmentInput!): DeleteScheduleSegmentPayload

  """deleteSocialMedia deletes a social media item for a Channel."""
  deleteSocialMedia(input: DeleteSocialMediaInput!): DeleteSocialMediaPayload

  """
  deleteSquadStreamInvitation allows a squad stream member to delete a squad stream invitation.
  """
  deleteSquadStreamInvitation(input: DeleteSquadStreamInvitationInput!): DeleteSquadStreamInvitationPayload

  """
  Deletes an authorized user who was allowed to stream on behalf of broadcaster.
  """
  deleteStreamAuthorizedUser(input: DeleteStreamAuthorizedUserInput!): DeleteStreamAuthorizedUserPayload

  """Deletes clips made by user."""
  deleteUserClips(input: DeleteUserClipsInput!): DeleteUserClipsPayload

  """Deletes a user's creator colors."""
  deleteUserColors(input: DeleteUserColorsInput!): DeleteUserColorsPayload

  """
  deleteVideoComment performs a delete on the video comment with the provided comment ID.
  NOTE: this should use an input argument, not define the commentID right here.
  """
  deleteVideoComment(commentID: ID!): DeleteVideoCommentPayload

  """deleteVideos performs a delete on the list of video ids."""
  deleteVideos(input: DeleteVideosInput!): DeleteVideosPayload

  """deleteVideoThumbnail deletes a thumbnail from a video."""
  deleteVideoThumbnail(input: DeleteVideoThumbnailInput!): DeleteVideoThumbnailPayload

  """Denies a message rejected on a channel chat."""
  denyRejectedChatMessage(input: DenyRejectedChatMessageInput!): DenyRejectedChatMessagePayload

  """Denies a cheer rejected on a channel chat."""
  denyRejectedCheer(input: DenyRejectedCheerInput!): DenyRejectedCheerPayload @deprecated(reason: "logic handled by denyRejectedChatMessage")

  """Deny an unban request from a channel-banned user."""
  denyUnbanRequest(input: DenyUnbanRequestInput!): DenyUnbanRequestPayload

  """Deselect channel badge (default to global badge)."""
  deselectChannelBadge(input: DeselectChannelBadgeInput!): DeselectChannelBadgePayload

  """Deselect global badge (default to no badge)."""
  deselectGlobalBadge: DeselectGlobalBadgePayload

  """
  Disables Two Factor Authentication for a Twitch user. Requires sudo authentication.
  """
  disableTwoFactor(input: DisableTwoFactorInput!): DisableTwoFactorPayload

  """
  Allows the current user to disable or permanently delete their own account.
  """
  disableUserAccount(input: DisableUserAccountInput!): DisableUserAccountPayload

  """
  dismissFriendRecommendation removes a friend recommendation to the authenticated user without creating a friend
  request.
  """
  dismissFriendRecommendation(input: DismissFriendRecommendationInput!): DismissFriendRecommendationPayload

  """Permanently dismiss a ritual token without redeeming it."""
  dismissRitualToken(input: DismissRitualTokenInput!): DismissRitualTokenPayload

  """
  dismissVideoSuggestedHighlight dismisses the automated highlight suggestion for a video.
  """
  dismissVideoSuggestedHighlight(input: DismissVideoSuggestedHighlightInput!): DismissVideoSuggestedHighlightPayload

  """
  dropImageUpload makes a request for a url to upload an image to. The caller can then use the URL to upload an image
  of their choice for either a drop or a benefit.
  """
  dropImageUpload(input: DropImageUploadInput!): DropImageUploadPayload

  """Edits an existing message in a chatroom."""
  editRoomMessage(input: EditRoomMessageInput!): EditRoomMessagePayload @deprecated

  """
  emitCampaignDiscoveryEvent updates a user's progress towards a discovery objective in applicable campaigns.
  """
  emitCampaignDiscoveryEvent(input: EmitCampaignDiscoveryEventInput!): EmitCampaignDiscoveryEventPayload @deprecated

  """
  endUseBitsInExtension completes the bit usage transaction in an extension.
  """
  endUseBitsInExtension(input: EndUseBitsInExtensionInput!): EndUseBitsInExtensionPayload

  """equipHeroAssets adds the specified assets to a user's hero."""
  equipHeroAssets(input: EquipHeroAssetsInput!): EquipHeroAssetsPayload

  """exportVideoToYoutube allows a user to export a video to Youtube."""
  exportVideoToYoutube(input: ExportVideoToYoutubeInput!): ExportVideoToYoutubePayload

  """
  extensionLinkUser enables or disables the user's identity sharing with an extension.
  """
  extensionLinkUser(input: ExtensionLinkUserInput!): ExtensionLinkUserPayload

  """
  finalizeCompetitionLobby update's a lobby's state to DONE and progresses the competition.
  """
  finalizeCompetitionLobby(input: FinalizeCompetitionLobbyInput!): FinalizeCompetitionLobbyPayload

  """followGame allows a user to follow a game."""
  followGame(input: FollowGameInput!): FollowGamePayload

  """
  followUser creates a follow relationship between the authenticated user and
  the target user.
  """
  followUser(input: FollowUserInput!): FollowUserPayload

  """
  generateAnimatedEmote kicks off the generation of animated .gif assets from a given animation preset and static image ids.
  The user will be notified of success or failure on pubsub.
  """
  generateAnimatedEmote(input: GenerateAnimatedEmoteInput!): GenerateAnimatedEmotePayload

  """
  generateExtensionRatingsCSVReport  asks the ExtensionRatings backend to generate a report and return a filename
  for that report.  The filename can then be used in follow-up calls to getReportPresignedURL to poll for its
  completion.  Authenticated on userID:extensionID via OWL in the ExtensionRatings backend.
  """
  generateExtensionRatingsCSVReport(input: GenerateExtensionRatingsCSVReportInput!): GenerateExtensionRatingsCSVReportPayload

  """
  generateSecondFactorQRCode generates a new second factor QR code so it can be used to generate OTP for authentication.
  The mutation requires sudo privilege to be successful.
  """
  generateSecondFactorQRCode(input: GenerateSecondFactorQRCodeInput!): GenerateSecondFactorQRCodePayload

  """
  generateSubscribersCSV kicks off a background job that will generate a csv containing a list
  of the channel's subscribers and then will alert the frontend that the csv is ready to
  download using pubsub. Authenticated on the channelID.
  """
  generateSubscribersCSV(input: GenerateSubscribersCSVInput!): GenerateSubscribersCSVPayload

  """
  getEmoteUploadConfig makes a request to mako to get emote upload configuration for a user to upload a new emote with.
  """
  getEmoteUploadConfig(input: GetEmoteUploadConfigInput!): GetEmoteUploadConfigPayload

  """Start a raid."""
  goRaid(input: GoRaidInput!): GoRaidPayload

  """Grant the VIP status to a user for a channel."""
  grantVIP(input: GrantVIPInput!): GrantVIPPayload

  """Host a target channel from a channel."""
  hostTargetChannel(input: HostTargetChannelInput!): HostTargetChannelPayload

  """Install an extension onto a specific channel."""
  installExtension(input: InstallExtensionInput!): InstallExtensionPayload

  """Disable the schedule of a user."""
  interruptSchedule(input: InterruptScheduleInput!): InterruptSchedulePayload

  """Invalidates authenticated sessions."""
  invalidateAuthenticatedSessions(input: InvalidateAuthenticatedSessionsInput!): InvalidateAuthenticatedSessionsPayload

  """Invalidates an association to an email."""
  invalidateEmailAssociation(input: InvalidateEmailAssociationInput!): InvalidateEmailAssociationPayload

  """Joins the channel's chatrooms."""
  joinChannelRooms(input: JoinChannelRoomsInput!): JoinChannelRoomsPayload @deprecated

  """
  Add a viewer to a source channel's raid. The viewer will be redirected to the target channel when the raid starts.
  """
  joinRaid(input: JoinRaidInput!): JoinRaidPayload

  """Leaves the channel's chatrooms."""
  leaveChannelRooms(input: LeaveChannelRoomsInput!): LeaveChannelRoomsPayload @deprecated

  """Leave a raid for a viewer."""
  leaveRaid(input: LeaveRaidInput!): LeaveRaidPayload

  """
  leaveSquadStream allows a member of a squad stream to leave the squad.  Their stream will be
  removed from the viewer experience, and they will be free to start/join another squad stream.
  """
  leaveSquadStream(input: LeaveSquadStreamInput!): LeaveSquadStreamPayload

  """Link a single sign-on (SSO) app to a user's account."""
  linkSSO(input: LinkSSOInput!): LinkSSOPayload @deprecated(reason: "Service has been shutdown")

  """
  Update a Prediction Event from ACTIVE to LOCKED, so that users can no longer make predictions on it.
  """
  lockPredictionEvent(input: LockPredictionEventInput!): LockPredictionEventPayload

  """
  Makes a download URL for an authorized user to download a batch of keys.
  """
  makeKeyBatchDownloadURL(input: MakeKeyBatchDownloadURLInput!): MakeKeyBatchDownloadURLPayload

  """Make a prediction on an active Prediction Event."""
  makePrediction(input: MakePredictionInput!): MakePredictionPayload

  """Manually triggers drop in Drops 2.0 system."""
  manuallyTriggerDrop(input: ManuallyTriggerDropInput!): ManuallyTriggerDropPayload

  """ReadAllCreatorNotifications marks all creator notifications as read."""
  markAllCreatorNotificationsAsRead(input: MarkAllCreatorNotificationsAsReadInput!): MarkAllCreatorNotificationsAsReadPayload

  """ReadAllViewerNotifications marks all viewer notifications as read."""
  markAllViewerNotificationsAsRead(input: MarkAllViewerNotificationsAsReadInput): MarkAllViewerNotificationsAsReadPayload

  """Make a user a moderator for a channel."""
  modUser(input: ModUserInput!): ModUserPayload

  """
  orderPanels updates the sort order of the provided panels, the input must be a list of panel ids
  all of which are owned by the acting user otherwise the request will fail and a generic GraphQL
  error will be returned.
  """
  orderPanels(input: OrderPanelsInput!): OrderPanelsPayload

  """
  Presign and return a secure S3 URL to download a CSV report for a GAME or EXTENSION.
  The generated CSV report contains rows for every day after 2018-01-31.
  """
  presignDevInsightsReportURL(input: PresignDevInsightsReportURLInput!): PresignDevInsightsReportURLPayload

  """
  processAndroidPayment processes an off-platform Android payment (user was charged outside the Twitch platform).
  See also: processIOSPayment (iOS purchases) and purchaseOffer (on-platform purchases).
  """
  processAndroidPayment(input: ProcessAndroidPaymentInput!): ProcessAndroidPaymentPayload

  """
  processIOSPayment processes an off-platform iOS payment (user was charged outside the Twitch platform).
  See also: processAndroidPayment (Android purchases) and purchaseOffer (on-platform purchases).
  """
  processIOSPayment(input: ProcessIOSPaymentInput!): ProcessIOSPaymentPayload

  """
  publishClip allows a user to permanently edit and update their default clip, viewable to the public.
  """
  publishClip(input: PublishClipInput!): PublishClipPayload

  """Publishes a competition to make it visible on the esports page."""
  publishCompetition(input: PublishCompetitionInput!): PublishCompetitionPayload

  """
  Publishes a subscription emote to become available with a subscription product.
  """
  publishSubscriptionEmote(input: PublishSubscriptionEmoteInput!): PublishSubscriptionEmotePayload

  """
  purchaseOffer completes the purchase of an offer made inside the Twitch platform.
  See also: processAndroidPayment (Android purchases) and processIOSPayment.
  """
  purchaseOffer(input: PurchaseOfferInput!): PurchaseOfferPayload

  """Submit a rating for a Twitch extension."""
  rateExtension(input: RateExtensionInput!): RateExtensionPayload

  """
  readNotifications sets the read state to true for one or more onsite notifications of the authenticated user.
  """
  readNotifications(input: ReadNotificationsInput!): ReadNotificationsPayload

  """Record an ad event."""
  recordAdEvent(input: RecordAdEventInput!): RecordAdEventPayload

  """
  Redeem a claimable code, like a bits key code to add bits to your account, etc.
  """
  redeemClaimable(input: RedeemClaimableInput!): RedeemClaimablePayload

  """Redeem a Community Points custom reward in a channel."""
  redeemCommunityPointsCustomReward(input: RedeemCommunityPointsCustomRewardInput!): RedeemCommunityPointsCustomRewardPayload

  """Redeem a set of creator gift subscriptions."""
  redeemCreatorGifts(input: RedeemCreatorGiftsInput!): RedeemCreatorGiftsPayload

  """
  Redeem an available ritual token. Currently, tokens are redeemed by sending
  a special message to a channel's chat.
  """
  redeemRitualToken(input: RedeemRitualTokenInput!): RedeemRitualTokenPayload

  """Submit a Subscription Redemption."""
  redeemSubscription(input: RedeemSubscriptionInput!): RedeemSubscriptionPayload

  """
  redeemTrueXAd processes the result of watching an ad to earn bits.
  This action can only be taken if an OAuth token is supplied with the request.
  """
  redeemTrueXAd(input: RedeemTrueXAdInput!): RedeemTrueXAdPayload

  """
  refreshExtensionToken is used by our client on a timer to ensure the token
  doesn't expire while the user is using the site.
  """
  refreshExtensionToken(input: RefreshExtensionTokenInput!): RefreshExtensionTokenPayload

  """
  regenerateStreamKey generates a new stream key for the broadcaster and returns the newly generated stream key.
  """
  regenerateStreamKey(input: RegenerateStreamKeyInput!): RegenerateStreamKeyPayload

  """
  regenerateVerificationCode generates a new verification code and resends the verification message with the new code.
  """
  regenerateVerificationCode(input: RegenerateVerificationCodeInput!): RegenerateVerificationCodePayload

  """Register payout information during payout onboarding."""
  registerPayoutInformation(input: RegisterPayoutInformationInput!): RegisterPayoutInformationPayload

  """
  Starts the registration for second factor authentication for a twitch user. Requires sudo authentication.
  """
  registerTwoFactor(input: RegisterTwoFactorInput!): RegisterTwoFactorPayload

  """
  Finishes the registration for second factor authentication for a twitch user. Requires sudo authentication.
  """
  registerTwoFactorConfirmation(input: RegisterTwoFactorConfirmationInput!): RegisterTwoFactorConfirmationPayload

  """
  rejectFriendRequest destroys a friend request relationship from the target user to the authenticated user.
  """
  rejectFriendRequest(input: RejectFriendRequestInput!): RejectFriendRequestPayload

  """
  rejectSquadStreamInvitation allows a user to decline an invitation to join a squad stream.
  """
  rejectSquadStreamInvitation(input: RejectSquadStreamInvitationInput!): RejectSquadStreamInvitationPayload

  """
  rejectSquadStreamOutOfNetworkInvitations allows a user to decline all out-of-network invitations to join a squad stream.
  """
  rejectSquadStreamOutOfNetworkInvitations(input: RejectSquadStreamOutOfNetworkInvitationsInput!): RejectSquadStreamOutOfNetworkInvitationsPayload

  """Removes channels from a user's AutoHost list."""
  removeAutohostChannels(input: RemoveAutohostChannelsInput!): RemoveAutohostChannelsPayload

  """removeCollectionItem removes an item from a collection."""
  removeCollectionItem(input: RemoveCollectionItemInput!): RemoveCollectionItemPayload

  """Remove a phase from a Competition."""
  removeCompetitionPhase(input: RemoveCompetitionPhaseInput!): RemoveCompetitionPhasePayload

  """Remove CompetitionPlayer from a competition."""
  removeCompetitionPlayer(input: RemoveCompetitionPlayerInput!): RemoveCompetitionPlayerPayload

  """Remove a competition team from a Competition."""
  removeCompetitionTeam(input: RemoveCompetitionTeamInput!): RemoveCompetitionTeamPayload

  """Revoke the editor status from a user for a given channel."""
  removeEditor(input: RemoveEditorInput!): RemoveEditorPayload

  """Remove an emote from its assigned group."""
  removeEmoteFromGroup(input: RemoveEmoteFromGroupInput!): RemoveEmoteFromGroupPayload

  """Removes a rbac user from a developer organization."""
  removeOrganizationMember(input: RemoveOrganizationMemberInput!): RemoveOrganizationMemberPayload

  """removeReaction removes a reaction created with addReaction."""
  removeReaction(input: RemoveReactionInput!): RemoveReactionPayload @deprecated

  """
  removeSquadStreamMember allows the owner of a squad stream to remove a member from the squad stream.
  """
  removeSquadStreamMember(input: RemoveSquadStreamMemberInput!): RemoveSquadStreamMemberPayload

  """
  removeStucco allows the owner of a stucco to remove an inactive stucco from their library.
  """
  removeStucco(input: RemoveStuccoInput!): RemoveStuccoPayload

  """reorderCollectionItem reorders an item's position in a collection."""
  reorderCollectionItem(input: ReorderCollectionItemInput!): ReorderCollectionItemPayload

  """
  reportContent allows a user to report content on the site as infringing of our terms of service.
  """
  reportContent(input: ReportContentInput!): ReportContentPayload

  """Reports a user for bad behavior in a whisper thread."""
  reportWhisper(input: ReportWhisperInput!): ReportWhisperPayload

  """Reports a whisper thread as spam."""
  reportWhisperThread(input: ReportWhisperThreadInput!): ReportWhisperThreadPayload @deprecated(reason: "Use reportWhisper")

  """Request a ritual token to be issued to the user."""
  requestRitualToken(input: RequestRitualTokenInput!): RequestRitualTokenPayload

  """
  resendVerificationEmail resends a verification email to the current user.
  """
  resendVerificationEmail(input: ResendVerificationEmailInput!): ResendVerificationEmailPayload

  """resetUsername allows a user to update their flagged username."""
  resetUsername(input: ResetUsernameInput!): ResetUsernamePayload

  """Resolve a Prediction Event by specifying the winning option."""
  resolvePredictionEvent(input: ResolvePredictionEventInput!): ResolvePredictionEventPayload

  """Respond to a team invitation by accepting or declining."""
  respondToTeamInvitation(input: RespondToTeamInvitationInput!): RespondToTeamInvitationPayload

  """Enable the schedule of a user."""
  resumeSchedule(input: ResumeScheduleInput!): ResumeSchedulePayload

  """Revoke the VIP status of a user from a channel."""
  revokeVIP(input: RevokeVIPInput!): RevokeVIPPayload

  """
  Request a new extension secret; automatically rotates any current secrets out of service
  with enough time for extension clients to gracefully switch over.  This function should
  only be called when you are ready to install the new set of secrets it will return; use
  GET to view secrets without rotating them.
  """
  rotateExtensionSecrets(input: RotateExtensionSecretsInput!): RotateExtensionSecretsPayload

  """Runs multiplayer ads on a channel."""
  runMultiplayerAds(input: RunMultiplayerAdsInput!): RunMultiplayerAdsPayload

  """
  saveExtensionManifest allows a user to update the manifest for an extension in development.
  """
  saveExtensionManifest(input: SaveExtensionManifestInput!): SaveExtensionManifestPayload

  """Give a competition participant a seed value."""
  seedCompetitionParticipant(input: SeedCompetitionParticipantInput!): SeedCompetitionParticipantPayload

  """Select a user's channel badge for a channel."""
  selectChannelBadge(input: SelectChannelBadgeInput!): SelectChannelBadgePayload

  """Select a user's global badge."""
  selectGlobalBadge(input: SelectGlobalBadgeInput!): SelectGlobalBadgePayload

  """Send a chat message through subscribers-only mode with Channel Points."""
  sendChatMessageThroughSubscriberMode(input: SendChatMessageThroughSubscriberModeInput!): SendChatMessageThroughSubscriberModePayload

  """
  sendCheer sends a chat message that contains cheermotes. The message will
  be processed, bits deducted from the authenticated user's balance, and then the
  message will be passed on to the chat service (client shouldn't send the message itself).
  This action can only be taken if an OAuth token is supplied with the request.
  """
  sendCheer(input: SendCheerInput!): SendCheerPayload

  """Sends a pubsub message on behalf of an Extension."""
  sendExtensionMessage(input: SendExtensionMessageInput!): SendExtensionMessagePayload

  """Send a highlighted chat message with Channel Points."""
  sendHighlightedChatMessage(input: SendHighlightedChatMessageInput!): SendHighlightedChatMessagePayload

  """Sends a message to a chatroom."""
  sendRoomMessage(input: SendRoomMessageInput!): SendRoomMessagePayload @deprecated

  """Sends a whisper message to the target user."""
  sendWhisper(input: SendWhisperInput!): SendWhisperPayload

  """Set values for length and period of ads for channel ads management."""
  setAutoAdDensity(input: SetAutoAdDensityInput!): SetAutoAdDensityPayload

  """Sets the user's auto refill settings."""
  setAutoRefillSettings(input: SetAutoRefillSettingsInput!): SetAutoRefillSettingsPayload

  """Sets the user's list of channelIDs to autohost."""
  setAutohostChannels(input: SetAutohostChannelsInput!): SetAutohostChannelsPayload

  """
  setBitsUserSettings sets a Bits users settings such as skipping the tutorial.
  """
  setBitsUserSettings(input: SetBitsUserSettingsInput!): SetBitsUserSettingsPayload

  """Set value for channel_feed_enabled."""
  setChannelFeedEnabled(input: SetChannelFeedEnabledInput!): SetChannelFeedEnabledPayload @deprecated

  """
  setChannelNotificationSetting allows a user to set a notification setting.
  """
  setChannelNotificationSetting(input: SetChannelNotificationSettingInput!): SetChannelNotificationSettingPayload

  """
  Set a channel's trailer.
  A channel trailer can only be modified by its corresponding user, a channel editor, or a Twitch admin.
  """
  setChannelTrailer(input: SetChannelTrailerInput!): SetChannelTrailerPayload

  """Set a user's Chat Pause setting."""
  setChatPauseSetting(input: SetChatPauseSettingInput!): SetChatPauseSettingPayload

  """
  setContentTags updates the tags specified and associates it with the piece of content specified.
  """
  setContentTags(input: SetContentTagsInput!): SetContentTagsPayload

  """
  setCreatorBadgeFlair updates the channel-wide setting for a user that determines what
  type of subscriber badge flair is available to eligible subscribers to that channel.
  """
  setCreatorBadgeFlair(input: SetCreatorBadgeFlairInput!): SetCreatorBadgeFlairPayload

  """
  setDashboardAlertQueueActivityStatus updates the specified activity's status for the dashboard alert queue.
  """
  setDashboardAlertQueueActivityStatus(input: SetDashboardAlertQueueActivityStatusInput!): SetDashboardAlertQueueActivityStatusPayload

  """
  setDashboardAlertQueuePreference updates the preference specified for the dashboard alert queue.
  """
  setDashboardAlertQueuePreference(input: SetDashboardAlertQueuePreferenceInput!): SetDashboardAlertQueuePreferencePayload

  """
  Sets the default payment method for a user.
  Currently supports the Zuora (credit card) and Recurly (credit card, Pay-with-Amazon, PayPal) payment providers
  This is the final step of the payment method management flow.
  (User.paymentMethods -> User.paymentMethodConfigs -> this mutation).
  """
  setDefaultPaymentMethod(input: SetDefaultPaymentMethodInput!): SetDefaultPaymentMethodPayload

  """Set a user's Deleted Message Display Chat UI setting."""
  setDeletedMessageDisplaySetting(input: SetDeletedMessageDisplaySettingInput!): SetDeletedMessageDisplaySettingPayload

  """SetDropBenefitOnDrop adds a benefit to a drop within a drop campaign."""
  setDropBenefitsOnDrop(input: SetDropBenefitsOnDropInput!): SetDropBenefitsOnDropPayload

  """
  setDropCampaignAccess updates who can or cannot access a campaign's drops.
  """
  setDropCampaignAccess(input: SetDropCampaignAccessInput!): SetDropCampaignAccessPayload

  """setDropCampaignStatus transitions a campaign between states."""
  setDropCampaignStatus(input: SetDropCampaignStatusInput!): SetDropCampaignStatusPayload

  """
  setDropCampaignSummary allows organizations in the devconsole to update a previously created campaign's summary.
  """
  setDropCampaignSummary(input: SetDropCampaignSummaryInput!): SetDropCampaignSummaryPayload

  """setDropEventRule updates a drops's rule to be an event based rule."""
  setDropEventRule(input: SetDropEventRuleInput!): SetDropEventRulePayload

  """setDropSummary allows organizations to update a drop's summary data."""
  setDropSummary(input: SetDropSummaryInput!): SetDropSummaryPayload

  """
  setDropTimeBasedRule updates a drops's rule to be a minutes watched based rule.
  """
  setDropTimeBasedRule(input: SetDropTimeBasedRuleInput!): SetDropTimeBasedRulePayload

  """Set a user's emote animations UI setting."""
  setEmoteAnimationsEnabled(input: SetEmoteAnimationsEnabledInput!): SetEmoteAnimationsEnabledPayload

  """Set a user's emote animations callout dismissed setting."""
  setEmoteAnimationsSettingCalloutDismissed(input: SetEmoteAnimationsSettingCalloutDismissedInput!): SetEmoteAnimationsSettingCalloutDismissedPayload

  """Sets the emote modifier groups for a user."""
  setEmoteModifierGroups(input: SetEmoteModifierGroupsInput!): SetEmoteModifierGroupsPayload

  """Sets the configuration for an extension version."""
  setExtensionConfiguration(input: SetExtensionConfigurationInput!): SetExtensionConfigurationPayload

  """Sets the feature flag options on a specified extension installation."""
  setExtensionFeatureFlags(input: SetExtensionFeatureFlagsInput!): SetExtensionFeatureFlagsPayload

  """
  Set the OAuth token for an installation which is retrieved and used for Helix requests from extensions.
  """
  setExtensionInstallationOAuth(input: SetExtensionInstallationOAuthInput!): SetExtensionInstallationOAuthPayload

  """
  SetGameDropAccountLinkClient sets the client ID on a game which is used to
  verify that users have connected their game accounts.
  """
  setGameDropAccountLinkClient(input: SetGameDropAccountLinkClientInput!): SetGameDropAccountLinkClientPayload

  """Sets the user's current hero to their profile picture."""
  setHeroAsAvatar(input: SetHeroAsAvatarInput!): SetHeroAsAvatarPayload

  """
  Set access permission to the channel's moderator logs for a given role.
  """
  setModLogsAccess(input: SetModLogsAccessInput!): SetModLogsAccessPayload

  """Set a user's mod view page tutorial seen state & time."""
  setModViewSettings(input: SetModViewSettingsInput!): SetModViewSettingsPayload

  """setNotificationSetting allows a user to set a notification setting."""
  setNotificationSetting(input: SetNotificationSettingInput!): SetNotificationSettingPayload

  """
  setOverwatchLeagueTeamPreference allows a user to set their preferred Overwatch team.
  """
  setOverwatchLeagueTeamPreference(input: SetOverwatchLeagueTeamPreferenceInput!): SetOverwatchLeagueTeamPreferencePayload

  """Set a user's preferred language tag."""
  setPreferredLanguageTag(input: SetPreferredLanguageTagInput!): SetPreferredLanguageTagPayload

  """Set radio track information currently being played."""
  setRadioCurrentlyPlaying(input: SetRadioCurrentlyPlayingInput!): SetRadioCurrentlyPlayingPayload

  """Set a user's readable chat colors UI setting."""
  setReadableChatColorsEnabled(input: SetReadableChatColorsEnabledInput!): SetReadableChatColorsEnabledPayload

  """
  setResourceRestriction can create or update a restriction on a resource.
  """
  setResourceRestriction(input: SetResourceRestrictionInput!): SetResourceRestrictionPayload

  """
  setScheduleReminder toggles on or off a user's set reminder for a given scheduled event.
  """
  setScheduleReminder(input: SetScheduleReminderInput!): SetScheduleReminderPayload

  """
  setSessionStatus sets the user's status for this session, which influences how they appear ("online", "idle",
  "watching SnarfyBobo") to friends and related users. To maintain a session status, setSessionStatus needs to be sent
  periodically. The amount of time your application should wait between these status heartbeats is included in the
  response payload.
  """
  setSessionStatus(input: SetSessionStatusInput!): SetSessionStatusPayload

  """
  Set the ID of the primary player in a squad stream that the user currently has in the primary position.
  """
  setSquadStreamPrimaryPlayer(input: SetSquadStreamPrimaryPlayerInput!): SetSquadStreamPrimaryPlayerPayload

  """
  setUnbanRequestsSettings allows a user to set their channel's unban requests settings.
  """
  setUnbanRequestsSettings(input: SetUnbanRequestsSettingsInput!): SetUnbanRequestsSettingsPayload

  """Set user's country of residence."""
  setUserResidence(input: SetUserResidenceInput!): SetUserResidencePayload

  """Spend Twitch Prime monthly subscription credit."""
  spendSubscriptionCredit(input: SpendSubscriptionCreditInput!): SpendSubscriptionCreditPayload

  """Start a new ad break."""
  startAd(input: StartAdInput!): StartAdPayload

  """
  startBounty allows a user to start a bounty for tracking (e.g. track the
  viewers CCU for meeting the bounty's requirements).
  If the user has not provided a title or met the other requirements to start the bounty, it will return an error.
  """
  startBounty(input: StartBountyInput!): StartBountyPayload

  """Starts a cloud broadcast."""
  startCloudBroadcast(input: StartCloudBroadcastInput!): StartCloudBroadcastPayload

  """Start a new payout onboarding workflow."""
  startPayoutOnboardingWorkflow(input: StartPayoutOnboardingWorkflowInput!): StartPayoutOnboardingWorkflowPayload

  """Start a Prime Video Watch Party."""
  startWatchParty(input: StartWatchPartyInput!): StartWatchPartyPayload

  """stopBounty allows a user to stop tracking progress for a bounty."""
  stopBounty(input: StopBountyInput!): StopBountyPayload

  """Stops a cloud broadcast."""
  stopCloudBroadcast(input: StopCloudBroadcastInput!): StopCloudBroadcastPayload

  """Stop a Prime Video Watch Party."""
  stopWatchParty(input: StopWatchPartyInput!): StopWatchPartyPayload

  """Submit CSAT (customer satisfaction) feedback."""
  submitCSATFeedback(input: SubmitCSATFeedbackInput!): SubmitCSATFeedbackPayload

  """
  Submit a new emote prefix for a given channel. Each channel has a single prefix.
  Submitting more than once overrides the previously set prefix.
  """
  submitEmotePrefix(input: SubmitEmotePrefixInput!): SubmitEmotePrefixPayload

  """
  Submit a new emoticon prefix for a given channel. Each channel has a single prefix. Submitting
  more than once simply overrides the previously set prefix and putting it in a pending state.
  """
  submitEmoticonPrefix(input: SubmitEmoticonPrefixInput!): SubmitEmoticonPrefixPayload @deprecated(reason: "Use 'submitEmotePrefix' instead")

  """Submit feedback for a Twitch extension."""
  submitExtensionFeedback(input: SubmitExtensionFeedbackInput!): SubmitExtensionFeedbackPayload

  """Swap competition lobby participants within a competition phase."""
  swapCompetitionLobbyParticipants(input: SwapCompetitionLobbyParticipantsInput!): SwapCompetitionLobbyParticipantsPayload

  """
  Syncs the current game data with the game data stored by the DropsManagementService. The DropsManagementService
  purposefully does not autosync when a Game is updated so that a change to the Game's account link client ID
  doesn't get overwritten without running this command.
  """
  syncGameOnDropCampaign(input: SyncGameOnDropCampaignInput!): SyncGameOnDropCampaignPayload

  """Terminates the poll with the given poll id."""
  terminatePoll(input: TerminatePollInput!): TerminatePollPayload

  """Terminates the current poll in a channel."""
  terminatePollInChannel(input: TerminatePollInChannelInput!): TerminatePollInChannelPayload

  """
  toggleRitualsEnabled allows a user to toggle the rituals feature for their channel.
  """
  toggleRitualsEnabled(input: ToggleRitualsEnabledInput!): ToggleRitualsEnabledPayload

  """
  Transitions the state for an existing extension.
  Only allowed for the owner of the extension.
  """
  transitionExtensionState(input: TransitionExtensionStateInput!): TransitionExtensionStatePayload

  """Removes a ban imposed on a user for a specified chat room."""
  unbanUserFromChatRoom(input: UnbanUserFromChatRoomInput!): UnbanUserFromChatRoomPayload

  """Removes block from target user."""
  unblockUser(input: UnblockUserInput!): UnblockUserPayload

  """
  undoRecommendationFeedback allows a user to removes a single piece of feedback.
  """
  undoRecommendationFeedback(input: UndoRecommendationFeedbackInput!): UndoRecommendationFeedbackPayload

  """unfollowGame allows a user to unfollow a game."""
  unfollowGame(input: UnfollowGameInput!): UnfollowGamePayload

  """
  unfollowUser destroys the follow relationship between the authenticated user and
  the target user.
  """
  unfollowUser(input: UnfollowUserInput!): UnfollowUserPayload

  """
  unfriendUser destroys a friend relationship from the target user to the authenticated user.
  """
  unfriendUser(input: UnfriendUserInput!): UnfriendUserPayload

  """Unhost from a channel."""
  unhost(input: UnhostInput!): UnhostPayload

  """Uninstall an extension from a specific channel."""
  uninstallExtension(input: UninstallExtensionInput!): UninstallExtensionPayload

  """Unlink an authenticated user's amazon connection."""
  unlinkAmazonConnection(input: UnlinkAmazonConnectionInput!): UnlinkAmazonConnectionPayload

  """Unlink a user's account connection to Riot."""
  unlinkRiotConnection(input: UnlinkRiotConnectionInput!): UnlinkRiotConnectionPayload

  """Unlink an SSO app from a user's account."""
  unlinkSSO(input: UnlinkSSOInput!): UnlinkSSOPayload @deprecated(reason: "Service has been shutdown")

  """Unlock a chosen modified subscriber emote using Community Points."""
  unlockChosenModifiedSubscriberEmote(input: UnlockChosenModifiedSubscriberEmoteInput!): UnlockChosenModifiedSubscriberEmotePayload

  """Unlock a chosen subscriber emote using Community Points."""
  unlockChosenSubscriberEmote(input: UnlockChosenSubscriberEmoteInput!): UnlockChosenSubscriberEmotePayload

  """Unlock a random subscriber emote using Community Points."""
  unlockRandomSubscriberEmote(input: UnlockRandomSubscriberEmoteInput!): UnlockRandomSubscriberEmotePayload

  """Remove moderator status from a user in a channel."""
  unmodUser(input: UnmodUserInput!): UnmodUserPayload

  """
  unsetHypeTrainConfig allows a user to unset the channel's custom hype train configurations.
  """
  unsetHypeTrainConfig(input: UnsetHypeTrainConfigInput!): UnsetHypeTrainConfigPayload

  """
  unsubscribeEmail unsubscribes a given user from a given email campaign.
  """
  unsubscribeEmail(input: UnsubscribeEmailInput!): UnsubscribeEmailPayload

  """Updates a user's ad settings for their channel."""
  updateAdProperties(input: UpdateAdPropertiesInput!): UpdateAdPropertiesPayload

  """Updates all a channels vidoes to the provided viewability."""
  updateAllChannelVideosViewability(input: UpdateAllChannelVideosViewabilityInput!): UpdateAllChannelVideosViewabilityPayload

  """Updates all of a user's whisper threads."""
  updateAllWhisperThreads(input: UpdateAllWhisperThreadsInput!): UpdateAllWhisperThreadsPayload

  """
  Set individual automod categories (i.e. set identity to level 3 but profanity to 0).
  """
  updateAutoModLevels(input: UpdateAutoModLevelsInput!): UpdateAutoModLevelsPayload

  """
  Set individual automod categories (i.e. set identity to level 3 but profanity
  to 0) - based on Sift categories, to be deprecated.
  """
  updateAutoModProperties(input: UpdateAutoModPropertiesInput!): UpdateAutoModPropertiesPayload

  """Update a user's autohost settings."""
  updateAutohostSettings(input: UpdateAutohostSettingsInput!): UpdateAutohostSettingsPayload

  """Updates bits badge tier notification."""
  updateBitsBadgeTierNotification(input: UpdateBitsBadgeTierNotificationInput!): UpdateBitsBadgeTierNotificationPayload

  """Updates bits badge tiers."""
  updateBitsBadgeTiers(input: UpdateBitsBadgeTiersInput!): UpdateBitsBadgeTiersPayload

  """Updates boost settings."""
  updateBoostSettings(input: UpdateBoostSettingsInput!): UpdateBoostSettingsPayload

  """
  updateBroadcastSettings allows the user to update their broadcast setting.
  """
  updateBroadcastSettings(input: UpdateBroadcastSettingsInput!): UpdateBroadcastSettingsPayload

  """Update a channels celebration."""
  updateCelebration(input: UpdateCelebrationInput!): UpdateCelebrationPayload

  """Update a channels celebration config."""
  updateCelebrationConfig(input: UpdateCelebrationConfigInput!): UpdateCelebrationConfigPayload

  """Update a channel's celebration product config."""
  updateCelebrationProductConfig(input: UpdateCelebrationProductConfigInput!): UpdateCelebrationProductConfigPayload

  """Update a user's celebration user settings."""
  updateCelebrationUserSettings(input: UpdateCelebrationUserSettingsInput!): UpdateCelebrationUserSettingsPayload

  """updateChangelogReadTime marks the changelog as read for a user."""
  updateChangelogReadTime: UpdateChangelogReadTimePayload

  """
  updateChanletContentAttributes allows users to make changes to the multi-view content attributes on a chanlet.
  """
  updateChanletContentAttributes(input: UpdateChanletContentAttributesInput!): UpdateChanletContentAttributesPayload

  """
  updateChannelClipsSetting allows a channel owner to enable/disable creation
  of Clips on their channel.
  """
  updateChannelClipsSetting(input: UpdateChannelClipsSettingInput!): UpdateChannelClipsSettingPayload

  """
  updateChannelHomePreferences updates a streamer's channel home preferences.
  """
  updateChannelHomePreferences(input: UpdateChannelHomePreferencesInput!): UpdateChannelHomePreferencesPayload

  """Update a channel's Prediction Settings."""
  updateChannelPredictionSettings(input: UpdateChannelPredictionSettingsInput!): UpdateChannelPredictionSettingsPayload

  """Updates a user's chat color."""
  updateChatColor(input: UpdateChatColorInput!): UpdateChatColorPayload

  """Set different chat settings (i.e. disable globalBannedWordsOptOut)."""
  updateChatSettings(input: UpdateChatSettingsInput!): UpdateChatSettingsPayload

  """Update the user's partner settings regarding bits."""
  updateCheerPartnerSettings(input: UpdateCheerPartnerSettingsInput!): UpdateCheerPartnerSettingsPayload

  """
  Updates the image assets for a broadcaster's particular cheermote tier.
  """
  updateCheermoteTier(input: UpdateCheermoteTierInput!): UpdateCheermoteTierPayload

  """updateClip allows a user to update the metadata of a clip."""
  updateClip(input: UpdateClipInput!): UpdateClipPayload

  """
  updateClipViewCount allows a user to increment the viewcount of a clip.
  """
  updateClipViewCount(input: UpdateClipViewCountInput!): UpdateClipViewCountPayload @deprecated(reason: "Will eventually be replaced by different viewcounting method")

  """
  updateCollection performs an update on the collection with the provided ID and updated attributes.
  """
  updateCollection(input: UpdateCollectionInput!): UpdateCollectionPayload

  """Update an automatic Community Points reward in a channel."""
  updateCommunityPointsAutomaticReward(input: UpdateCommunityPointsAutomaticRewardInput!): UpdateCommunityPointsAutomaticRewardPayload

  """Update a channel's Community Points channel settings."""
  updateCommunityPointsChannelSettings(input: UpdateCommunityPointsChannelSettingsInput!): UpdateCommunityPointsChannelSettingsPayload

  """
  updateCommunityPointsCommunityGoal updates a Community Points Community Goal.
  """
  updateCommunityPointsCommunityGoal(input: UpdateCommunityPointsCommunityGoalInput!): UpdateCommunityPointsCommunityGoalPayload

  """Update a custom Community Points reward in a channel."""
  updateCommunityPointsCustomReward(input: UpdateCommunityPointsCustomRewardInput!): UpdateCommunityPointsCustomRewardPayload

  """
  Update the status of a Community Points redemption (for example, from unfulfilled to fulfilled).
  """
  updateCommunityPointsCustomRewardRedemptionStatus(input: UpdateCommunityPointsCustomRewardRedemptionStatusInput!): UpdateCommunityPointsCustomRewardRedemptionStatusPayload

  """Update the status of all Community Points redemptions for a channel."""
  updateCommunityPointsCustomRewardRedemptionStatusesByChannel(input: UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput!): UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload

  """
  Update the status of the Community Points redemptions from the provided list.
  """
  updateCommunityPointsCustomRewardRedemptionStatusesByRedemptions(input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput!): UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload

  """Update the status of all Community Points redemptions for a reward."""
  updateCommunityPointsCustomRewardRedemptionStatusesByReward(input: UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput!): UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload

  """
  Allows users to sign up for or remove themselves from the Community Points early access program.
  """
  updateCommunityPointsEarlyAccessSettings(input: UpdateCommunityPointsEarlyAccessSettingsInput!): UpdateCommunityPointsEarlyAccessSettingsPayload @deprecated(reason: "Early access period is over.")

  """
  Update the last viewed timestamp of a user for Community Points content.
  """
  updateCommunityPointsLastViewedContent(input: UpdateCommunityPointsLastViewedContentInput!): UpdateCommunityPointsLastViewedContentPayload

  """Update an automatic Community Points reward cost acknowledgements."""
  updateCommunityPointsSmartCostsAcknowledgements(input: UpdateCommunityPointsSmartCostsAcknowledgementsInput!): UpdateCommunityPointsSmartCostsAcknowledgementsPayload

  """Update Competition."""
  updateCompetition(input: UpdateCompetitionInput!): UpdateCompetitionPayload

  """Update CompetitionPlayer in a competition."""
  updateCompetitionPlayer(input: UpdateCompetitionPlayerInput!): UpdateCompetitionPlayerPayload

  """Update  a Team in a Competition."""
  updateCompetitionTeam(input: UpdateCompetitionTeamInput!): UpdateCompetitionTeamPayload

  """Update a consent status or create a new consent status."""
  updateConsent(input: UpdateConsentInput!): UpdateConsentPayload

  """
  updateContentTags updates the tags specified and associates it with the piece of content specified.
  """
  updateContentTags(input: UpdateContentTagsInput!): UpdateContentTagsPayload @deprecated(reason: "Use setContentTags instead")

  """
  updateDropBenefit updates a benefit owned by an organization. The benefit can be used in drop campaigns.
  """
  updateDropBenefit(input: UpdateDropBenefitInput!): UpdateDropBenefitPayload

  """
  updateDropBenefitOnDrop sets a benefit on a drop and how often that benefit can be claimed.
  """
  updateDropBenefitOnDrop(input: UpdateDropBenefitOnDropInput!): UpdateDropBenefitOnDropPayload

  """
  updateDropPreconditions updates the drops that must be claimed before a drop can be claimed.
  """
  updateDropPreconditions(input: UpdateDropPreconditionsInput!): UpdateDropPreconditionsPayload

  """
  updateDropsOptOutStatus allows the user to update their drops opt-out status.
  """
  updateDropsOptOutStatus(input: UpdateDropsOptOutStatusInput!): UpdateDropsOptOutStatusPayload

  """
  updateEmoteOrders allows a broadcaster to reorder the emotes within the emote groups they own.
  """
  updateEmoteOrders(input: UpdateEmoteOrdersInput!): UpdateEmoteOrdersPayload

  """
  updateExtensionDiscoveryData allows a user to update the discovery data for an extension.
  """
  updateExtensionDiscoveryData(input: UpdateExtensionDiscoveryDataInput!): UpdateExtensionDiscoveryDataPayload

  """
  updateExtensionManifest allows a user to update the manifest for an extension in development.
  """
  updateExtensionManifest(input: UpdateExtensionManifestInput!): UpdateExtensionManifestPayload @deprecated(reason: "Switching to saveExtensionManifest")

  """
  updateHypeTrainConfig allows a user to update the channel's hype train configurations.
  """
  updateHypeTrainConfig(input: UpdateHypeTrainConfigInput!): UpdateHypeTrainConfigPayload

  """
  Changes the user's activity sharing setting. A user's activity is one part of their status.
  """
  updateIsSharingActivity(input: UpdateIsSharingActivityInput!): UpdateIsSharingActivityPayload

  """Exchanges an LWA token for an Amazon OAuth token."""
  updateLWAToken(input: UpdateLWATokenInput!): UpdateLWATokenPayload

  """Update the user's partner settings regarding leaderboards."""
  updateLeaderboardSettings(input: UpdateLeaderboardSettingsInput!): UpdateLeaderboardSettingsPayload

  """
  Changes the user's activity sharing setting. A user's activity is one part of their status.
  """
  updateLiveUpNotification(input: UpdateLiveUpNotificationInput!): UpdateLiveUpNotificationPayload

  """
  Updates a lobby participant who is a competition player's or competition team's score.
  """
  updateLobbyParticipantScore(input: UpdateLobbyParticipantScoreInput!): UpdateLobbyParticipantScorePayload

  """Updates a Mosaic layout with the specified id for the current user."""
  updateDashboardViewMosaicLayout(input: UpdateDashboardViewMosaicLayoutInput!): UpdateDashboardViewMosaicLayoutPayload

  """Modifies multi-view content attributes."""
  updateMultiviewContentAttributes(input: UpdateMultiviewContentAttributesInput!): UpdateMultiviewContentAttributesPayload

  """
  updateOnboardingSkippedChannels updates skipped channel IDs during onboarding for a given user.
  """
  updateOnboardingSkippedChannels(input: UpdateOnboardingSkippedChannelsInput!): UpdateOnboardingSkippedChannelsPayload @deprecated(reason: "This feature is retired")

  """
  updateOrganizationMemberRole updates the role of an organization member (Twitch Developers).
  """
  updateOrganizationMemberRole(input: UpdateOrganizationMemberRoleInput!): UpdateOrganizationMemberRolePayload

  """
  updateOwnerChanletAttributes updates/creates a new set of owner chanlet attributes for a Channel.
  """
  updateOwnerChanletAttributes(input: UpdateOwnerChanletAttributesInput!): UpdateOwnerChanletAttributesPayload

  """updatePanel updates the data for a given panel."""
  updatePanel(input: UpdatePanelInput!): UpdatePanelPayload

  """
  Starts the process for associating a phone number to a twitch account. Requires sudo authentication.
  A one time password (valid for 10 minutes) will be sent via SMS to the phone
  number provided. The one time password will need to be verified via
  updatePhoneNumberConfirmation to complete the update.
  """
  updatePhoneNumber(input: UpdatePhoneNumberInput!): UpdatePhoneNumberPayload

  """
  Completes the process for associating a phone number to a twitch account. Requires sudo authentication.
  The one time password issued using updatePhoneNumber will be verified to make sure user contols the phone number.
  """
  updatePhoneNumberConfirmation(input: UpdatePhoneNumberConfirmationInput!): UpdatePhoneNumberConfirmationPayload

  """
  updatePrimeOfferStatus allows a user to update their status in respect to an offer. (e.g. UNSEEN, SEEN, CLAIMED).
  """
  updatePrimeOfferStatus(input: UpdatePrimeOfferStatusInput!): UpdatePrimeOfferStatusPayload

  """
  updatePrimeSettings allows the user to enable or disable chat notifications when spending a Prime Credit,
  and allows the user to set the type of Smilies (Turbos, Robots, or Monkeys) they want for Prime/Turbo Emoticons.
  """
  updatePrimeSettings(input: UpdatePrimeSettingsInput!): UpdatePrimeSettingsPayload

  """Update a user's raid settings."""
  updateRaidSettings(input: UpdateRaidSettingsInput!): UpdateRaidSettingsPayload

  """Updates an existing chatroom."""
  updateRoom(input: UpdateRoomInput!): UpdateRoomPayload @deprecated

  """
  Updates the room modes (slow mode, emotes only mode, etc.) for the room.
  """
  updateRoomModes(input: UpdateRoomModesInput!): UpdateRoomModesPayload @deprecated

  """Update's a user's room view for a chatroom."""
  updateRoomView(input: UpdateRoomViewInput!): UpdateRoomViewPayload @deprecated

  """Update a schedule segment."""
  updateScheduleSegment(input: UpdateScheduleSegmentInput!): UpdateScheduleSegmentPayload

  """
  UpdateSeenCreatorOnboardingContent updates the list of streamer onboarding content that a user has seen.
  """
  updateSeenCreatorOnboardingContent(input: UpdateSeenCreatorOnboardingContentInput!): UpdateSeenCreatorOnboardingContentPayload

  """updateSocialMedia updates an existing social media item for a Channel."""
  updateSocialMedia(input: UpdateSocialMediaInput!): UpdateSocialMediaPayload

  """
  updateSquadInvitePolicy allows a broadcaster to update their squad stream invite policy.
  """
  updateSquadInvitePolicy(input: UpdateSquadInvitePolicyInput!): UpdateSquadInvitePolicyPayload

  """
  updateSquadStream allows an owner of a squad stream to update the squad stream.
  """
  updateSquadStream(input: UpdateSquadStreamInput!): UpdateSquadStreamPayload

  """
  updateStucco allows a user to update a stucco (that is currently not active).
  """
  updateStucco(input: UpdateStuccoInput!): UpdateStuccoPayload

  """
  updateStuccoPack allows the updating of a channel's stucco pack. (activating stuccos).
  """
  updateStuccoPack(input: UpdateStuccoPackInput!): UpdateStuccoPackPayload

  """
  updateSubscriptionProduct allows a user to update their subscription product settings.
  """
  updateSubscriptionProduct(input: UpdateSubscriptionProductInput!): UpdateSubscriptionProductPayload

  """
  updateUser updates a user's displayname, description, email or delete a phone number.
  """
  updateUser(input: UpdateUserInput!): UpdateUserPayload

  """Updates a user's creator colors."""
  updateUserColors(input: UpdateUserColorsInput!): UpdateUserColorsPayload

  """Set a user's privacy preference for registration date."""
  updateUserCreateDateHidden(input: UpdateUserCreateDateHiddenInput!): UpdateUserCreateDateHiddenPayload

  """Set a user's directory hidden field."""
  updateUserDirectoryHidden(input: UpdateUserDirectoryHiddenInput!): UpdateUserDirectoryHiddenPayload

  """Set a user's email reuse field."""
  updateUserEmailReusable(input: UpdateUserEmailReusableInput!): UpdateUserEmailReusablePayload

  """
  updateUserIsEmailRevertSuccess sets/resets a user's Email revert success flag.
  """
  updateUserIsEmailRevertSuccess(input: UpdateUserIsEmailRevertSuccessInput!): UpdateUserIsEmailRevertSuccessPayload

  """Update a user's Prediction Settings."""
  updateUserPredictionSettings(input: UpdateUserPredictionSettingsInput!): UpdateUserPredictionSettingsPayload

  """
  updateUserSubscriptionSettings updates the subscription preferences for the authenticated user.
  """
  updateUserSubscriptionSettings(input: UpdateUserSubscriptionSettingsInput!): UpdateUserSubscriptionSettingsPayload

  """
  updateUserTeamMembership updates the team membership preferences for target user.
  """
  updateUserTeamMembership(input: UpdateUserTeamMembershipInput!): UpdateUserTeamMembershipPayload

  """
  updateUserVideoShelves adds/removes/reorders for a user's video shelves.
  """
  updateUserVideoShelves(input: UpdateUserVideoShelvesInput!): UpdateUserVideoShelvesPayload

  """
  updateUserViewedVideo updates a resume watching entry for a specified user and video.
  """
  updateUserViewedVideo(input: UpdateUserViewedVideoInput!): UpdateUserViewedVideoPayload

  """updateVideo updates a video identified by provided video ID."""
  updateVideo(input: UpdateVideoInput!): UpdateVideoPayload

  """
  updateVideoComment updates a video comment identified by provided comment ID.
  """
  updateVideoComment(input: UpdateVideoCommentInput!): UpdateVideoCommentPayload

  """
  updateVideoStreamSettings updates the broadcaster's video stream settings such as latency mode.
  """
  updateVideoStreamSettings(input: UpdateVideoStreamSettingsInput!): UpdateVideoStreamSettingsPayload

  """
  UpdateVideosViewability updates videos to being published or unpublished.
  """
  updateVideosViewability(input: UpdateVideosViewabilityInput!): UpdateVideosViewabilityPayload

  """
  Changes the user's visibility setting. This is an account-level setting that will cause the user's availability to
  appear differently to other users, despite what sessions are reporting. See the VisibilityInput enum for details on
  the effects of each value.
  
  Because this is an account-level setting, it should only be used in response to the user expressing clear intention
  to change their visibility. Setting a status for an individual session should be done using setSessionStatus.
  """
  updateVisibility(input: UpdateVisibilityInput!): UpdateVisibilityPayload

  """Updates Whisper settings for the authenticated user."""
  updateWhisperSettings(input: UpdateWhisperSettingsInput!): UpdateWhisperSettingsPayload

  """Updates a whisper thread."""
  updateWhisperThread(input: UpdateWhisperThreadInput!): UpdateWhisperThreadPayload

  """
  uploadCompetitionImage generates a url for a user to upload an image to for a competition.
  """
  uploadCompetitionImage(input: UploadCompetitionImageInput!): UploadCompetitionImagePayload

  """Uses a chat notification token."""
  useChatNotificationToken(input: UseChatNotificationTokenInput!): UseChatNotificationTokenPayload

  """
  validateVerificationCode validates a given code and sets the address to verified if it matches.
  """
  validateVerificationCode(input: ValidateVerificationCodeInput!): ValidateVerificationCodePayload

  """verifyContactMethod verifies a user contact method from an opaque ID."""
  verifyContactMethod(input: VerifyContactMethodInput!): VerifyContactMethodPayload

  """
  verifyOneTimePassword verifies a one time password for a user for authentication. Requires sudo authentication.
  """
  verifyOneTimePassword(input: VerifyOneTimePasswordInput!): VerifyOneTimePasswordPayload

  """
  verifyRewardedVideoEligibilityCaptcha verifies a users captcha with the rewarded video system.
  """
  verifyRewardedVideoEligibilityCaptcha(input: VerifyRewardedVideoEligibilityCaptchaInput!): VerifyRewardedVideoEligibilityCaptchaPayload

  """
  viewedNotifications updates when the authenticated user last saw onsite notifications.
  """
  viewedNotifications: ViewedNotificationsPayload

  """
  visitStreamManager updates when the authenticated user visits their stream manager for the first time.
  """
  visitStreamManager(input: VisitStreamManagerInput!): VisitStreamManagerPayload

  """Casts a vote for a specific choice in an ad poll."""
  voteInAdPoll(input: VoteInAdPollInput!): VoteInAdPollPayload

  """Casts a vote for a specific choice in a poll."""
  voteInPoll(input: VoteInPollInput!): VoteInPollPayload

  """Casts a vote for a specific choice in a poll, by index and channelID."""
  voteInPollByChoiceIndex(input: VoteInPollByChoiceIndexInput!): VoteInPollByChoiceIndexPayload
}

"""
GDPR cookie vendors for vendors that dont support TCF strings, for a user.
"""
type NonTCFCookieVendor {
  """User content status for each vendor."""
  consentStatus: ConsentStatus!

  """If it’s an advertising, analytics, or essential cookie."""
  cookieVendorType: CookieVendorType!

  """
  A flag that shows if the consent is given by the user or by consent service as default value.
  """
  hasUserSetConsent: Boolean!

  """A flag that shows if the vendor should be visible to management page."""
  isVisible: Boolean!

  """Vendor name."""
  name: VendorName!

  """Url to the Vendor's privacy policy."""
  policyURL: String!
}

"""Information about a registered developer OAuth application."""
type OAuthApp {
  """The category that describes the app's type."""
  category: OAuthAppCategory

  """The timestamp when the app was created."""
  createdAt: Time!

  """
  The ID of the app. It is the value of the `Client-ID` header when the app makes API requests.
  """
  id: ID!

  """The name of the app."""
  name: String!

  """
  The user-provided description of the app's type. Used if `Category` is Other.
  """
  otherDescription: String

  """Owner is the user that owns this app."""
  owner: User

  """The URI to which users should be redirected after authorizing the app."""
  redirectURI: String!

  """The client secret of the app."""
  secret: String!

  """The timestamp when the app was last updated."""
  updatedAt: Time!

  """Whether the app's OAuth tokens expire."""
  willTokensExpire: Boolean!
}

"""Possible categories of developer apps."""
enum OAuthAppCategory {
  """Game integration category."""
  GAME_INTEGRATION

  """Website integration category."""
  WEBSITE_INTEGRATION

  """Application integration category."""
  APPLICATION_INTEGRATION

  """Browser extension category."""
  BROWSER_EXTENSION

  """Broadcaster suite category."""
  BROADCASTER_SUITE

  """Chat bot category."""
  CHAT_BOT

  """Giveaway loyalty tool category."""
  GIVEAWAY_LOYALTY_TOOL

  """Analytics tool category."""
  ANALYTICS_TOOL

  """Category for when the other categories do not describe."""
  OTHER
}

"""A list of applications."""
type OAuthAppConnection {
  """The applications."""
  edges: [OAuthAppEdge!]!

  """Pagination."""
  pageInfo: PageInfo!
}

"""A broadcaster user with cursor."""
type OAuthAppEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the app for the current edge."""
  node: OAuthApp!
}

"""
OEmbed is a universal spec converted to GraphQL from http://oembed.com/.
"""
interface OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int

  """
  The inputURL is the URL that we are trying to resolve via oEmbed.  It is not part
  of the official spec, but GQL implementations practically need to use it.
  """
  inputURL: String!
  providerName: String
  providerURL: String

  """
  The description of thumbnail from the oembed spec fits with an optional thumbnail
  type with required parameters.
  """
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
}

"""Offer describes something that is purchasable."""
type Offer {
  """Details of the user's eligibility to purchase the Offer."""
  eligibility: OfferEligibility!

  """
  The time at which this Offer ceases to be valid for purchase. If null, this Offer will never expire.
  """
  endAt: Time

  """
  The type of the gift offer (will be omitted if the Offer is not a gift).
  """
  giftType: GiftType

  """Unique identifier for an Offer."""
  id: ID!

  """
  A listing describing the charge model and cancellation policy for the Offer.
  """
  listing: OfferListing

  """The platform on which the Offer is eligible for purchase."""
  platform: OfferPlatform!

  """
  A Promotion object describes the promotion to be applied on an Offer (if any).
  """
  promotion: OfferPromotion

  """Quantity is the configured purchase quantity restrictions."""
  quantity: Range

  """The authenticated user's relationship with the Offer."""
  self: OfferSelfEdge

  """The time at which this Offer becomes valid for purchase."""
  startAt: Time!

  """
  Tag bindings provide static and dynamic bindings of the attributes on an Offer.
  """
  tagBindings: [OfferTagBinding!]!

  """Tenant product line registry to which this Offer belongs."""
  tplr: String!
}

"""Contains an offer ID and offer status."""
input OfferAndStatus {
  """Unique Identifier for an offer."""
  offerID: ID!

  """The status to set the offer to for the specified user."""
  status: String!
}

"""Deliver method type for Prime Offers entitlements."""
enum OfferDeliveryMethod {
  """
  The entitlement will be delivered as a claim code, which can be used to get the entitlement.
  """
  CLAIM_CODE

  """The entitlement will be directly delivered."""
  DIRECT_ENTITLEMENT

  """
  The entitlement will be directly delivered and a Twitch account is not needed for the offer.
  """
  SES_ENTITLEMENT

  """Misspelling of EXTERNAL_OFFER."""
  EXTERNAL @deprecated(reason: "Use EXTERNAL_OFFER instead")

  """The entitlement will be delivered via external means."""
  EXTERNAL_OFFER
}

"""OfferEligibility describes user's eligibility to purchase an Offer."""
type OfferEligibility {
  """
  If the user is eligible for the Offer, then this is set to the
  time at which the user's benefits would expire if the
  Offer is purchased. If null, the benefits never expire.
  """
  benefitsEndAt: Time

  """
  If the user is eligible for the Offer, then this is set to the
  time at which the user's benefits would become available if the
  Offer is purchased.
  """
  benefitsStartAt: Time

  """A boolean that is true when the user is eligible for the Offer."""
  isEligible: Boolean!

  """
  Allows tenants to override the maximum purchasable quantity for an offer
  within a checkout session (used in purchase velocity cases).
  """
  maxQuantityOverride: Int

  """Provides extra contextual details for the type of purchase."""
  purchaseType: OfferPurchaseType!

  """
  If the user is ineligible for the Offer, then this code is set
  as the reason why the user is ineligible.
  """
  reasonCode: OfferIneligibilityReasonCode
}

"""OfferIneligibilityReasonCode indicates why a user isn't eligible."""
enum OfferIneligibilityReasonCode {
  """Not eligible because the user has already purchased this offer."""
  ALREADY_PURCHASED

  """
  Not eligible because something about the transaction could not be verified.
  """
  COULD_NOT_VERIFY

  """Offer would exceed user's max token balance."""
  MAX_TOKEN_BALANCE

  """No ineligibility reason was given."""
  NONE

  """The reason for ineligibility could not be resolved."""
  OTHER
}

"""OfferListing defines the charge model for a given listing."""
type OfferListing {
  """
  The conditions around a user's cancellation of their purchase (e.g. refund policy).
  """
  cancellationPolicy: CancellationPolicyType!

  """FIAT/non-FIAT based charge model OR 3P managed SKU."""
  chargeModel: ChargeModel!
}

"""The platform on which the Offer is valid."""
enum OfferPlatform {
  """The web site."""
  WEB

  """The iOS app."""
  IOS

  """The Android app."""
  ANDROID

  """The desktop app."""
  DESKTOP
}

"""Promotion is a modifier to an Offer."""
type OfferPromotion {
  """End time of a promotion (empty if evergreen promotion)."""
  endAt: Time

  """Unique identifier for a Promotion."""
  id: ID!

  """The OfferListing associated with this Promotion."""
  listing: OfferListing! @deprecated(reason: "No longer used, currently left for backwards compatibility")

  """Unique name for a Promotion."""
  name: String!

  """
  Describes the priority of the Promotion (the higher the priorty, the more important the promo).
  """
  priority: Int!

  """Describe the Promotions metadata to display to the client."""
  promoDisplay: PromotionDisplay!

  """Start time of a promotion."""
  startAt: Time!
}

"""
OfferPUrchaseType provides extra contextual details for the type of purchase.
"""
enum OfferPurchaseType {
  """This offer is a default, standard purchase."""
  DEFAULT_PURCHASE

  """
  This offer being purchased will be a tier upgrade from their current active tier.
  """
  UPGRADE_RECURRING_SUB_TIER

  """
  This offer being purchased will be a tier downgrade from their current active tier.
  """
  DOWNGRADE_RECURRING_SUB_TIER

  """This offer being purchased is future-dated."""
  FUTURE_PURCHASE
}

"""The authenticated user's relationship with the offer."""
type OfferSelfEdge {
  """
  Returns any fraud-related checkout actions that the client must invoke.
  """
  checkoutActions(quantity: Int!, paymentSession: PaymentSession): [CheckoutAction!]

  """Configs that initiate the user's checkout flow for this Offer."""
  checkoutConfiguration: CheckoutConfiguration

  """
  Provides a list of eligible payment methods that the user can select for this offer.
  """
  eligiblePaymentMethods: [EligiblePaymentMethod!]
}

"""
Enum indicating the current live state of a given Prime Gaming content offer.
"""
enum OfferState {
  """The offer is no longer live and has expired."""
  EXPIRED

  """The offer is currently live."""
  LIVE

  """The offer will be live in the future."""
  FUTURE
}

"""Enum indicating the visual status of the offer to the user."""
enum OfferStatus {
  """The user has not seen this offer card on the Crown."""
  UNSEEN

  """The user has seen this offer card on the Crown."""
  SEEN

  """The user has claimed this offer."""
  CLAIMED

  """
  The user has dismissed this offer card from the Crown and can no longer see it.
  """
  DISMISSED

  """
  A previous SEEN or DISMISSED status has been overridden to allow the offer card to be visible on the Crown.
  """
  OVERRIDDEN

  """The user's offer status is in a errored state."""
  ERROR
}

"""OfferTagBinding defines a key-value pair."""
type OfferTagBinding {
  """The key of the tag."""
  key: String!

  """The value of the tag."""
  value: String!
}

"""OfferTagBindingInput defines a key-value pair."""
input OfferTagBindingInput {
  """The key of the tag."""
  key: String!

  """The value of the tag."""
  value: String!
}

"""Current state of the user in the onboarding process."""
type Onboarding {
  """
  Retrieves a list of streams that have been selected for onboarding based on a user's followed games.
  `first` is the number of streams PER FOLLOWED GAME to fetch.
  `locale` is a language code that will filter streams by if there are viewers
  with that language code (ex. "en-US", "es-ES", or "de-AT").
  `languages` is list of language codes that will be used to filter streams by the broadcaster language. (ex. [EN, KO]).
  `games` are a list of game ids that would replace the user's followed games for fetching the streams.
  """
  onboardingStreams(first: Int = 3, locale: String, languages: [Language!], games: [String!]): [Stream] @deprecated(reason: "This feature has been sunset.")

  """List of channel IDs skipped by a user during onboarding."""
  skippedChannelIDs: [ID!] @deprecated(reason: "This feature is retired")
}

type OnsiteNotification {
  """Actions of the notification."""
  actions: [OnsiteNotificationAction!]!

  """Body of the notification in Markdown format."""
  body: String!

  """Category of the notification (only for dart ones)."""
  category: String

  """When this notification was created."""
  createdAt: Time!

  """List of users that created this notification."""
  creators: [User]!

  """
  Destination type to route users to when they interact with the notification on non-web clients.
  Values include Homepage, ChannelPage, NotificationSettingsPage, and BroadcasterDashboard.
  """
  destinationType: String

  """Determines where the notification will be displayed at front end."""
  displayType: OnsiteNotificationDisplayType!

  """
  Optional extra notification content.
  When type is "vodupload", extra is Video.
  When type is "hotclipfollower", extra is Clip.
  When type is "hotclip", extra is Clip.
  When type is "subgiftreceived", extra is User.
  When type is "vodcomment", extra is VideoComment.
  When type is "vodcommentmod", extra is VideoComment.
  When type is "vodcommentreply", extra is VideoComment.
  When destination is "ChannelPage", extra is User.
  When destination is "BrowseGame", extra is Game.
  When destination is "ExternalLink", extra is OnsiteNotificationExternalLink.
  """
  extra: OnsiteNotificationContent

  """ID of the notification."""
  id: ID!

  """Whether this notification is read."""
  isRead: Boolean!

  """Type of onsite render style."""
  renderStyle: OnsiteNotificationRenderStyle!

  """A URL to a thumbnail image."""
  thumbnailURL: String!

  """Type of notification."""
  type: String!

  """When notification was last updated."""
  updatedAt: Time!
}

type OnsiteNotificationAction {
  """Body of the notification action in plain text."""
  body: String!

  """ID of the action."""
  id: ID!

  """Label of the action."""
  label: String!

  """ID of the modal that will open on click, if it is a modal CTA."""
  modalID: ID!

  """Type of the notification action."""
  type: String!

  """URL of the notification action."""
  url: String!
}

type OnsiteNotificationConnection {
  """List of notifications."""
  edges: [OnsiteNotificationEdge!]

  """Information about pagination in this connection."""
  pageInfo: PageInfo

  """Notifications summary."""
  summary: OnsiteNotificationsSummary
}

"""Extra onsite notification content."""
union OnsiteNotificationContent = Clip | Game | OnsiteNotificationExternalLink | User | Video | VideoComment

"""Determines where the notification will be displayed at front end."""
enum OnsiteNotificationDisplayType {
  """Notifications that will be displayed in the "My Twitch" tab."""
  VIEWER

  """Notifications that will be displayed in the "My Channel" tab."""
  CREATOR
}

type OnsiteNotificationEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor

  """The notification."""
  node: OnsiteNotification!
}

"""
Extra onsite notification content returned when the notification links to an external site.
"""
type OnsiteNotificationExternalLink {
  """The link that the notification opens when clicked."""
  url: String!
}

"""Used to determine how to render the onsite notification."""
enum OnsiteNotificationRenderStyle {
  """The default render style with no buttons and a single click CTA."""
  DEFAULT

  """Rendered with two CTA buttons."""
  TWO_BUTTONS
}

"""
Capabilities that a mobile client has for displaying onsite notifications.
"""
enum OnsiteNotificationsCapability {
  """Mobile destination type Homepage."""
  HOMEPAGE

  """Mobile destination type ChannelPage."""
  CHANNEL_PAGE

  """Mobile destination type NotificationSettingsPage."""
  NOTIFICATION_SETTINGS_PAGE

  """Mobile destination type BroadcasterDashboard."""
  BROADCASTER_DASHBOARD

  """Mobile destination type BrowseGame."""
  BROWSE_GAME

  """Mobile destination type ExternalLink."""
  EXTERNAL_LINK

  """Mobile destination type WebOnly."""
  WEB_ONLY

  """Mobile destination type WhisperThread."""
  WHISPER_THREAD

  """Mobile destination type FriendRequest."""
  FRIEND_REQUEST

  """Pushy notification type hotclip."""
  HOT_CLIP

  """Pushy notification type hotclipfollower."""
  HOT_CLIP_FOLLOWER

  """Pushy notification type vodupload."""
  VOD_UPLOAD

  """Pushy notification type vodcomment."""
  VOD_COMMENT

  """Pushy notification type vodcommentmod."""
  VOD_COMMENT_MOD

  """Pushy notification type vodcommentreply."""
  VOD_COMMENT_REPLY

  """Pushy notification type subgiftreceived."""
  SUB_GIFT_RECEIVED

  """Pushy notification type dropsavailable."""
  DROPS_AVAILABLE

  """Pushy notification type communityguidelineschange."""
  COMMUNITY_GUIDELINES_CHANGE

  """Pushy notification type smartannouncement."""
  SMART_ANNOUNCEMENT

  """Pushy notification type affiliateinvite."""
  AFFILIATE_INVITE
}

type OnsiteNotificationsSummary {
  """Unread summary for creator display type."""
  creatorUnreadSummary: OnsiteNotificationsUnreadSummary

  """Last time notifications were seen."""
  lastSeenAt: Time

  """Number of unseen notifications."""
  unseenCount: Int!

  """Unread summary for viewer display type."""
  viewerUnreadSummary: OnsiteNotificationsUnreadSummary
}

"""Contains summary for unread infomation."""
type OnsiteNotificationsUnreadSummary {
  """Last time user marked all as read."""
  lastReadAllAt: Time

  """Number of unread notifications."""
  unreadCount: Int!
}

input OrderPanelsInput {
  ids: [ID!]!
}

type OrderPanelsPayload {
  """List of panels in their new order."""
  panels: [Panel]
}

"""A developer organization."""
type Organization {
  """The bounty board campaigns that the company owns."""
  bountyCampaigns(campaignID: ID, status: BountyCampaignStatus): BountyCampaignConnection

  """The brand portal settings for the company."""
  brandPortalSettings: BrandPortalSettings

  """ID of the Company in the CurseForge Infrastructure."""
  curseCompanyID: ID

  """Drop Campaigns developed by the organization."""
  dropCampaigns: [DropCampaign!] @deprecated(reason: "Use Organization.drops instead")

  """Drop 2.0 Campaigns and Benefits configured for the organization."""
  drops: OrganizationDrops!

  """
  The estimated viewer reach for the pool of broadcasters this company is considering targeting.
  """
  estimatedBroadcasterViewerReach(gameNames: [String!]!, targetAllBroadcasters: Boolean!, targetVarietyBroadcasters: Boolean!, streamLengthSeconds: Int, targetAllCountries: Boolean = false, targetAllGames: Boolean = false, countries: [String!] = []): BroadcasterViewerReach

  """
  The games associated with the company. Optionally include games that a company can use for Bounty Board
  campaigns (ie. "Just Chatting" for trailer campaigns).
  """
  games(includeBountyBoardGames: Boolean = false): [Game!]

  """The company's unique identifier."""
  id: ID!

  """List of pending invites."""
  invites(first: Int = 10, after: Cursor): OrganizationInviteConnection

  """Legacy Companies need to agree to the Drops Terms."""
  isCampaignsEnabled: Boolean!

  """Legacy Companies are required to sign the Contract."""
  isContractSigned: Boolean!

  """
  Indicates if the Company is a Legacy Company from the first iteration of the DevSite.
  """
  isLegacy: Boolean!

  """A list of rbac users who are apart of an organization."""
  members(first: Int = 10, after: Cursor, input: OrganizationMembersInput): OrganizationMemberConnection

  """The human-readable name of the company."""
  name: String!

  """Attributes related to the current user."""
  self: OrganizationSelfEdge

  """Indicates if company is a developer, publisher or other."""
  type: OrganizationType!

  """The Company URL for their Corporate Website."""
  url: String!
}

"""Status of company applications."""
enum OrganizationAppilcationStatus {
  """Application is pending."""
  PENDING

  """Application has been rejected."""
  REJECTED

  """Application has been approved."""
  APPROVED

  """Application has been deleted."""
  DELETED
}

"""
OrganizationApplication is the application for requesting an organization be added to Twitch Developer Organizations.
"""
type OrganizationApplication {
  """
  Email of the person creating the application.
  Deprecated as we are no longer collecting contact email. Using TwitchID and Dart to send notifications instead.
  """
  contactEmail: String @deprecated(reason: "No longer collecting contact email.")

  """The name of applying organization."""
  organizationName: String!

  """Current status of the company application."""
  status: OrganizationAppilcationStatus!
}

"""
OrganizationDrop links organizations to the campaigns it has configured
and the benefits that it has created.
"""
type OrganizationDrops {
  """
  The benefits created for this organization that can be added to the organization's drops.
  """
  benefits: [DropBenefit!]

  """The campaigns configued for this organizaiton."""
  campaigns: [DropCampaign!]
}

"""An invitation to join a developer organization under a given role."""
type OrganizationInvite {
  """When the invitation was created."""
  createdAt: Time!

  """The date and time the invite will expire."""
  expiresAt: Time!

  """The invites's unique identifier."""
  id: ID!

  """User the invitation if for."""
  invitee: User

  """User who created the invitation."""
  inviter: User

  """ID of the organization the invitation is for."""
  organizationID: ID!

  """Name of the organization the invitation is for."""
  organizationName: String!

  """Role the invitation is for."""
  role: OrganizationMemberRole!
}

"""Paginated list of organization invites in an organization."""
type OrganizationInviteConnection {
  """The elements of the paginated list."""
  edges: [OrganizationInviteEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!

  """The total number of Organization invites."""
  totalCount: Int!
}

"""
An element in a paginated list of organization invites.
Contains metadata about the organization invites.
"""
type OrganizationInviteEdge {
  """An opaque cursor identifying the edge's position in the paginted list."""
  cursor: Cursor!

  """The organization invite."""
  node: OrganizationInvite!
}

"""Paginated list of organization invites for in a user."""
type OrganizationInviteUserConnection {
  """The elements of the paginated list."""
  edges: [OrganizationInviteEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!

  """The total number of Organization invites."""
  totalCount: Int!

  """
  Whether or not the user is under the limit of allowed organization memberships.
  """
  isWithinOrganizationMembershipLimit: Boolean
}

"""A RBAC user."""
type OrganizationMember {
  """Users email."""
  email: String!

  """Users first name."""
  firstName: String!

  """Twitch user id."""
  id: ID!

  """Users last name."""
  lastName: String!

  """Users role."""
  role: OrganizationMemberRole!

  """Users title."""
  title: String!

  """The Twitch user associated with the RBAC user."""
  user: User
}

"""A paginated list of organization member relationships."""
type OrganizationMemberConnection {
  """The elements of the paginated list."""
  edges: [OrganizationMemberEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!

  """The total number of Organization members."""
  totalCount: Int!
}

"""
An element in a paginated list of organization member relationships.
Contains metadata about the follow relationship between two users.
"""
type OrganizationMemberEdge {
  """An opaque cursor identifying the edge's position in the paginted list."""
  cursor: Cursor!

  """Date user joined organization."""
  joinedAt: Time!

  """The user who is organization members."""
  node: OrganizationMember!
}

"""Role for an organization member."""
enum OrganizationMemberRole {
  """Adiministrator role."""
  ADMINISTRATOR

  """Developer role."""
  DEVELOPER

  """Manager role."""
  MANAGER

  """Marketer role."""
  MARKETER

  """Owner Role."""
  OWNER

  """Billing Manager Role."""
  BILLING_MANAGER

  """Shadow Account Role."""
  SHADOW_ACCOUNT
}

"""Parameters for filtering OrganizationMembers."""
input OrganizationMembersInput {
  """Filter members with this role."""
  role: OrganizationMemberRole
}

"""The relationship between the authenticated user and a game."""
type OrganizationSelfEdge {
  """
  Whether or not the current user is able to add another to the organization.
  """
  canAddMember: Boolean!

  """Whether or not the current user is able to leave the organization."""
  canLeaveOrganization: Boolean!

  """
  Whether or not the current user is able to remove a member from the organization.
  """
  canRemoveMember: Boolean!

  """Date user joined organization."""
  joinedAt: Time!

  """The current users role in the organization."""
  role: OrganizationMemberRole!
}

"""Type of work an organization does."""
enum OrganizationType {
  """Organization that developes games."""
  GAME_DEVELOPER

  """Organization that publishes games."""
  GAME_PUBLISHER

  """Organization that does other work."""
  OTHER

  """Organization that works in brands/advertsing."""
  BRANDS_ADVERTISING

  """Organization that works with broadcaster tools."""
  BROADCASTER_TOOLS
}

"""Friend requests sent from this user to other users."""
type OutgoingFriendRequestConnection {
  """The friend request elements of this list."""
  edges: [OutgoingFriendRequestEdge!]

  """Information about this page."""
  pageInfo: PageInfo!

  """The total number of outgoing friend requests."""
  totalCount: Int!
}

"""A friend request sent from this user to another user."""
type OutgoingFriendRequestEdge {
  """The time at which the friend request was sent."""
  createdAt: Time!

  """
  An opaque cursor identifying the edge's position in the paginated list.
  """
  cursor: Cursor!

  """The user to whom the friend request was sent."""
  node: User
}

"""Contains Overwatch League Team preferences."""
type OverwatchLeagueTeamPreference {
  """Set of available teams for selection."""
  availableTeamsSet: [OverwatchTeamPreferenceOption!]

  """Unique identifier for this set of Overwatch team preferences."""
  id: ID!

  """The preferred team."""
  selectedTeam: OverwatchTeamPreferenceOption
}

"""Moment Details specific to the overwatch game."""
type OverwatchMomentDetails {
  """One of "game_start" or "hero_change"."""
  event: String!

  """The hero the broadcaster is playing."""
  heroName: String!

  """The role the broadcaster is playing."""
  role: String!
}

"""Contains an Overwatch team option to choose as the preferred team."""
type OverwatchTeamPreferenceOption {
  """Unique identifier for this Overwatch team preference."""
  id: ID!

  """The rewards associated with this team preference."""
  rewards: [TournamentReward!]

  """The name of the team."""
  teamName: String!
}

"""
OwnerChanletAttributes store configuration flags for child chanlets the channel owns.
"""
type OwnerChanletAttributes {
  """Whether to show the child chanlets."""
  isChanletFeatureEnabled: Boolean!
}

"""
PageInfo is a special field which contains information about the page,
specifically the cursors which the page starts and ends, and whether or
not the client can forward-paginate or backward-paginate.

This is part of the Relay Cursor Connections Specification:
https://facebook.github.io/relay/graphql/connections.htm.
"""
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

"""
Data about a paid upgrade for a subscription.
ie. a user upgrades a 1-month gift to a recurring subscription.
"""
type PaidUpgrade {
  """The id of the paid upgrade purchase. Used to cancel the paid upgrade."""
  originID: ID!

  """The formatted price of the paid upgrade in USD."""
  price: String! @deprecated(reason: "Transitioning to priceInfo instead")

  """
  PriceInfo holds the paid upgrade's pricing information such as currency, cost, and tax information.
  """
  priceInfo(taxCountry: String): PriceInfo!

  """The date the paid upgrade begins."""
  startsAt: Time!

  """Tier of upgraded product."""
  tier: String!
}

"""Panel is information about a single info panel for a channel."""
interface Panel {
  """id is a unique identifier for the panel."""
  id: ID!

  """type is the kind of panel."""
  type: PanelType!
}

"""The required configuration to activate a panel extension."""
input PanelActivationInput {
  """The slot name of where the component extension should be displayed."""
  slot: String!
}

"""PanelType is the kind of panel."""
enum PanelType {
  """
  DEFAULT panels contain one or more of the content values in `Panel` to display.
  """
  DEFAULT

  """EXTENSION panels are placeholders for extension content."""
  EXTENSION
}

"""
PanelView holds the view configuration of an extension if the panel anchor is supported.
"""
type PanelView implements ExtensionView {
  """
  Specifies whether or not the extension has the ability to link to external websites.
  """
  canLinkExternalContent: Boolean!

  """The extension developer configured height of the panel extension."""
  height: Int!

  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
PanelViewInput holds the view configuration of an extension if the panel anchor is supported.
"""
input PanelViewInput {
  """The extension developer configured height of the panel extension."""
  height: Int!

  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""DEPRECATED."""
type Partnership {
  isPartner: Boolean @deprecated
}

"""PartnershipApplication is a submitted partnership application."""
type PartnershipApplication {
  """
  ID of the user that submitted the application,
  provided purely for the convenience of invalidating GraphQL client caches.
  """
  id: ID!

  """
  A submitted application currently can only be unresolved or resolved:
  
  - A null resolvedAt timestamp means that the application is unresolved and may be under review.
  
  - A non-null resolvedAt means that the application has been resolved, either approved or rejected.
    A user with an approved application may now start the partnership on-boarding flow.
  """
  resolvedAt: Time
}

"""PasswordStatus determines the current state of the users password."""
enum PasswordStatus {
  """The users password has never been evaluated."""
  NOT_EVALUATED

  """The users password meets requirements."""
  VALID

  """The users password does not meet requirements."""
  INVALID

  """Unknown password status."""
  UNKNOWN
}

"""Associated metrics for the "Path to Affiliate" quest."""
type PathToAffiliate {
  """Average viewers needed to complete the quest."""
  averageViewers: QuestGoalFloat

  """Image URL for the quest's badge."""
  badgeURL: String

  """Time that this quest was completed."""
  completedAt: Time

  """
  Number of followers needed to complete the quest. Evaluated at a 6 month
  period. All other metrics are evaluated in 30 day periods.
  """
  followers: QuestGoalInt

  """Number of hours streamed needed to complete the quest."""
  hoursStreamed: QuestGoalFloat

  """Number of unique days needed to complete the quest."""
  uniqueDaysStreamed: QuestGoalInt

  """Current state of the user's affiliate invitation."""
  affiliateInvitationStatus: AffiliateInvitationStatus
}

"""Associated metrics for the "Path to Partner" quest."""
type PathToPartner {
  """Average viewers needed to complete the quest."""
  averageViewers: QuestGoalFloat

  """Image URL for the quest's badge."""
  badgeURL: String

  """Time that this quest was completed."""
  completedAt: Time

  """Number of hours streamed needed to complete the quest."""
  hoursStreamed: QuestGoalFloat

  """Time period that's being evaluated for the metrics/goals."""
  questEvaluationInterval: QuestEvaluationInterval

  """Number of unique days needed to complete the quest."""
  uniqueDaysStreamed: QuestGoalInt
}

"""
Payout Status is the payout status of the creator for all non-earnings related issues.
"""
type PayableStatus {
  """Whether or not the user is able to be paid out."""
  isPayable: Boolean!
}

"""Types of credit cards supported."""
enum PaymentCardType {
  """Visa."""
  VISA

  """Mastercard."""
  MASTERCARD

  """American Express."""
  AMERICAN_EXPRESS

  """Discover."""
  DISCOVER
}

"""
A monthly rollup of metrics that are relevant to incentive-based contracts for
some partnered streamers.
"""
type PaymentIncentiveMetricsRollup {
  """
  A measure of how much advertising time broadcasters have during their live
  streams.
  """
  advertisingDensity: Float!

  """The number of live hours the user streamed for the month."""
  liveHoursBroadcast: Float!

  """The number of live minutes watched for the month."""
  liveMinutesWatched: Float!

  """
  The start time for the monthly rollup. These times are in the Pacific Time
  Zone and the monthly rollups begin in this time zone. Rather than
  converting to local time, clients should inform end users of this timing
  quirk and perform custom parsing on these values to show the current year
  and month in Pacific Time.
  """
  timestamp: Time

  """The number of VOD minutes watched the user has for the month."""
  vodMinutesWatched: Float!
}

"""Payment instrument used through the payment provider."""
enum PaymentInstrumentType {
  """Credit or debit card."""
  CREDIT_CARD

  """Pay with Amazon."""
  AMAZON

  """Pay with Paypal."""
  PAYPAL

  """Pay with Google In-App Billing."""
  GOOGLE_IAB

  """Pay with Apple In-App Purchase."""
  APPLE_IAP

  """Xsolla only."""
  SKRILL

  """Xsolla only."""
  YANDEX

  """Xsolla only."""
  WEBMONEY

  """Xsolla default."""
  UNKNOWN

  """Pay with Wallet."""
  WALLET

  """Pay with bank account."""
  DIRECT_DEBIT
}

"""
Type of payment method a user has used to buy products on Twitch, such as subs.
"""
type PaymentMethod {
  """
  Country (ISO-3166) associated to the billing info for the customer's payment method.
  """
  billingCountry: String

  """Email associated with customer's Amazon/Paypal account."""
  billingEmail: String

  """If payment type is card, then the type of card used is shown here."""
  cardType: PaymentCardType

  """ID of the payment method that can be referenced by other systems."""
  chargeInstrumentID: ID!

  """Credit card expiration month, if paymentType is CREDIT_CARD."""
  expirationMonth: Int

  """Credit card expiration year, if paymentType is CREDIT_CARD."""
  expirationYear: Int

  """
  External payment method ID (the ID recorded by the payment provider)
  We can guarantee its uniqueness since it is external from our systems.
  """
  extMethodID: ID

  """Whether or not payment method has restrictions."""
  isRestricted: Boolean!

  """Credit card last four digits, if paymentType is CREDIT_CARD."""
  lastFour: String

  """The payment scheme used by this payment method."""
  paymentScheme: PaymentScheme

  """Payment type used via the payment provider."""
  paymentType: PaymentInstrumentType!

  """One of the payment providers that Twitch currently supports."""
  provider: PaymentProvider!

  """List of purchase profiles associated with this payment method."""
  purchaseProfiles: [PurchaseProfile!]

  """
  List of recurring payments associated with this payment method.
  New schema to eventually replace purchase profiles.
  """
  recurringPaymentDetails: [RecurringPaymentDetail!]
}

"""The list of availability statuses for a payment method."""
enum PaymentMethodAvailabilityStatus {
  """Available status."""
  AVAILABLE

  """Degraded status."""
  DEGRADED

  """Full outage status."""
  FULL_OUTAGE
}

"""Type of payment providers."""
enum PaymentProvider {
  """Unknown payment provider."""
  UNKNOWN

  """
  (Deprecated) Paypal payment provider now a payment method provided by Recurly.
  """
  PAYPAL

  """(Deprecated) Paypal payment provider."""
  PAYPAL_RT

  """
  Recurly payment provider, allows payments with credit card, amazon, paypal.
  """
  RECURLY

  """
  Xsolla payment provider, usually provides Iframe for users to go through checkout process.
  """
  XSOLLA

  """
  (Deprecated) Xsolla payment provider, usually provides Iframe for users to go through checkout process.
  """
  XSOLLA_V3

  """Zuora payment provider, supports credit card payments."""
  ZUORA

  """Twitch Prime used to buy product on Twitch."""
  PRIME

  """Google In-App Billing, for Android transactions."""
  GOOGLE_IAB

  """Apple In-App Purchases for iOS transactions."""
  APPLE_IAP

  """Sub tokens, which can be redeemed for channel subscriptions."""
  SUB_TOKEN
}

type PaymentProviderConfigs {
  """
  Configs to initiate Recurly library for the user for purchase checkout or payment method update.
  """
  recurly: RecurlyConfigs!

  """
  Xsolla configs include the iframe URL for purchase checkout or payment method update.
  """
  xsolla: XsollaConfigs!

  """
  Configs for initiating Zuora credit card payments or payment method update.
  """
  zuora: ZuoraConfigs!
}

"""The payment scheme supported."""
enum PaymentScheme {
  """SEPA."""
  SEPA

  """BACS."""
  BACS
}

"""Inputs for PaymentSession."""
input PaymentSession {
  """Payment's Tracking Checkout ID."""
  checkoutSessionID: ID

  """User's device ID."""
  deviceID: ID

  """Twilight's storage device ID."""
  localStorageDeviceID: ID

  """Offer Session ID."""
  offerSessionID: ID

  """Twilight's Page Session ID."""
  pageSessionID: ID

  """Twilight's Tab Session ID."""
  tabSessionID: ID
}

"""
There are legacy and new data sources that contain similar payment transaction data. This type aims to merge several
data sources into one to expose a consistent payment history for each Twitch user.
"""
type PaymentTransaction {
  """Currency for the price."""
  currency: String

  """Price in smallest subunit for the currency, such as 499."""
  grossAmount: Int

  """The divisor used to derive the gross amount."""
  grossAmountDivisor: Int

  """Payment ID such as PPT321281 or POPT3278183712."""
  id: ID!

  """
  Whether this payment transaction was made to purchase a gift for someone else or not.
  """
  isGift: Boolean!

  """The payment method that was used to generate this payment transaction."""
  paymentMethod: PaymentMethod!

  """Payment transaction purchased product details."""
  product: PaymentTransactionProduct!

  """PurchaseOrderID for the payment."""
  purchaseOrderID: ID

  """Time the purchase payment was recognized at."""
  purchasedAt: Time!

  """Quantity of the purchase."""
  quantity: Int!

  """
  The recipient Twitch user of the product purchased by the payment transaction, if applicable.
  """
  recipient: User
}

"""A paginated list of payment transactions, and its metadata."""
type PaymentTransactionConnection {
  """The list of payment transactions on this page."""
  edges: [PaymentTransactionEdge!]

  """
  The payment date of the earliest PaymentTransaction among all possible pages.
  """
  firstPurchasedAt: Time

  """
  The payment date of the latest PaymentTransaction among all possible pages.
  """
  lastPurchasedAt: Time

  """Information about this page of payment transactions."""
  pageInfo: PageInfo!

  """The total number of payment transactions in the overall collection."""
  totalCount: Int
}

"""
Filter and sorting options for querying all transactions for a Twitch purchaser.
"""
input PaymentTransactionConnectionCriteriaInput {
  """Only show transactions purchased after this date."""
  purchasedAfter: Time

  """Only show transactions purchased before this date."""
  purchasedBefore: Time

  """Sort transactions by... defaults to date desc."""
  sortBy: PaymentTransactionSort = PURCHASE_DATE_DESC

  """
  Only show transactions that purchased products of a certain type, defaults to ALL.
  """
  type: PaymentTransactionTypeFilter = ALL

  """Purchaser ID."""
  userID: ID!
}

"""
An element in a paginated list of payment transactions, and its metadata.
"""
type PaymentTransactionEdge {
  """Offset acting as a cursor."""
  cursor: Cursor!

  """The element node."""
  node: PaymentTransaction
}

"""Payment transaction purchased product details."""
type PaymentTransactionProduct {
  """Number of digital goods wrapped into a product."""
  bundleSize: Int!

  """The name of the product."""
  name: String!

  """
  Some products have owners. For example, the owner of the `Lirik - Tier 1 Subscription` product is Lirik.
  """
  owner: User

  """Some products have tiers, such as subs."""
  tier: String

  """What type of product the payment was made for."""
  type: PaymentTransactionType!
}

"""Possible sort orders for lists of payment transactions."""
enum PaymentTransactionSort {
  """Sort the payment transactions descending by price."""
  PRICE_DESC

  """Sort the payment transactions ascending by price."""
  PRICE_ASC

  """Sort by purchase date descending."""
  PURCHASE_DATE_DESC

  """Sort by purchase date ascending."""
  PURCHASE_DATE_ASC
}

"""Payment transaction type."""
enum PaymentTransactionType {
  """Transaction for a subscription type."""
  SUBSCRIPTION

  """Transaction for a bits type."""
  BITS

  """Transaction for a sub token."""
  SUB_TOKEN

  """Transaction for gift cards."""
  GIFT_CARD

  """Transaction for celebration."""
  CELEBRATION

  """Transaction for an unknown type."""
  UNKNOWN
}

"""Select the kind of transactions."""
enum PaymentTransactionTypeFilter {
  """
  Only return payment transactions that associated with subscription products.
  """
  SUBSCRIPTIONS

  """
  Only return payment transactions that are associated with subtoken purchases and redemptions.
  """
  SUB_TOKEN

  """The default filter (no filter)."""
  ALL
}

"""Payout Information."""
type Payout {
  """Payout History Information."""
  history: PayoutHistory
}

"""
Payout Balance is the amount accrued by the user since their last Payout.
"""
type PayoutBalance {
  """Currency for the user."""
  currency: String!

  """Amount of total earnings accrued since last payout for user."""
  currentPayoutBalanceAmount: Float!

  """Month for the current payout balance."""
  month: Int!

  """Year for the current payout balance."""
  year: Int!
}

"""Enumerates valid payout categories."""
enum PayoutCategory {
  """Assigned if the user has a payout plan for the affiliate program."""
  AFFILIATE

  """
  Assigned if the user has a payout plan for the extensions developer program.
  """
  EXTENSIONS_DEVELOPER

  """Assigned if the user has a payout plan for the partner program."""
  PARTNER
}

"""Payout History Information."""
type PayoutHistory {
  """Url for Tipalti payout history iframe."""
  iframeURL: String
}

"""PayoutInvite describes a user's invite to a payout program."""
type PayoutInvite {
  """The payout program category the user has been invited to."""
  category: PayoutOnboardingCategory

  """A PayoutInvite's unique ID."""
  id: ID!

  """Whether or not this payout invite is for the affiliate program."""
  isForAffiliate: Boolean!

  """
  Whether or not this payout invite is for the extensions developer program.
  """
  isForExtensionsDeveloper: Boolean!

  """Whether or not this payout invite is for the partner program."""
  isForPartner: Boolean!

  """
  Whether or not the payout invite was created through the legacy onboarding flow.
  """
  isLegacy: Boolean!

  """The payout onboarding workflow for this payout invite."""
  workflow: PayoutOnboardingWorkflow
}

"""
PayoutOnboardingCategory enumerates valid categories for payout onboarding.
"""
enum PayoutOnboardingCategory {
  """
  Assigned for payout onboarding flows to enroll a user into the affiliate program.
  """
  AFFILIATE

  """
  Assigned for payout onboarding flows to enroll a user into the partner program with the "standard" payout plan.
  """
  STANDARD_PARTNER

  """
  Assigned for payout onboarding flows to enroll a user into the partner program with the "premium" payout plan.
  """
  PREMIUM_PARTNER

  """
  Assigned for payout onboarding flows to enroll a user into the partner program with a "custom" payout plan.
  """
  CUSTOM_PARTNER

  """
  Assigned for payout onboarding flows to enroll a user into the extensions developer program.
  """
  EXTENSIONS_DEVELOPER

  """
  Assigned for payout onboarding flows to enroll a user into an unpaid partner program.
  """
  UNPAID_PARTNER
}

"""PayoutOnboardingStep enumerates valid payout onboarding steps."""
enum PayoutOnboardingStep {
  """User needs to complete their registration step."""
  REGISTRATION_NOT_STARTED

  """User needs to agree to their payout agreement."""
  AGREEMENT_NOT_STARTED

  """User needs to submit their royalty tax interview."""
  ROYALTY_TAX_INTERVIEW_NOT_STARTED

  """
  User submitted their royalty tax interview and is waiting for it to be accepted.
  """
  ROYALTY_TAX_INTERVIEW_PENDING

  """
  User submitted their royalty tax interview but additional action by the user is required before completion.
  """
  ROYALTY_TAX_INTERVIEW_ACTION_REQUIRED

  """
  User submitted their royalty tax interview and received mismatch errors.
  """
  ROYALTY_TAX_INTERVIEW_MISMATCH

  """
  User submitted their royalty tax interview and received errors while it was processed.
  """
  ROYALTY_TAX_INTERVIEW_FAILED

  """
  User has completed their royalty tax interview and needs to complete their service tax interview.
  """
  SERVICE_TAX_INTERVIEW_NOT_STARTED

  """
  User submitted their service tax interview and is waiting for it to be accepted.
  """
  SERVICE_TAX_INTERVIEW_PENDING

  """
  User submitted their service tax interview but additional action by the user is required before completion.
  """
  SERVICE_TAX_INTERVIEW_ACTION_REQUIRED

  """
  User submitted their service tax interview and received mismatch errors.
  """
  SERVICE_TAX_INTERVIEW_MISMATCH

  """
  User submitted their service tax interview and received errors while it was processed.
  """
  SERVICE_TAX_INTERVIEW_FAILED

  """User neeeds to setup how they want to get paid out."""
  PAYOUT_METHOD_NOT_STARTED

  """
  User submitted their payout method and is waiting for it to be accepted.
  """
  PAYOUT_METHOD_PENDING

  """
  User is waiting for a final approval from the payout onboarding reviewers.
  """
  REVIEW_PENDING

  """User has completed their payout onboarding."""
  COMPLETED

  """User has canceled their payout onboarding workflow."""
  CANCELED

  """User has a pending upgrade to their payout agreement."""
  AGREEMENT_PENDING_UPGRADE
}

"""
PayoutOnboardingWorkflow describes the workflow details while a user is onboarding into a payout program.
"""
type PayoutOnboardingWorkflow {
  """The current step at which this workflow is at."""
  currentStep: PayoutOnboardingStep!

  """A PayoutOnboardingWorkflow's unique ID."""
  id: ID!

  """
  The URL for a user to update their payout settings. A redirectURL is the URL
  where the user will be redirected to after updating their payout settings.
  """
  payoutSettingsURL(redirectURL: String): String!

  """The registration information submitted by the user for this workflow."""
  registration: PayoutRegistration

  """
  Describes a user's tax interview information while completing their payout onboarding.
  """
  taxInterview(type: TaxInterviewType!, returnURL: String!): TaxInterview

  """
  Lists the fields that were mismatched during the registration and tax interview steps.
  """
  taxMismatchErrors: [TaxMismatchError!]

  """The timestamp when the workflow was most recently updated."""
  timestamp: Time!
}

"""
Describes the payout plan a user has when enrolled into a payout program.
"""
type PayoutPlan {
  """The category applied for this payout plan."""
  category: PayoutCategory!

  """Describes whether or not this payout plan is receiving revenue."""
  isReceivingRevenue: Boolean!

  """Lists tags to further describe this type of payout plan."""
  tags: [PayoutPlanTag!]
}

"""Enumerates valid payout plan tags."""
enum PayoutPlanTag {
  """Assigned if the user has the "standard" payout plan."""
  STANDARD

  """Assigned if the user has the "premium" payout plan."""
  PREMIUM

  """Assigned if the user has the "custom" payout plan."""
  CUSTOM

  """
  Assigned if the user has a payout plan created through the legacy onboarding flow.
  """
  LEGACY

  """
  Assigned if user has an esports payout plan. Twitch pays them lump sum when
  they get rewarded from competing in a Twtich sponsored event.
  """
  ESPORTS
}

"""
PayoutRegistration describes the personal information a user submitted while onboarding into a payout program.
"""
type PayoutRegistration {
  """
  Birthdate submitted by the user while registering into a payout program.
  """
  birthdate: Time!

  """City submitted by the user while registering into a payout program."""
  city: String!

  """
  Company Name submitted by the user while registering into a payout program.
  """
  companyName: String

  """
  Country Code (ISO-3166) submitted by the user while registering into a payout program.
  """
  countryCode: String!

  """Email submitted by the user while registering into a payout program."""
  email: String!

  """
  First Name submitted by the user while registering into a payout program.
  """
  firstName: String!

  """
  Last Name submitted by the user while registering into a payout program.
  """
  lastName: String!

  """
  Middle Name submitted by the user while registering into a payout program.
  """
  middleName: String

  """
  Parent Email submitted by the under age user while registering into a payout program.
  """
  parentEmail: String

  """
  Parent Name submitted by the under age user while registering into a payout program.
  """
  parentName: String

  """Postal submitted by the user while registering into a payout program."""
  postal: String

  """
  State Code submitted by the user while registering into a payout program.
  """
  stateCode: String

  """
  Primary Address submitted by the user while registering into a payout program.
  """
  streetAddress: String!

  """
  Secondary Address submitted by the user while registering into a payout program.
  """
  streetAddress2: String
}

type PayWithAmazonConfigs {
  """Used to configure PWA gateway and identify requests to Amazon."""
  clientID: ID!

  """
  Frontend only has access to production PWA environment so this helps QA.
  """
  isProduction: Boolean!

  """
  Also known as merchant ID, which identifies the account accepting payments.
  """
  sellerID: ID!
}

"""
Data about a pending future subscription.
ie. a user turns a 1-month gift into a recurring subscription.
"""
type PendingSubscription {
  """Whether the pending sub is cancelable."""
  isCancelable: Boolean!

  """
  The id of the pending subscription purchase. Used to cancel the paid upgrade.
  """
  originID: ID!

  """The formatted price of the pending subscription in USD."""
  price: String! @deprecated(reason: "Transitioning to priceInfo instead")

  """
  PriceInfo holds the pending subscription's pricing information such as currency, cost, and tax information.
  """
  priceInfo(taxCountry: String): PriceInfo!

  """The date the pending subscription begins."""
  startsAt: Time!

  """Tier of pending subscription."""
  tier: String!

  """
  The type of pending subscription. Ie GIFT_TO_PAID for a gift to paid conversion.
  """
  type: PendingSubType!
}

"""Denotes the type of pending subscription."""
enum PendingSubType {
  """
  This pending subscription was a conversion from a gift sub to a paid sub.
  """
  GIFT_TO_PAID

  """
  This pending subscription was a conversion from a DNRd sub to a renewing sub.
  """
  DNR_TO_RESUB_RECURRING

  """
  This pending subscription was a conversion from a DNRd sub to a one month sub.
  """
  DNR_TO_RESUB_NONRECURRING

  """
  This pending subscription was a conversion from a prime sub to a paid sub.
  """
  PRIME_TO_PAID
}

"""The permanent emote modifiers available to set."""
enum PermanentEmoteModifier {
  """Unknown emote modifier."""
  UNKNOWN

  """BlackWhite emote modifier."""
  BLACK_WHITE

  """HorizontalFlip emote modifier."""
  HORIZONTAL_FLIP

  """Sunglasses emote modifier."""
  SUNGLASSES

  """Thinking emote modifier."""
  THINKING

  """Squished emote modifier."""
  SQUISHED
}

"""
Describes the section(follows, recommendation ...) for a current user in the navigation bar.
"""
type PersonalSection {
  """
  Returns the list of contents in this section, nil if there is an error.
  """
  items: [PersonalSectionItem!]

  """The localized title for the personal section."""
  title: PersonalSectionTitle!

  """Describes the section (FOLLOWED, RECOMMENDED, POPULAR ...)."""
  type: PersonalSectionType!
}

"""Describes the personal channel for the current user."""
type PersonalSectionChannel {
  """Either live stream or vod depending on whether the stream in live."""
  content: PersonalSectionChannelContent

  """Describes how to label channels, if a label is necessary."""
  label: PersonalSectionChannelLabel!

  """Unique id per channel used in client tracking."""
  trackingID: ID!

  """The channel (user object of channel)."""
  user: User
}

"""Content metadata for either live stream or list of vod."""
union PersonalSectionChannelContent = Stream | VideoConnection

"""
Describes how to label channels in combined sections. This enum is closely related
to - but separate from - the PersonalSectionType enum. Some sections may not have labels
and some labels may not have sections.
"""
enum PersonalSectionChannelLabel {
  """Use no label."""
  NONE

  """Use label for recommended channel."""
  RECOMMENDED

  """Use label for similar channel."""
  SIMILAR

  """Use label for followed channel."""
  FOLLOWED

  """Use label for popular channel."""
  POPULAR
}

"""Input to personal section query."""
input PersonalSectionInput {
  """
  Name of the channel the user is watching. Used to present similar channels.
  """
  contextChannelName: String

  """Provides additional context used to influence recommendations."""
  recommendationContext: RecommendationsContext

  """Requested sections eg: follows, recommendation, popular."""
  sectionInputs: [PersonalSectionType!]!
}

"""
The types of content(channel, category ...) that can be contained in a PersonalSectionItem.
"""
union PersonalSectionItem = PersonalSectionChannel

"""A personal section token type that contains text."""
type PersonalSectionTextToken {
  """The text to display for this token."""
  value: String!
}

"""The title for the personal section."""
type PersonalSectionTitle {
  """
  The localizedFallback title, only to be used if localizedTokens is nil.
  """
  localizedFallback: String!

  """
  The localized section title in the form of a list of tokens. [Maximum of 2 tokens].
  """
  localizedTokens: [PersonalSectionTitleToken!]
}

"""The content of a personal section title token."""
union PersonalSectionTitleToken = PersonalSectionTextToken | User

"""Describes the type in personal sections."""
enum PersonalSectionType {
  """Returns the list of followed channels if the user is authenticated."""
  FOLLOWED_SECTION

  """Returns the list of recommended channels."""
  RECOMMENDED_SECTION

  """Returns the list of popular channels."""
  POPULAR_SECTION

  """Returns the list of similar channels."""
  SIMILAR_SECTION
}

"""
The phase state signifies the progress of the phase in the competition.
"""
enum PhaseState {
  """No lobbies are currently actively playing in the phase."""
  UNSTARTED

  """Some or all the lobbies in the phase are actively playing."""
  PLAYING

  """All lobbies in the phase are done playing."""
  FINISHED

  """Lobby state is unknown."""
  UNKNOWN
}

type PhotoOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  url: String!
  version: String!
  width: Int!
}

"""Stream Platform."""
union Platform = PlayStation

type PlatformEventSetting {
  """Whether the setting is enabled for the given platform."""
  isEnabled: Boolean!

  """The name of the platform. ("email", "push", etc..)."""
  platformName: String!

  """The exact state of the setting. ("on", "off", "friends_only", etc)."""
  settingState: String!
}

"""Stream platform type."""
enum PlatformType {
  all
  ps4
  xbox
}

"""Access token that determines playback experience for a video."""
type PlaybackAccessToken {
  """The signature of the token."""
  signature: String!

  """Token that encodes information about the user's access to a video."""
  value: String!
}

"""Optional parameters to pass in when fetching a playback access token."""
input PlaybackAccessTokenParams {
  """If the video should not be loaded over HTTPS."""
  disableHTTPS: Boolean

  """If the user has adblock enabled."""
  hasAdblock: Boolean

  """The platform the user is watching the video on."""
  platform: String!

  """The player backend being used to serve video."""
  playerBackend: String

  """The type of player the user is watching from."""
  playerType: String!
}

type Playing implements Activity {
  """The game being played."""
  game: Game

  """This activity's type, i.e. "PLAYING"."""
  type: ActivityType
}

"""Stream metadata for PlayStation."""
type PlayStation {
  platform: String
  title: SCETitle
  updatedAt: Time
  user: SCEUser
}

"""A poll users can vote in."""
type Poll {
  """A choice specified by a choice id."""
  choice(id: ID!): PollChoice

  """A list of choices users can vote for."""
  choices: [PollChoice!]!

  """
  User that created the poll.
  Mods and editors can make polls on behalf of a broadcaster.
  """
  createdBy: User

  """
  Amount of seconds from when the poll starts to when it ends.
  Since a broadcaster can end a poll early ("terminate a poll"), it may be possible for endedAt - startedAt != duration.
  """
  durationSeconds: Int!

  """
  Time when the poll ended.
  Null if the poll is still active.
  """
  endedAt: Time

  """
  User that ended the poll. Mods and editors can end polls on behalf of a broadcaster.
  Null if no user manually ended the poll.
  """
  endedBy: User

  """ID of poll."""
  id: ID!

  """Whether the poll is viewable by other users."""
  isViewable: Boolean!

  """User who owns this poll. The poll will appear on their channel."""
  ownedBy: User

  """
  Amount of milliseconds before the poll ends.
  0 when the polls is ended.
  """
  remainingDurationMilliseconds: Int!

  """
  The authenticated user's relationship with this poll.
  Main use case is to check if the user has voted in the poll already.
  Null if un-authenticated user is making this query.
  """
  self: PollSelfEdge

  """A map of poll settings."""
  settings: PollSettings!

  """Time when poll started."""
  startedAt: Time!

  """The status of the poll."""
  status: PollStatus!

  """Title of poll."""
  title: String!

  """A breakdown of the different tokens used in this poll."""
  tokens: PollTokenBreakdown!

  """The top Bits contributor for the poll."""
  topBitsContributor: PollTopBitsContributor

  """The top Community Points contributor for the poll."""
  topCommunityPointsContributor: PollTopCommunityPointsContributor

  """The top Bits contributor for the poll."""
  topContributor: PollTopContributor @deprecated(reason: "Use topBitsContributor instead.")

  """Total number of unique voters that have voted in this poll."""
  totalVoters: Int!

  """A breakdown of the different votes cast in this poll."""
  votes: PollVoteBreakdown!
}

"""A choice in a poll that users can vote for."""
type PollChoice {
  """ID of choice."""
  id: ID!

  """The authenticated user's relationship with this choice."""
  self: PollChoiceSelfEdge!

  """The title of the choice."""
  title: String!

  """A breakdown of the different tokens used for this choice."""
  tokens: PollTokenBreakdown!

  """Total number of unique voters that have voted for this choice."""
  totalVoters: Int!

  """
  A list of voters for this choice.
  Only the poll's ownerID and their mods/editors can search for this.
  """
  voters(first: Int = 15, after: Cursor, sort: PollVoterConnectionSort = VOTES, direction: PollVoterConnectionSortDirection = DESC): PollChoiceVoterConnection

  """A breakdown of the different votes cast for this choice."""
  votes: PollVoteBreakdown!
}

"""A connection between poll choice and the authenticated user."""
type PollChoiceSelfEdge {
  """The voter object pertaining to the authenticated user."""
  voter: PollVoter
}

"""A connection between poll and voters and metadata."""
type PollChoiceVoterConnection {
  """The list of voters in this poll / choice."""
  nodes: [PollVoterConnectionEdge!]!
}

"""A connection between poll and metadata."""
type PollConnection {
  """The list of polls for the user."""
  edges: [PollEdge!]

  """Information about pagination in this connection."""
  pageInfo: PageInfo!
}

"""
A page entry, that contains the Poll item and a cursor to return from the query to allow pagination.
"""
type PollEdge {
  """Cursor used for next query."""
  cursor: Cursor!

  """The underlying poll voter."""
  node: Poll!
}

"""A connection between a poll and the authenticated user."""
type PollSelfEdge {
  """The voter object pertaining to the authenticated user."""
  voter: PollVoter
}

"""Poll Settings."""
type PollSettings {
  """Bits votes poll settings."""
  bitsVotes: PollSettingsBitsVotes!

  """Channel Points votes poll settings."""
  communityPointsVotes: PollSettingsCommunityPointsVotes!

  """ID of poll settings."""
  id: ID!

  """Multichoice voting poll settings."""
  multichoice: PollSettingsMultichoice!

  """Subscriber multiplier poll settings."""
  subscriberMultiplier: PollSettingsSubscriberMultiplier! @deprecated(reason: "Subscriber multipliers are no longer supported.")

  """Subscriber only poll settings."""
  subscriberOnly: PollSettingsSubscriberOnly! @deprecated(reason: "Subscriber-only polls are no longer supported.")
}

"""Bits votes poll settings."""
type PollSettingsBitsVotes {
  """Cost of bits for a vote."""
  cost: Int!

  """Whether the poll allows for users to use bits for votes."""
  isEnabled: Boolean!
}

"""Channel Points votes poll settings."""
type PollSettingsCommunityPointsVotes {
  """Cost of channel points for a vote."""
  cost: Int!

  """Whether the poll allows for users to use channel points for votes."""
  isEnabled: Boolean!
}

"""Multichoice voting enabled poll setting."""
type PollSettingsMultichoice {
  """Whether the poll has multichoice voting enabled."""
  isEnabled: Boolean!
}

"""
Subscriber multiplier poll settings.
Deprecated: subscriber multipliers are no longer supported.
"""
type PollSettingsSubscriberMultiplier {
  """Whether the poll has a subscriber multipler."""
  isEnabled: Boolean!
}

"""
Subscriber only poll settings.
Deprecated: subscriber-only polls are no longer supported.
"""
type PollSettingsSubscriberOnly {
  """Whether the poll is subscriber only."""
  isEnabled: Boolean!
}

"""Possible sort orders for lists of polls."""
enum PollSort {
  """Sort the polls by time."""
  START_TIME
}

"""The status of the poll."""
enum PollStatus {
  """
  Encountered some poll status that we do not know how to handle BibleThump.
  """
  UNKNOWN

  """Poll is running. Users can vote. Results are publicly visible."""
  ACTIVE

  """
  Poll ran its entire duration and "naturally" completed. Users cannot vote. Results are publicly visible.
  """
  COMPLETED

  """
  Poll was manually ended ("terminated") by a user. Users cannot vote. Results are publicly visible.
  """
  TERMINATED

  """
  Poll has ended and is no longer publicly visible. Users cannot vote. Results are not publicly visible.
  """
  ARCHIVED

  """
  Poll has been moderated by Twitch and is no longer viewable, even to the poll
  owner. Users cannot vote. Results are not visible to any user.
  """
  MODERATED
}

"""A breakdown of tokens used/by for this poll/choice/user."""
type PollTokenBreakdown {
  """Total number of bits used."""
  bits: Int!

  """Total number of community points used."""
  communityPoints: Int!

  """ID of token breakdown."""
  id: ID!
}

"""Top contributor to the poll and the bits they contributed."""
type PollTopBitsContributor {
  """Bits amount contributed."""
  bitsAmount: Int!

  """Top contributor to the poll."""
  user: User
}

"""Top contributor to the poll and the community points they contributed."""
type PollTopCommunityPointsContributor {
  """Community Points amount contributed."""
  communityPointsAmount: Int!

  """Top contributor to the poll."""
  user: User
}

"""
Top contributor to the poll and the bits they contributed.
Deprecated: use PollTopBitsContributor instead.
"""
type PollTopContributor {
  """Bits amount contributed."""
  bitsAmount: Int!

  """Top contributor to the poll."""
  user: User
}

"""A breakdown of votes cast for/by this poll/choice/user."""
type PollVoteBreakdown {
  """Total number of base votes."""
  base: Int!

  """Total number of votes due to bits contributions."""
  bits: Int!

  """Total number of votes due to Community Points contributions."""
  communityPoints: Int!

  """ID of vote breakdown."""
  id: ID!

  """Total number of votes across all different vote types."""
  total: Int!
}

"""A voter taking part in a poll and associated information."""
type PollVoter {
  """The Choices this voter voted for."""
  choices: [PollVoterChoice!]!

  """id of the voter in the poll."""
  id: ID!

  """The Poll this voter voted in."""
  poll: Poll

  """A breakdown of the different tokens used by the voter in the poll."""
  tokens: PollTokenBreakdown!

  """The User object relating to this voter."""
  user: User

  """A breakdown of the different votes this voter used in the poll."""
  votes: PollVoteBreakdown!
}

"""A choice a voter made taking part in a poll."""
type PollVoterChoice {
  """The id of the PollVoterChoice."""
  id: ID!

  """The poll choice."""
  pollChoice: PollChoice

  """A breakdown of the different tokens used by the voter."""
  tokens: PollTokenBreakdown!

  """A breakdown of the different votes this voter used."""
  votes: PollVoteBreakdown!
}

"""A connection between poll and voters and metadata."""
type PollVoterConnection {
  """The list of voters in this poll / choice."""
  nodes: [PollVoterConnectionEdge!]!
}

"""
A page entry, that contains the PollVoter item and a cursor to return from the query to allow pagination.
"""
type PollVoterConnectionEdge {
  """Cursor used for next query."""
  cursor: Cursor!

  """The underlying poll voter."""
  node: PollVoter!
}

"""Possible sort orders for lists of voters."""
enum PollVoterConnectionSort {
  """Sort the voters by # of votes."""
  VOTES

  """Sort the voters by time of creation."""
  CREATED_DATE

  """Sort the voters by amount of Bits on vote."""
  BITS

  """Sort the voters by amount of channel points."""
  CHANNEL_POINTS
}

"""Possible sort directions for lists of voters."""
enum PollVoterConnectionSortDirection {
  """Sort in descending order."""
  DESC

  """Sort in ascending order."""
  ASC
}

"""The tokens that are used on a vote."""
input PollVoteTokensInput {
  """The amount of bits used for this vote."""
  bits: Int!

  """The amount of channel points used for this vote."""
  channelPoints: Int!
}

type Post {
  """The user that created this post."""
  author: User

  """
  The content of the post as entered by the user and annotated with links and emotes.
  """
  body: MessageBody

  """Time the post was created by the user."""
  createdAt: Time

  """Collection of embedable content attached to this post."""
  embeds: [PostEmbed]

  """This Post's unique feeds ID."""
  id: ID!

  """Is this post deleted."""
  isDeleted: Boolean

  """The reactions associated with this post."""
  reactions: [Reaction]

  """Data related to the current user."""
  self: PostSelfConnection
}

"""TODO: Add events."""
union PostEmbed = Clip | LinkOEmbed | PhotoOEmbed | RichOEmbed | Video | VideoOEmbed

type PostPermissionSet {
  """True if the current user is allowed to delete this post."""
  canDelete: Boolean!
}

type PostSelfConnection {
  """Permissions that the current user has on this post."""
  permissions: PostPermissionSet
}

"""A single Prediction made by a user on a Prediction Event."""
type Prediction {
  """The Event that this Prediction relates to."""
  event: PredictionEvent

  """The unique identifier of the Prediction."""
  id: ID!

  """
  Whether the Prediction's results have been acknowledged by the user. Null if the Prediction has not been resolved yet.
  """
  isResultAcknowledged: Boolean

  """The Outcome that was Predicted."""
  outcome: PredictionOutcome

  """The number of points that the user spent on this Prediction."""
  points: Int!

  """
  The number of points won by the user for this Prediction. Null if the Prediction has not been resolved yet.
  """
  pointsWon: Int

  """The timestamp of when the user initially made this Prediction."""
  predictedAt: Time!

  """
  The result of this Prediction. Null if the Prediction has not been resolved or refunded yet.
  """
  result: PredictionResult

  """The timestamp of when the user most recently updated this Prediction."""
  updatedAt: Time!

  """The user that made this Prediction."""
  user: User
}

"""An Event that users can make Predictions on."""
type PredictionEvent {
  """
  The channel that the Prediction Event belongs to. Null if this is Event is not tied to a channel.
  """
  channel: Channel

  """The timestamp of when the Event was created."""
  createdAt: Time!

  """
  The creator of the Event. Null if the Event was created by an automatic process or an admin.
  """
  createdBy: PredictionEventActor

  """
  The timestamp of when the Event was resolved or canceled. Null if the Event is not resolved or canceled yet.
  """
  endedAt: Time

  """
  The user or extension that resolved or canceled the Event. Null if this was triggered by an automatic process or
  by an admin, or if the Event is not resolved or canceled yet.
  """
  endedBy: PredictionEventActor

  """Unique identifier of the Prediction Event."""
  id: ID!

  """
  The timestamp of when the Event was locked. Null if the Event is still active.
  """
  lockedAt: Time

  """
  The user or extension that locked the Event. Null if this was triggered by an automatic process or by an admin,
  or if the Event is stillactive.
  """
  lockedBy: PredictionEventActor

  """The Outcomes available for predicting in this Event."""
  outcomes: [PredictionOutcome!]!

  """
  The length of the prediction window (the duration that the Event accepts predictions) in seconds.
  """
  predictionWindowSeconds: Int!

  """The relationship between this Prediction Event and the logged in user."""
  self: PredictionEventSelfEdge

  """The current status of the Event."""
  status: PredictionEventStatus!

  """The title of the Event."""
  title: String!

  """
  The Outcome that ended up being selected as the "correct" Outcome. Null if the Event has not been resolved yet.
  This Outcome will also be present as one of the outcomes in the "outcomes" field.
  """
  winningOutcome: PredictionOutcome
}

"""
Someone or something that is capable of performing actions on a Prediction Event.
"""
union PredictionEventActor = ExtensionClient | User

"""Paginated list of Prediction Events for a channel."""
type PredictionEventConnection {
  """The elements in the list."""
  edges: [PredictionEventEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""Element in a list of Prediction Events."""
type PredictionEventEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The Prediction Event."""
  node: PredictionEvent!
}

"""The relationship between a Prediction Event and the logged in user."""
type PredictionEventSelfEdge {
  """
  The user's Prediction on the Event. Null if the user does not have a Prediction on the Event.
  """
  prediction: Prediction

  """
  A restriction on the user participating in this Event. Null if there are no
  restrictions. If non-null, the user can only participate in Spectator Mode.
  """
  restriction: UserPredictionEventRestriction
}

"""Possible statuses for a Prediction Event."""
enum PredictionEventStatus {
  """Event is actively accepting new predictions."""
  ACTIVE

  """
  Event is no longer accepting new predictions, and is awaiting resolution.
  """
  LOCKED

  """Event has been resolved, and is in the process of paying out winners."""
  RESOLVE_PENDING

  """
  Event has been resolved, the winning Option has been determined, and winners have received their Channel Points.
  """
  RESOLVED

  """
  Event has been canceled, and is in the process of refunding participants.
  """
  CANCEL_PENDING

  """Event has been canceled and all users have been refunded."""
  CANCELED
}

"""A single Outcome that users can choose in a Prediction Event."""
type PredictionOutcome {
  """The color of this Outcome."""
  color: PredictionOutcomeColor!

  """The unique identifier of the Prediction Outcome."""
  id: ID!

  """The title of the Event."""
  title: String!

  """
  The top predictors (sorted by most points spent) of this Outcome. Empty if no users have predicted this Outcome.
  """
  topPredictors: [Prediction!]!

  """
  The total number of points that have been spent predicting this Outcome.
  """
  totalPoints: Int!

  """The total number of users that have predicted this Outcome."""
  totalUsers: Int!
}

"""The possible colors for a Prediction Outcome."""
enum PredictionOutcomeColor {
  """Blue."""
  BLUE

  """Pink."""
  PINK

  """Green."""
  GREEN

  """Orange."""
  ORANGE

  """Grey."""
  GREY

  """Purple."""
  PURPLE
}

"""Possible result types for a Prediction."""
enum PredictionResult {
  """The Prediction was incorrect."""
  LOSE

  """The Prediction was canceled and refunded."""
  REFUND

  """The Prediction was correct."""
  WIN
}

"""DEPRECATED."""
type Premiere {
  """The Premiere’s identifier."""
  id: ID! @deprecated(reason: "Premieres as a product has been deprecated")

  """
  The paginated items in the premiere. At this time, they will all be VoDs.
  A maximum of 100 items will be returned per request.
  """
  items(first: Int = 10, after: Cursor): PremiereConnection @deprecated(reason: "Premieres as a product has been deprecated")

  """
  The archived video. Only populated if the premiere is in state SUCCESS.
  """
  pastPremiere: Video @deprecated(reason: "Premieres as a product has been deprecated")

  """Status of the premiere."""
  status: PremiereStatus! @deprecated(reason: "Premieres as a product has been deprecated")

  """The user who this premiere belongs to."""
  user: User @deprecated(reason: "Premieres as a product has been deprecated")
}

"""
DEPRECATED.
Paginated list of videos.
"""
type PremiereConnection {
  """The list of items in this page."""
  edges: [PremiereItemEdge] @deprecated(reason: "Premieres as a product has been deprecated")

  """Information about this page of videos."""
  pageInfo: PageInfo @deprecated(reason: "Premieres as a product has been deprecated")

  """The total number of items in the premiere."""
  totalCount: Int @deprecated(reason: "Premieres as a product has been deprecated")
}

"""
DEPRECATED.
The types of objects that can be contained in a premiere.
"""
union PremiereItem = Video

"""
DEPRECATED.
A page entry, that contains a premiere item and a cursor to return
from the query to allow pagination.
NOTE: this should have been named PremiereEdge.
"""
type PremiereItemEdge {
  """Cursor is a cursor."""
  cursor: Cursor! @deprecated(reason: "Premieres as a product has been deprecated")

  """Node is a node."""
  node: PremiereItem! @deprecated(reason: "Premieres as a product has been deprecated")
}

"""DEPRECATED."""
enum PremiereStatus {
  """An unscheduled premiere."""
  UNSCHEDULED @deprecated(reason: "Premieres as a product has been deprecated")

  """A scheduled premiere."""
  SCHEDULED @deprecated(reason: "Premieres as a product has been deprecated")

  """A cancelled premiere."""
  CANCELLED @deprecated(reason: "Premieres as a product has been deprecated")

  """A premiere that has been started."""
  STARTED @deprecated(reason: "Premieres as a product has been deprecated")

  """A successfully completed premiere."""
  SUCCESS @deprecated(reason: "Premieres as a product has been deprecated")

  """
  A failed premiere. Examples of failed premieres are premieres that attempt to run
  prior to the video being processed (or failed processing,) or the event failing
  in the middle due to technical difficulties.
  """
  FAILED @deprecated(reason: "Premieres as a product has been deprecated")

  """An unknown status to ensure we are able to return something."""
  UNKNOWN @deprecated(reason: "Premieres as a product has been deprecated")
}

"""Domain of dev insights report."""
enum PresignDevInsightsReportURLDomain {
  """Report for a game."""
  GAME

  """Report for an extension."""
  EXTENSION

  """Report for a drop."""
  DROP
}

"""Input for presignDevInsightsReportURL mutation."""
input PresignDevInsightsReportURLInput {
  """Domain of report, for a GAME or EXTENSION or DROP."""
  domain: PresignDevInsightsReportURLDomain!

  """Game ID or Extension ID or Drops Campaign ID/Reward ID."""
  id: ID!

  """Type of report, default is OVERVIEW_V2."""
  type: PresignDevInsightsReportURLReportType
}

"""URL info that can be used to upload the image."""
type PresignDevInsightsReportURLPayload {
  """
  URL to be used by the client to download the CSV report.
  Expires in 5 minutes.
  """
  url: String
}

"""Type of dev insights report."""
enum PresignDevInsightsReportURLReportType {
  """Default report type, used for games and extensions."""
  OVERVIEW_V2

  """Drops report that returns top 10 streamers for campaigns."""
  DROPS_CAMPAIGNS_TOP_STREAMERS

  """Drops report that returns overview of campaigns."""
  DROPS_CAMPAIGNS_OVERVIEW

  """Drops report that returns overview of drops."""
  DROPS_CAMPAIGNS_DROPS_OVERVIEW
}

"""
Generic Price Information that supports taxing and multi region pricing.
LONG-TERM NOTE: using Int (32 bit) as a price field can cause issue when we sell products locally
e.g. 2147483648 (2^31) Lao Att = 253132 USD cent
Therefor, if we sell product which price more than $2500 in Laos currency. We will need to fix this.
"""
type PriceInfo {
  """The currency associated with the price of a subscription product."""
  currency: Currency!

  """The description associated with pricing information."""
  description: String!

  """The discounted total also broken down by price and tax."""
  discount: DiscountBreakdown

  """The ISO-4217 wording of deriving price."""
  exponent: Int!

  """Identifier used for caching."""
  id: ID!

  """If the tax is already included in price."""
  isTaxInclusive: Boolean!

  """The numerical price of a subscription product."""
  price: Int!

  """The tax rate of localized product."""
  tax: Int!

  """The total price given price and tax."""
  total: Int!
}

"""Wrapper around standard Emoticons for Prime Smilies Emoticons."""
type PrimeEmoticons {
  """Name for the currently enabled Emoticon set selected by the user."""
  currentSetName: PrimeEmoticonsSetName!

  """All Prime Emoticon Sets of emote values (id, token, setId)."""
  emoticonSets: [SmiliesSet!]
}

"""The Names for the smilies Emoticon sets supported by Prime."""
enum PrimeEmoticonsSetName {
  """
  Emotes that are granted to all users with Robot faces. Group id is #0 and emoticons start at id #1.
  """
  ROBOTS

  """Emotes that are granted via Prime with Turbo faces."""
  PURPLE

  """Emotes that are granted via Prime with Monkey faces."""
  MONKEYS
}

"""
Prime Digital Content Offers are displayed to users on Twitch via Offers in the top nav.
"""
type PrimeOffer {
  """Unique Identifier for an offer used by the Catalog service."""
  catalogOfferID: ID!

  """
  Hint describing the current availability state of the claim for the user.
  """
  claimHint: ClaimHint!

  """
  Instructions string in Markdown displayed after offer is claimed to use or redeem.
  """
  claimInstructions: String!

  """Content metadata for the given offer."""
  content: PrimeOfferContent

  """The method of offer entitlement."""
  deliveryMethod: OfferDeliveryMethod!

  """Description string in Markdown used in info block for Offer."""
  description: String!

  """Unique Identifier for an offer."""
  id: ID!

  """Offer image asset URL."""
  imageURL: String!

  """
  Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority.
  """
  priority: Int!

  """The connection for whether the user is entitled to the offer."""
  self: PrimeOfferSelfConnection

  """Tags related to the offer such as Free Games with Prime (FGWP)."""
  tags: [String!]!

  """Primary Title for Offer."""
  title: String!
}

"""An Object containing metadata for Digital Content."""
type PrimeOfferContent {
  """Content Categories for the game, displayed in info."""
  categories: [String!]!

  """
  If the content has an external marketing page (Blizzard, Retail, etc), some offers will have no external URL.
  """
  externalURL: String

  """The Game metadata."""
  game: Game

  """The publisher of the content."""
  publisher: String!

  """Content SKU list for the offer."""
  skus: [String!]!
}

"""
The requesting user's eligibility for a given Prime Gaming content offer.
These fields map directly to eligibility rules used by SCES to calculate eligibility.
They are true if the user is eligible under the specified rule.
"""
type PrimeOfferEligibility {
  """
  Boolean indicating if the user can claim the offer, determined by the included eligibility rules.
  """
  canClaim: Boolean!

  """
  LinkedAccountRule
  True if the user has the required account link, if applicable.
  """
  hasRequiredAccount: Boolean!

  """Boolean indicating if the user has already claimed the offer."""
  isClaimed: Boolean!

  """
  MarketplaceRule
  True if the user is in one of the offer's eligible marketplaces.
  """
  isInEligibleMarketplace: Boolean!

  """
  PrimeGamingRule
  True if the user is Prime Gaming enabled.
  """
  isPrimeGaming: Boolean!

  """
  ClaimLimitRule
  True if the user has not exceeded the claim limit for the offer.
  """
  isUnderClaimLimit: Boolean!

  """
  OfferWindowRule
  True if the time is within the offer's available window.
  """
  isWithinOfferWindow: Boolean!

  """State of the offer: EXPIRED, LIVE, FUTURE."""
  offerState: OfferState!

  """
  The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN, ERROR.
  """
  status: OfferStatus!
}

"""The connection between the user and their offer entitlement state."""
type PrimeOfferSelfConnection {
  """
  The data (link, text, or claim code) for the entitlement that was created.
  """
  claimData: String!

  """Indicates whether the user has the entitlement to the offer."""
  hasEntitlement: Boolean!

  """
  The visual status of the offer to the user, UNSEEN, SEEN, CLAIMED, DISMISSED, OVERRIDDEN.
  """
  status: String!
}

"""
Represents a Prime Gaming content offer with the requesting user's eligibility information.
These offers are displayed on the Crown menu on Twitch.tv.
"""
type PrimeOfferWithEligibility {
  """Unique Identifier for an offer used by the Catalog service."""
  catalogOfferID: ID!

  """
  Instructions string in Markdown displayed after offer is claimed to use or redeem.
  """
  claimInstructions: String!

  """Content metadata for the given offer."""
  content: PrimeOfferContent

  """The method of offer entitlement."""
  deliveryMethod: OfferDeliveryMethod!

  """Description string in Markdown used in info block for Offer."""
  description: String!

  """Unique Identifier for an offer."""
  id: ID!

  """Offer image asset URL."""
  imageURL: String!

  """Describes the user's eligibility for the requested offer."""
  offerEligibility: PrimeOfferEligibility

  """
  Ranking for which the offer should be displayed, ordered ASC -1 through 99 where -1 value indicates top priority.
  """
  priority: Int!

  """Tags related to the offer such as Free Games with Prime (FGWP)."""
  tags: [String!]!

  """Primary Title for Offer."""
  title: String!
}

"""
PrimePayoutDetail shows the detailed breakdown of the prime payouts for a given user.
"""
type PrimePayoutDetail {
  """currency for the payout number above."""
  currency: Currency!

  """
  currentPrimePayout is the payout that will be made in this specific payout cycle.
  """
  currentPrimePayout: CurrentPrimePayout!

  """
  deferredPrimePayout is part of the earning that was earned this month but will not be paid out this month.
  """
  deferredPrimePayout: DeferredPrimePayout!

  """month when this payout will be made."""
  month: Int!

  """year when this payout will be made."""
  year: Int!
}

"""PrimePayoutDetails shows the history of prime payout detail."""
type PrimePayoutDetails {
  """primePayoutHistory is the history of prime payout details for a user."""
  primePayoutHistory: [PrimePayoutDetail!]!
}

"""
Metadata relevant to Prime copy or marketing that needs to be scheduled.
"""
type PrimePromotion {
  """externalURL is a string with the destination URL."""
  externalURL: String

  """id is the unique identifier for the PrimePromotion."""
  id: ID!

  """
  isExternalLink is boolean that indicates whether the text should be a link.
  """
  isExternalLink: Boolean!

  """
  text is a string field containing the user visible text for a dynamic/changing string.
  """
  text: String!
}

"""Prime Settings related data for a given user."""
type PrimeSettings {
  """This type's unique identifier."""
  id: ID!

  """
  If true, chat notifications will be sent on Prime Credit Token Channel Subscriptions.
  """
  isSubCreditChatNotificationEnabled: Boolean!

  """The currently chosen Emoticon Set for the Prime User that are Smilies."""
  primeEmoticons: PrimeEmoticons
}

"""
Information about the authenticated user's Prime subscription credit benefit.
"""
type PrimeSubCreditBenefit {
  """
  Checks when the authenticated user's Prime subscription credit will renew.
  """
  renewalDate: Time

  """
  Checks if the authenticated user has the Prime benefit for 30-day subscription credit renewals.
  """
  willRenew: Boolean
}

"""Information about the Amazon user's Prime Video benefit."""
type PrimeVideoBenefit {
  """Error when the authentication token is expired."""
  error: WatchPartyError

  """True if the user has valid access."""
  isValid: Boolean
}

"""Contains rating information for Prime Video content."""
type PrimeVideoRating {
  """Number of votes."""
  count: Int!

  """Fractional number of stars."""
  stars: Float!
}

"""PrivacyLawName is the privacy law."""
enum PrivacyLawName {
  """Privacy law CCPA."""
  CCPA

  """Privacy GDPR."""
  GDPR

  """Rest of World."""
  ROW
}

"""
The enumerated error reasons when processing payment made for the purchase of an offer.
"""
enum ProcessAndroidPaymentErrorCode {
  """User is ineligible to purchase."""
  INELIGIBLE

  """Unable to process payment due to an invalid argument."""
  INVALID_ARGUMENT

  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """Must have auth credentials to purchase an offer."""
  UNAUTHENTICATED

  """Transaction had already been processed."""
  ALREADY_HANDLED
}

"""
ProcessAndroidPaymentInput contains the necessary fields to process an Android payment.
"""
input ProcessAndroidPaymentInput {
  """User IDs of the gift purchase recipients (if the Offer is a gift)."""
  giftRecipientUserIDs: [ID!]

  """The ID of the Offer."""
  offerID: ID!

  """The ID of the user making the purchase."""
  purchasingUserID: ID!

  """The number of units purchased."""
  quantity: Int!

  """The receipt data required to process Android purchases."""
  receiptData: AndroidReceiptDataInput!

  """The static and dynamic bindings of the attributes on an Offer."""
  tagBindings: [OfferTagBindingInput!]!

  """The purchase tracking data."""
  trackingData: AndroidPaymentTrackingDataInput
}

"""
ProcessAndroidPaymentPayload returns the order created for the purchase.
"""
type ProcessAndroidPaymentPayload {
  """Reason why a Purchase Order failed to be created if an error occurred."""
  error: ProcessAndroidPaymentErrorCode

  """The Purchase Order created for this txn process attempt."""
  purchaseOrder: PurchaseOrder
}

"""
The enumerated error reasons when processing payment made for the purchase of an offer.
"""
enum ProcessIOSPaymentErrorCode {
  """User is ineligible to purchase."""
  INELIGIBLE

  """Unable to process payment due to an invalid argument."""
  INVALID_ARGUMENT

  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """Must have auth credentials to purchase an offer."""
  UNAUTHENTICATED

  """Transaction had already been processed."""
  ALREADY_HANDLED
}

"""
ProcessIOSPaymentInput contains the necessary fields to process a payment from the iOS platform.
"""
input ProcessIOSPaymentInput {
  """The ID of the user making the purchase."""
  purchasingUserID: ID!

  """The ID of the Offer that was used for the purchase."""
  offerID: ID!

  """The static and dynamic bindings of the attributes on an Offer."""
  tagBindings: [OfferTagBindingInput!]!

  """The receipt data required to process iOS purchases."""
  receiptData: IOSReceiptDataInput!

  """The purchase tracking data."""
  trackingData: IOSPaymentTrackingDataInput

  """User IDs of the gift purchase recipients (if the Offer is a gift)."""
  giftRecipientUserIDs: [ID!]

  """The number of units purchased."""
  quantity: Int!
}

"""ProcessIOSPaymentPayload returns the order created for the purchase."""
type ProcessIOSPaymentPayload {
  """
  The error code representing the reason why the requested Purchase Order failed
  to be created. Populated only if an error occurred, nil otherwise.
  """
  error: ProcessIOSPaymentErrorCode

  """The Purchase Order record created for this transaction attempt."""
  purchaseOrder: PurchaseOrder
}

"""
A benefit the user receives when purchasing a product from the product catalog.
"""
interface ProductCatalogBenefit {
  """The identifier of the benefit."""
  id: ID!
}

"""A product appearing in the product catalog."""
interface ProductCatalogItem {
  """A list of benefits the user will receive when purchasing the product."""
  benefits: [ProductCatalogBenefit!]

  """A description of the product."""
  description: String

  """The identifier of the product."""
  id: ID!

  """A list of offers available for purchasing the product."""
  offers: [Offer!]

  """The owner (ex: channel) of the product."""
  owner: ID!

  """The title of the product."""
  title: String!
}

"""
Contains the product's checkout price and tax info for a purchase and error if a final price cannot be determined.
"""
type ProductPurchase {
  """The price and tax breakdown for the purchase."""
  checkoutPriceSummary: CheckoutPriceSummary

  """Error when the final price could not be retrieved for a product."""
  errorCode: ProductPurchaseErrorCode

  """The region from which the tax was calculated."""
  taxRegion: TaxRegion
}

"""Possible errors when retrieving product purchase info."""
enum ProductPurchaseErrorCode {
  """The user is unauthorized to retrieve the purchase info."""
  USER_UNAUTHORIZED

  """PricingID not found."""
  PRICING_ID_NOT_FOUND

  """Cannot determine the user residence."""
  UNKNOWN_USER_RESIDENCE

  """Billing info not found for the user."""
  BILLING_INFO_NOT_FOUND

  """User ineligible to make corresponding purchase."""
  PURCHASE_INELIGIBLE

  """Unexpected error occurred."""
  UNKNOWN
}

"""
ProgramAgreement describes the End User License Agreement associated with a user's current payout plan.
"""
type ProgramAgreement {
  """Agreement body in HTML."""
  body: String!

  """Agreement type accepted by the user."""
  type: PayoutOnboardingCategory!

  """Agreement version (e.g. "v1")."""
  version: String!
}

"""Types that can only be displayed for an Offer Promotion."""
enum PromoDiscountType {
  """No Discount type to be shown."""
  DISCOUNT_TYPE_NONE

  """Percent Discount type to be shown."""
  DISCOUNT_TYPE_PERCENT
}

"""Data used to display promotional discounts to the client."""
type PromotionDisplay {
  """Describes the discount percent to display to the client."""
  discountPercent: Float

  """Describes the type of discount that will be applied to the client."""
  discountType: PromoDiscountType!
}

"""Moment Details specific to the PUBG game."""
type PUBGMomentDetails {
  """bucket is the player count bucket for aggregations."""
  bucket: Int!

  """One of "game_start" or "player_count"."""
  event: String!

  """The game mode for the moment."""
  gameMode: String!

  """The maximum player count in this period."""
  maxPlayerCount: Int!

  """The minimum player count in this period."""
  minPlayerCount: Int!
}

"""PublishClipError is an error associated with the publishClip mutation."""
type PublishClipError {
  message: String
}

"""PublishClipInput edits the clip with the provided slug via segments."""
input PublishClipInput {
  """
  The number of seconds into the clip's raw media the preview image is set to.
  """
  previewOffsetSeconds: Float

  """
  The segments describing the desired changes to apply to the newly edited clip.
  """
  segments: [ClipSegmentInput!]!

  """The slug uniquely identifying the clip to edit."""
  slug: ID!

  """The new title this clip will be updated to."""
  title: String
}

"""PublishClipPayload returns the edited clip or an error."""
type PublishClipPayload {
  """The clip with its updated properties."""
  clip: Clip

  """The error when the clip fails to publish."""
  error: PublishClipError
}

"""Publish a Competition."""
input PublishCompetitionInput {
  """ID of the Competition we want to update."""
  id: ID!
}

"""Data that was mutated after the competition was updated."""
type PublishCompetitionPayload {
  """The competition which was updated."""
  competition: Competition
}

"""Errors for publishing subscription emotes."""
type PublishSubscriptionEmoteError {
  """The associated error code."""
  code: PublishSubscriptionEmoteErrorCode!
}

"""Possible error codes returned for publishing subscription emotes."""
enum PublishSubscriptionEmoteErrorCode {
  """The product has no available empty emote slots."""
  EMOTE_LIMIT_REACHED

  """Only the product owner is allowed to upload emotes."""
  INVALID_OWNER

  """The emote code submitted collides with an existing emote code."""
  EMOTE_CODE_ALREADY_EXISTS

  """
  The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  """
  EMOTE_CODE_UNACCEPTABLE

  """Data for least one of the image sizes is not provided or invalid."""
  INCOMPLETE_EMOTE_IMAGE_DATA

  """The emote code suffix submitted contains invalid characters."""
  INVALID_CODE_SUFFIX

  """The upload emote image could not be parsed."""
  INVALID_IMAGE_UPLOAD

  """The uploaded emote image could not be found."""
  EMOTE_IMAGE_NOT_FOUND

  """
  There were not enough image assets supplied for the selected asset type.
  """
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS

  """
  There were more image assets supplied than required for the selected asset type.
  """
  TOO_MANY_EMOTE_IMAGE_ASSETS

  """The selected emote asset type was invalid."""
  INVALID_EMOTE_ASSET_TYPE

  """
  A static image asset was not supplied, but is required for the selected asset type.
  """
  EMOTE_MISSING_STATIC_ASSET

  """
  An animated image asset was not supplied, but is required for the selected asset type.
  """
  EMOTE_MISSING_ANIMATED_ASSET

  """Other errors returned from the service."""
  UNKNOWN_ERROR
}

"""The data needed to finalize the creation of a Subscription Emote."""
input PublishSubscriptionEmoteInput {
  """The type of image asset for the emote."""
  assetType: EmoteAssetType

  """
  The custom suffix of the emote code. When appended to the channel's emote prefix this will form the full emote code.
  """
  codeSuffix: String!

  """A list containing the image IDs for all assets needed for the emote."""
  imageAssets: [EmoteImageAssetInput!]

  """
  DEPRECATED: Use imageAssets instead. The ID of the 28x28px emote ("1x") image file previously uploaded to upload service.
  """
  imageID1x: ID

  """
  DEPRECATED: Use imageAssets instead. The ID of the 56x56px emote ("2x") image file previously uploaded to upload service.
  """
  imageID2x: ID

  """
  DEPRECATED: Use imageAssets instead. The ID of the 112x112px emote ("4x")
  image file previously uploaded to upload service.
  """
  imageID4x: ID

  """
  The ProductID of the subscription product which this emote will be associated with.
  """
  productID: ID!
}

"""Results of the subscription emote publish."""
type PublishSubscriptionEmotePayload {
  """The newly created emote if successful."""
  emote: Emote

  """Service error, if any."""
  error: PublishSubscriptionEmoteError
}

"""
Parameters to get details about a purchasable offer for the current logged in user.
"""
input PurchasableOfferParams {
  """List of gift recipient IDs if the offer is giftable."""
  giftRecipientIDs: [ID!]

  """The ID of the Offer."""
  offerID: ID!

  """The ID of the Promotion attached to a Purchasable Offer (optional)."""
  promotionID: ID

  """The static and dynamic bindings of the attributes on an Offer."""
  tagBindings: [OfferTagBindingInput!]
}

"""Category of product that can be purchased."""
enum PurchaseableProductType {
  """Subscription product."""
  SUBSCRIPTION

  """Bits product."""
  BITS
}

"""Set of purchase Ineligibility reasons."""
enum PurchaseIneligibilityReason {
  """User already has an active subscription to this product."""
  HAS_ACTIVE_SUBSCRIPTION

  """Not applicable as user is eligible to make a purchase."""
  NOT_APPLICABLE
}

"""The enumerated error reasons when purchasing an offer."""
enum PurchaseOfferErrorCode {
  """User is ineligible to purchase."""
  INELIGIBLE

  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """User's payment method is invalid."""
  INVALID_PAYMENT_METHOD

  """Must have auth credentials to purchase an offer."""
  UNAUTHENTICATED
}

"""PurchaseOfferInput contains the necessary fields to purchase an offer."""
input PurchaseOfferInput {
  """Data to facilitate the Fraud analysis."""
  billingAuthInfo: BillingAuthInfo

  """User IDs of the gift purchase recipients (if the Offer is a gift)."""
  giftRecipientUserIDs: [ID!]

  """The ID of the Offer."""
  offerID: ID!

  """Payments' session tracking."""
  paymentSession: PaymentSession!

  """The ID of the user making the purchase."""
  purchasingUserID: ID!

  """The number of units purchased."""
  quantity: Int!

  """The static and dynamic bindings of the attributes on an Offer."""
  tagBindings: [OfferTagBindingInput!]!

  """Tenant-specific tracking params."""
  tenantTracking: String
}

"""PurchaseOfferPayload returns the order created for the purchase."""
type PurchaseOfferPayload {
  """Reason why a Purchase Order failed to be created if an error occurred."""
  error: PurchaseOfferErrorCode

  """The Purchase Order created for this purchase attempt."""
  purchaseOrder: PurchaseOrder
}

"""PurchaseOrder is the record of a purchase made by a user."""
type PurchaseOrder {
  """The action token ID used to facilitate the 3D Secure flow."""
  actionTokenID: ID

  """The reason for a purchase order failure, if it failed."""
  failureReason: PurchaseOrderFailureReason

  """The ID of the Purchase Order."""
  id: ID!

  """The state of the Purchase Order."""
  state: PurchaseOrderState!
}

"""The enumerated failure reasons for a purchase order failure."""
enum PurchaseOrderFailureReason {
  """Bank declined the charge."""
  BANK_DECLINED

  """Failed to entitle the benefit. User was refunded if a charge occurred."""
  ENTITLEMENT_FAILED

  """User is ineligible to purchase."""
  INELIGIBLE

  """User's payment method is invalid."""
  INVALID_PAYMENT_METHOD

  """System error."""
  SYSTEM_ERROR

  """Unknown failure reason."""
  UNKNOWN
}

"""PurchaseOrderState is the current state of the Purchase Order."""
enum PurchaseOrderState {
  """The Purchase Order is in an unknown state."""
  UNKNOWN

  """
  The Purchase Order flow has been initiated and is at its starting state.
  """
  INITIATED

  """
  The Purchase Order has a scheduled future-dated payment to complete the purchase.
  """
  PAYMENT_PENDING

  """The Purchase Order has been paid and fulfillment has been kicked off."""
  FULFILLMENT_INITIATED

  """The Purchase Order has been successfully fulfilled."""
  SUCCESS

  """The Purchase Order failed and requires 3DS2 verification."""
  THREE_D_SECURE_CHALLENGE_REQUIRED

  """The Purchase Order failed."""
  FAILED

  """The Purchase Order's benefit cancellation has been kicked off."""
  CANCEL_BENEFITS_INITIATED

  """The Purchase Order's benefits have been fully cancelled."""
  BENEFITS_CANCELLED

  """A refund has been kicked off for the Purchase Order."""
  REFUND_INITIATED

  """A refund has been successfully applied to the Purchase Order."""
  REFUND_APPLIED

  """A refund has failed to the Purchase Order."""
  REFUND_FAILED
}

"""
Purchase profile of a recurring or non-recurring subscription that a user bought.
"""
type PurchaseProfile {
  """Cancels the entitled benefit and refunds if isRefundable is true."""
  cancelledAt: Time

  """Date this purchase profile was created."""
  createdAt: Time!
  expiresAt: Time

  """Usually the Twitch user's ID, but recorded by the payment provider."""
  extPurchaserID: ID

  """The external subscription ID recorded by the payment provider."""
  extSubscriptionID: ID

  """ID of the Purchase Profile in Payments team database."""
  id: ID!
  isExpired: Boolean

  """Whether this purchase profile was gifted."""
  isGift: Boolean

  """Whether this purchase profile is being paid for."""
  isPaying: Boolean!
  isRecurring: Boolean!
  isRefundable: Boolean
  paidAt: Time

  """Product type of the purchase."""
  productType: SubscriptionProductType!
  purchasedAt: Time

  """Twitch purchaser's email."""
  purchaserEmail: String!

  """Twitch purchaser's user ID."""
  purchaserID: ID!

  """Twitch purchaser's real name."""
  purchaserName: String

  """Currency for the renewalPrice, e.g. "USD"."""
  renewalCurrency: String

  """
  Expected renewal price of the product in the smallest subunit of the currency, e.g. "499".
  """
  renewalPrice: Int

  """
  Different from cancellation in that it stops renewal but let's user keep the benefit until it expires.
  """
  renewalStoppedAt: Time

  """
  State of the purchase profile. i.e. cancelling the purchase profile can set state to 'cancelled'.
  """
  state: PurchaseProfileState!

  """
  Subscription benefit associated with this purchase profile, if still active.
  """
  subscriptionBenefit: SubscriptionBenefit

  """Date this purchase profile was last updated."""
  updatedAt: Time

  """
  Whether this purchase profile will renew in the future and charge the user's payment method.
  """
  willRenew: Boolean!
}

enum PurchaseProfileState {
  ACTIVE
  CANCELLED
  INACTIVE
  MIGRATED
}

"""Root fields to access the Twitch API."""
type Query {
  """
  Get the context that corresponds to an upcoming ad request made client side.
  """
  adContext(context: AdRequestContext!): AdContext

  """Get a single AdCreative."""
  adCreative(adSystem: String!, creativeID: ID!): AdCreative

  """Get all tags."""
  allTags(first: Int = 5, after: Cursor, tagScope: TagScope): TagConnection

  """Get AutoMod evaluation of text using AutoMod rule."""
  automodContent(input: AutoModContentInput!): AutoModContent

  """A list of global chat badges."""
  badges: [Badge]

  """
  Gets a list of Bits offers for a logged out user, for use on the Bits landing page.
  """
  bitsOffers: [BitsOffer!]

  """Returns a challenge by its ID."""
  challenge(id: ID!): ChannelChallenge

  """Get a list of the most recent changelog items."""
  changelogEntries(limit: Int = 15): [ChangelogEntry!]

  """Get a channel by ID or name."""
  channel(id: ID, name: String): Channel

  """Get a channel/viewer pair by login."""
  channelViewer(userLogin: String!, channelLogin: String!): ChannelViewer

  """Get a list of channels, either by IDs or by their names."""
  channels(ids: [ID!], names: [String!]): [Channel]

  """Get the ban status of a usser with respect to a channel's chat room."""
  chatRoomBanStatus(channelID: ID!, userID: ID!): ChatRoomBanStatus

  """
  GlobalCheerConfig contains information about (1) How to display Cheers and (2) What Cheermotes are globally available.
  """
  cheerConfig: GlobalCheerConfig!

  """Get the logged-in user's authorizations for a client ID."""
  clientAuthorization(id: ID!): ClientAuthorization

  """Get a clip by slug."""
  clip(slug: ID!): Clip

  """Get the state of a cloud broadcast for the given broadcastID."""
  cloudBroadcast(id: ID!): CloudBroadcast

  """Get the capabilities of a single cloud broadcast provider."""
  cloudBroadcastProvider(id: ID!): CloudBroadcastProvider

  """Get a single collection (playlist) item by its ID."""
  collection(id: ID!, options: CollectionOptions): Collection

  """Gets competition by ID."""
  competition(id: ID!): Competition

  """
  The features the user has access to when organizing competitions with the Versus product.
  """
  competitionOrganizerCapabilities: CompetitionOrganizerCapability

  """
  Gets a paginated list of competitions, commonly by its state. If state is
  UNKNOWN, the query will default to LIVE competitions.
  """
  competitions(first: Int = 10, after: Cursor, state: CompetitionState = UPCOMING): CompetitionConnection

  """Get a privacy consent status from a user, e.g. GDPR or CCPA."""
  consent(consentSessionID: ID!): Consent

  """Get a content tag by tag ID."""
  contentTag(id: ID!): Tag

  """Get content tags by tag IDs."""
  contentTags(ids: [ID!]): [Tag!]

  """Get a Creator Camp article."""
  creatorCampArticle(id: ID!, category: String!): CreatorCampArticle

  """Get a Creator Camp category."""
  creatorCampCategory(id: ID!): CreatorCampCategory

  """Get information populated in the Creator Dashboard."""
  creatorDashboard(startAt: Time!, endAt: Time!, period: TimeSeriesPeriod!): CreatorDashboard

  """Get information for the Creator Home page."""
  creatorHome: CreatorHome

  """Get the chanel/viewer pair with the current user and the channelID."""
  currentChannelViewer(channelID: ID!): ChannelViewer

  """
  The currently authenticated user.
  Returns null if the user is not authenticated.
  """
  currentUser: User

  """Fetch a single directory by name and type."""
  directory(name: String!, type: DirectoryType!): Directory

  """
  Fetch a single drop by ID. This could be either an event or time based drop.
  """
  drop(id: ID!): DropType

  """Fetch a single drop benefit by ID."""
  dropBenefit(id: ID!, ownerID: ID!): DropBenefit

  """Fetch a single drop campaign by ID."""
  dropCampaign(id: ID!): DropCampaign

  """
  Determine the currently logged in users eligibility for the specified drop.
  """
  dropEligibility(dropInstanceID: ID!): DropEligibility

  """Get an emote by ID."""
  emote(id: ID!): Emote

  """Get the current set of emote modifiers."""
  emoteModifiers: [CommunityPointsEmoteModifier!]

  """Get an emote set by ID."""
  emoteSet(id: ID!): EmoteSet

  """Experiment properties for temporary use."""
  experiment: Experiment

  """
  Get an Extension by ID. Optionally, provide a specific version. If no version is provided,
  the released version of that extension is returned.
  """
  extension(id: ID!, version: String): Extension

  """
  Get an ExtensionCarousel by ID. The default carousel can be loaded by providing the ID: "default".
  """
  extensionCarousel(id: ID!): ExtensionCarousel

  """
  Fetch a paginated list of Extension Categories. Each Category will provide the first ten
  extensions sorted by popularity in that category.
  """
  extensionCategories(first: Int = 10, after: Cursor): ExtensionCategoryConnection

  """
  Fetch a single category. Both slugs and ids are valid inputs for getting a category.
  """
  extensionCategory(id: ID!): ExtensionCategory

  """
  Fetch a single Extension Client by ID.
  An ExtensionClient is the authorization component of an extension.
  Returns Null if the current user doesn't have access to the extension.
  """
  extensionClient(id: ID!): ExtensionClient

  """Fetch a paginated list of Extension Clients."""
  extensionClients(organizationID: ID, after: Cursor): ExtensionClientConnection

  """Fetch an ExtensionManifest by ID and version."""
  extensionManifest(id: ID!, version: String!): ExtensionManifest

  """Fetch a paginated list of ExtensionManifests."""
  extensionManifests(id: ID!, after: Cursor): ExtensionManifestConnection

  """
  Fetch a Summary of the state of an extension. The Cursor is used to page extension manifests.
  """
  extensionManifestsSummary(id: ID!, after: Cursor): ExtensionManifestsSummary

  """
  extensionRatingsCSVReportPresignedURL asks the ExtensionRatings backend if the given report is completed, and if
  so, to generate and return a presigned S3 URL that the devsite can use to allow the user to download it.
  If the URL is not ready yet, the response will be an empty string.
  """
  extensionRatingsCSVReportPresignedURL(reportFilename: String!): ExtensionRatingsCSVReportPresignedURL

  """Fetch the authentication settings for a particular extension."""
  extensionSecrets(extensionID: ID!): ExtensionSecretsInfo

  """Fetch an ExtensionVersionDiscoveryManifest by ID and version."""
  extensionVersionDiscoveryManifest(id: ID!, version: String!): ExtensionVersionDiscoveryManifest

  """
  Search extensions by text found in the Extension name, description or summary. The results are
  always returned in order of popularity. By default, all RELEASED and IN_TEST extensions are returned.
  Pass RELEASED as the value of 'state' to only return extensions in the RELEASED state.
  """
  extensions(first: Int = 10, after: Cursor, search: String, state: ExtensionStateFilter): ExtensionConnection

  """
  Fetch the sections & content that should be featured on mobile
  `language` is a letter code for the language the requesting user speaks (e.g. "en").
  """
  featuredContentSections(language: String!): [FeaturedContentSection!]

  """
  Fetch streams that are featured on the front page, ordered by featurePriority ascending.
  DEPRECATED: `geolocation` is computed based on GeoIP with a fallback value of "US" and should be omitted
  `language` is a letter code for the language the requesting user speaks (ex. "en")
  By default returns 6 streams.
  """
  featuredStreams(first: Int = 6, geolocation: String, language: String, acceptedMature: Boolean = true): [FeaturedStream]

  """
  Fetch VODs that should be featured on the homepage
  `language` is a letter code for the language the requesting user speaks (e.g. "en").
  """
  featuredVideos(first: Int = 2, language: String!): [FeaturedVideo] @deprecated(reason: "Subject to change")

  """Get a Feed by ID."""
  feed(id: ID!): Feed @deprecated

  """Convert a URL to an object that can be embedded into Twitch feeds."""
  feedEmbed(url: String!): FeedEmbed @deprecated

  """Get a feed item by ID."""
  feedItemContent(id: ID!): FeedItemContent @deprecated

  """
  Get a single game as identified by its name or ID. At least one parameter must be provided.
  """
  game(name: String, id: ID): Game

  """
  Fetch games based on a variety of sorting options.
  By default returns 10 games, sorted by highest ccu.
  DEPRECATED field arguments: locale, tags
  Use GameOptions instead.
  """
  games(first: Int = 10, after: Cursor, options: GameOptions, locale: String, tags: [String!]): GameConnection

  """Get whether a username is available for registration."""
  isUsernameAvailable(username: String!): Boolean

  """Get key code information given a key code."""
  key(code: String!, countryOfResidence: String): Claimable

  """Get a chat message by its id."""
  message(id: ID!): Message

  """Get a list of the most recent Mod View Newsfeed items."""
  modViewNewsfeedEntries(first: Int = 10): [ModViewNewsfeedEntry!]

  """
  Returns a developer organization by ID.
  User must be apart of the organization.
  """
  organization(id: ID!): Organization

  """
  Gets a pending Twitch Developer Organization application of the currently authenticated user.
  This is deprecated due to multi-org and ability to have multiple applications.
  """
  pendingOrganizationApplication: OrganizationApplication @deprecated(reason: "Use pendingOrganizationApplications instead.")

  """
  Gets a pending Twitch Developer Organization applications of the currently authenticated user.
  """
  pendingOrganizationApplications: [OrganizationApplication!]

  """
  Get a list of sections(follows, recommendation) for the current user
  may not return all the requested section e.g requesting following section for logged out user.
  """
  personalSections(input: PersonalSectionInput!): [PersonalSection!]

  """Returns a poll by its ID."""
  poll(id: ID!): Poll

  """Returns a Prediction Event by its ID."""
  predictionEvent(id: ID!): PredictionEvent

  """
  Get Current PrimeOffers for a given region based on country code (request info or query param)
  optional dateOverride to provide offers that would be displayed on that date
  optional countryCode to provide offers that are displayed for that country
  optional locale to provide offers displayed for the supplied locale.
  """
  primeOffers(dateOverride: Time, countryCode: String, locale: String): [PrimeOffer!]!

  """
  Retrieve currently live Prime Gaming offers for a given region using the new eligibility architecture.
  If provided, dateOverride is used to specify offers that would be live on the given date.
  If provided, countryCode is used to specify offers that would be live in the given region.
  If provided, locale is used to specify the offer content language for the given locale.
  """
  primeOffersWithEligibility(dateOverride: Time, countryCode: String, locale: String): [PrimeOfferWithEligibility!]!

  """
  Retrieve currently live Prime Gaming offers for a given region.
  This query retrieves offer data without eligibility or entitlement information.
  If provided, dateOverride is used to specify offers that would be live on the given date.
  If provided, countryCode is used to specify offers that would be live in the given region.
  If provided, locale is used to specify the offer content language for the given locale.
  """
  primeOffersWithoutEligibility(dateOverride: Time, countryCode: String, locale: String): [PrimeOffer!]!

  """
  PrimePromotions data - query supports optional identifiers for promotion strings but default behavior will use
  countryCode and userID to find available marketing promotions. For whitelisted QA users dateOverride can be provided.
  """
  primePromotions(ids: [ID!], dateOverride: Time): [PrimePromotion]!

  """
  PrimeVideoBenefit returns a user's prime video benefits from Amazon. Requires an LWA token.
  """
  primeVideoBenefit(accessToken: String!): PrimeVideoBenefit

  """
  Get details about a purchasable offer for the current logged in user.
  This field can only be requested if an OAuth token is supplied with the request.
  If the OAuth token is not supplied or if the offer does not exist, this will return null.
  """
  purchasableOffer(params: PurchasableOfferParams!): Offer

  """
  Fetch radio content based on the content type, optionally filtered by an Amazon Standard Identification Number.
  """
  radioContent(contentType: RadioContentType!, id: ID): RadioContent @deprecated(reason: "Use specific user.radio queries instead.")

  """
  Fetch a group of recommended games.
  `recRequestID` is a tracking id created by the caller. This should be unique per request.
  `location` defines the source location of the recommended streams request (e.g. "TV_APPS").
  `context` contains parameters that are used to personalize recommendations (e.g. "Platform").
  """
  recommendedGames(first: Int = 6, recRequestID: ID!, location: String!, context: RecommendationsContext!): RecommendedGamesConnection

  """
  Fetch a group of recommended streams.
  `recRequestID` is a tracking id created by the caller. This should be unique per request.
  `location` defines the source location of the recommended streams request (e.g. "LEFT_NAV").
  `context` contains parameters that are used to personalize recommendations (e.g. "Platform").
  `filters` is an optional parameter that can be used to filter recommendation results.
  """
  recommendedStreams(first: Int = 6, recRequestID: ID!, location: String!, context: RecommendationsContext!, filters: StreamRecommendationsFilters): RecommendedStreamsConnection

  """Holds configuration necessary for calling Recurly."""
  recurlyConfigs(paymentSession: PaymentSession): RecurlyConfigs

  """Get a message rejected by chat."""
  rejectedChatMessage(id: ID!): RejectedChatMessage

  """Get a list of valid reasons for a content type."""
  reportReasons(content: ReportContentType!): [ReportReason!]

  """Get a list of valid country and ToS reasons for a content types."""
  reportToSAndCountryReasons(content: ReportContentType!): ReportToSAndCountryReasons

  """Metadata about the request to the API."""
  requestInfo: RequestInfo!

  """Get a room by its ID."""
  room(id: ID!): Room

  """
  Get a schedule segment by ID. Additional options can be provided to get the segment relative to a
  different time or timezone.
  """
  scheduleSegment(id: ID!, options: ScheduleSegmentOptions): ScheduleSegment

  """Get search results for a user's query."""
  search(userQuery: String!, platform: String!, options: SearchOptions): SearchResult @deprecated(reason: "Use the 'searchFor' query instead.")

  """Search for tags to apply to a channel."""
  searchApplicableTags(userQuery: String!, limit: Int = 15): [Tag!]

  """Get search results for categories/games."""
  searchCategories(query: String!, first: Int = 25, after: Cursor): SearchCategoriesConnection

  """Search for category tags to filter categories in Browse."""
  searchCategoryTags(userQuery: String!, limit: Int = 15): [Tag!]

  """Get gql search results for a user's query."""
  searchFor(userQuery: String!, platform: String!, options: SearchForOptions, target: SearchForTarget, requestID: ID): SearchFor

  """Search for tags to filter live channels in Browse."""
  searchLiveTags(userQuery: String!, categoryID: ID, limit: Int = 15): [Tag!]

  """Get Live Streams in search by user query."""
  searchStreams(userQuery: String!, first: Int = 25, after: Cursor): SearchStreamConnection

  """Get search suggestions for a user's query."""
  searchSuggestions(queryFragment: String!, requestID: ID): SearchSuggestionConnection

  """
  Get users by query in search. for search page product use searchFor instead.
  """
  searchUsers(userQuery: String!, first: Int = 25, after: Cursor): SearchUserConnection

  """
  Fetch shelves to display on the homepage.
  DEPRECATED field arguments: platform (use context.platform), langWeightedCCU.
  """
  shelves(requestID: String!, platform: String!, langWeightedCCU: Boolean, first: Int, itemsPerRow: Int = 12, context: RecommendationsContext): ShelfConnection

  """Get paginated short video feed."""
  shortVideoFeed(first: Int = 3, after: Cursor, options: ShortVideoFeedOptions): ShortVideoFeedConnection @deprecated

  """
  Whether or not the Twitch Developers CSAT callout should appear for the currently authenticated user.
  """
  shouldShowDevsiteCSAT: Boolean

  """Get a squad stream by ID."""
  squadStream(id: ID!): SquadStream

  """
  The playback access token that determines whether the user can watch the live stream
  Fetched for both authed and unauthed users.
  """
  streamPlaybackAccessToken(channelName: String!, params: PlaybackAccessTokenParams!): PlaybackAccessToken

  """
  Fetch live streams, ordered by the number of viewers descending.
  languages can be empty or null, which will imply all the languages are included on the results.
  tags are an array of tag ID as optional filters for streams.
  DEPRECATED field arguments: platformType, languageTags, tags
  Use StreamOptions instead.
  """
  streams(first: Int = 10, after: Cursor, options: StreamOptions, platformType: PlatformType = all, languages: [Language!], input: StreamMetadataFilterInput, tags: [String!]): StreamConnection

  """
  Get a subscription product by its name. See product name examples below. The productName uniquely identifies a product.
  
  e.g. "meclipse", "meclipse_2000", "meclipse_3000", these are respectively, the tier 1, 2, and 3 subscription product
  names for the user with login "shroud".
  """
  subscriptionProduct(productName: String!): SubscriptionProduct

  """
  Get all avaialble token bundle products available for the user.
  CountryCode will need to be in ISO 3166 Alpha-2 format(e.g. "US", "BR", "HK").
  """
  subscriptionTokenBundleProducts(countryCode: String, channelID: ID): [SubscriptionTokenBundleProduct!]

  """Gets the Token Product Config."""
  subscriptionTokenProductConfig: SubscriptionTokenProductConfig

  """
  Gets a list of cloud broadcast providers that can be used by clients to start a broadcast via the provider.
  """
  supportedCloudBroadcastProviders: [CloudBroadcastProviderKey!]

  """Get the logged in user's available hero assets."""
  supportedHeroAssets: [HeroAsset!]!

  """Get the verticals available for a particular user."""
  supportedVerticals(recommendationsContext: RecommendationsContext!): [VerticalDirectory!]

  """Gets a team by its Twitch name."""
  team(name: String!): Team

  """
  Gets a list of sorted top tags aggregated from all tags applied to current live channels.
  """
  topTags(limit: Int = 5): [Tag!]

  """Get localized metadata for any twitch's website url."""
  urlMetadata(url: String!): URLMetadata

  """
  Get a user by their ID or login.
  If no ID or login is provided, null is returned.
  Lookup type can tell the resolver to include all users (inclusing deleted and
  suspended accounts) on the lookup, defaults to only retrieve active users.
  """
  user(id: ID, login: String, lookupType: UserLookupType = ACTIVE): User

  """Fetch the user by a specific attribute."""
  userByAttribute(input: UserByAttribute!): User

  """
  Fetch a user by their ID, or receive a reason indicating
  why the user could not be retrieved.
  """
  userResultByID(id: ID!): UserResult

  """
  Fetch a user by their login, or receive a reason indicating
  why the user could not be retrieved.
  """
  userResultByLogin(login: String!): UserResult

  """Get a list of users, either by their logins or by their IDs."""
  users(ids: [ID!], logins: [String!]): [User]

  """
  Get a verification request given an opaqueID.
  These are generally email verification requests, but could be phone-numbers in the future.
  """
  verificationRequest(opaqueID: ID!): VerificationRequest

  """Get content for a vertical directory by its ID."""
  verticalDirectory(id: ID!, recommendationsContext: RecommendationsContext!, contentMin: Int!, contentMax: Int!): VerticalDirectory

  """
  Get content for a vertical subdirectory filtered by one or more context IDs (ex: category ID, tag ID).
  """
  verticalSubDirectory(id: ID!, contentContext: VerticalSubDirectoryContentContext, recommendationsContext: RecommendationsContext!, contentMin: Int!, contentMax: Int!): VerticalSubDirectory

  """
  Get a video by its ID.
  By default, Video queries only return public videos.
  If the owner should also see their own private videos, set includePrivate flag in the `options` input.
  This flag does not include other people's private videos.
  """
  video(id: ID, options: VideoOptions): Video

  """A paginated list of comments against id, videoID, or channelID."""
  videoComments(first: Int, after: Cursor, last: Int, Before: Cursor, id: String, videoID: String, channelID: String): VideoCommentConnection

  """
  Get the current or past video ingest metadata such as bitrates and codecs by its ID and channelID.
  Optional customerID for staffs.
  """
  videoIngestSession(id: ID!, channelID: ID!, customerID: ID): VideoIngestSession

  """
  Get the current video ingest metadata such as bitrates and codecs starting a
  specified number of seconds ago by channelID. Optional customerID for staffs.
  """
  videoIngestSessionLatest(channelID: ID!, customerID: ID, secondsAgo: Int!): VideoIngestSession

  """
  Get the current or past video ingest metadata such as bitrates and codecs by
  time range and channelID. Optional customerID for staffs.
  """
  videoIngestSessions(channelID: ID!, customerID: ID, startedAt: Time!, endedAt: Time!): [VideoIngestSession!]

  """
  The playback access token that determines whether the user can watch the video.
  Fetched for both authed and unauthed users.
  """
  videoPlaybackAccessToken(id: ID!, params: PlaybackAccessTokenParams!): PlaybackAccessToken

  """Get a list of videos in order of descending popularity."""
  videos(first: Int = 10, after: Cursor, broadcastType: BroadcastType, language: Language): VideoConnection

  """Get a list of Prime Video items for Watch Parties."""
  watchPartyItems(first: Int = 20, after: Cursor, accessToken: String, options: WatchPartyItemSearchOptions): WatchPartyItemConnection

  """Get a whisper thread by ID."""
  whisperThread(id: ID): WhisperThread
}

"""Interval that a quest is being evaluated for."""
type QuestEvaluationInterval {
  """Duration of the interval (in days)."""
  durationInDays: Int!

  """End time of the interval."""
  endTime: Time!

  """Start time of the interval."""
  startTime: Time!
}

"""Progress towards a particular quest goal."""
type QuestGoalFloat {
  """Current progress towards quest goal."""
  current: Float!

  """Number needed to complete the quest goal."""
  goal: Float!
}

"""Progress towards a particular quest goal."""
type QuestGoalInt {
  """Current progress towards quest goal."""
  current: Int!

  """Number needed to complete the quest goal."""
  goal: Int!
}

"""The quests associated with a user."""
type Quests {
  """"Build a Community" quest."""
  buildACommunity: BuildACommunity

  """"It Begins" quest."""
  itBegins: ItBegins

  """"Path to Affiliate" quest."""
  pathToAffiliate: PathToAffiliate

  """"Path to Partner" quest."""
  pathToPartner: PathToPartner
}

"""Twitch Radio access."""
type Radio {
  """Twitch Radio account information for the user."""
  account: RadioAccount!

  """Fetch the requesting user's currently playing radio content."""
  currentlyPlaying: RadioCurrentlyPlaying! @deprecated(reason: "Use 'currentRadioTrack' in 'channel' instead.")

  """
  Fetch a radio playlist by ID. Tracks can be requested here, but can be slow to respond.
  """
  playlist(id: ID!): RadioPlaylist

  """
  Fetch all, or filtered subset of, radio playlists. Cannot request track data from this query.
  """
  playlists(filter: RadioPlaylistFilter): [RadioPlaylist!]!

  """
  Fetch the requesting user's recently played radio content ids. Optionally filtered by type.
  """
  recentlyPlayed(filter: RadioRecentlyPlayedFilter): [RadioRecentlyPlayed!]!

  """
  Fetch a radio station by ID. Returns the initial queue with a token to get the next tracks if no pageToken is passed.
  """
  station(id: ID!, pageToken: String, numberOfTracks: Int): RadioStation

  """Fetch all radio stations."""
  stations: [RadioStation!]!
}

"""Amazon Music user information for a Twitch user using Twitch Radio."""
type RadioAccount {
  """The Twitch user's ID as known in Amazon Music."""
  customerID: ID!

  """The unique Amazon client device identifier for this user and service."""
  deviceID: ID!

  """ISO 3166-1 alpha-2 country code territory of the user in Amazon Music."""
  musicTerritory: String!

  """User token to authenticate with Amazon services"""
  amazonAccessToken: String!
  tokenExpiresAt: Time!
}

"""A Twitch Radio Album."""
type RadioAlbum {
  """The album's unique id (an Amazon Standard Identification Number)."""
  id: ID!

  """URL to the album's main image."""
  imageURL: String!

  """The album name."""
  name: String!
}

"""A Twitch Radio artist."""
type RadioArtist {
  """The creator channel."""
  channel: Channel

  """The creator channel id."""
  creatorChannelID: ID

  """The artist's unique id (an Amazon Standard Identification Number)."""
  id: ID!

  """The artist name."""
  name: String!
}

"""A container for Twitch Radio content request results."""
type RadioContent {
  """The requested playlists."""
  items: [RadioContentItem!]
}

"""
The types of radio content that can be requested (e.g., playlists, stations, tracks, etc).
"""
union RadioContentItem = RadioPlaylist | RadioRecentlyPlayed

"""A Twitch Radio LinkFire Input Response for Content Promotion."""
type RadioContentPromotion {
  """Text on the redirect button."""
  buttonText: String!

  """
  Icon for the media service having dark/light theme assets. Formats supported: PNG, SVG. Default value is SVG.
  """
  icon(format: RadioIconFormat = SVG): RadioIconThemeAssets!

  """
  IconURL for the media service. Formats supported: PNG, SVG. Default value is SVG.
  """
  iconURL(format: RadioIconFormat = SVG): String! @deprecated(reason: "Use 'icon' instead.")

  """Rank to order the icons."""
  rank: Int!

  """Title of the service."""
  title: String!

  """URL to redirect to the service."""
  url: String!
}

"""The different Twitch Radio collection types that can be requested."""
enum RadioContentType {
  """Retrieve playlists, can be filtered by ASIN."""
  PLAYLIST

  """Retrieve the user's recently played playlists."""
  RECENTLY_PLAYED
}

"""Content currently playing in the client for a user."""
type RadioCurrentlyPlaying {
  """The radio content promotion json data."""
  contentPromotions: [RadioContentPromotion!]

  """Whether the track is currently playing or not."""
  isCurrentlyPlaying: Boolean!

  """The Track Details of the currently playing track."""
  track: RadioTrack
}

"""The types of content we can register current plays for."""
enum RadioCurrentlyPlayingType {
  """A radio playlist."""
  PLAYLIST

  """A radio station."""
  STATION
}

"""The currently playing radio track addition result."""
type RadioCurrentTrackResponse {
  """Radio currently Playing Track is added Successfully or not."""
  isSuccess: Boolean!
}

"""Icon Formats for the media service."""
enum RadioIconFormat {
  """PNG Icon for the media service."""
  PNG

  """SVG Icon for the media service."""
  SVG
}

"""Theme for the media service assets."""
type RadioIconThemeAssets {
  """Dark theme Asset URL."""
  darkURL: String!

  """Light theme Asset URL."""
  lightURL: String!
}

"""A Twitch Radio playlist."""
type RadioPlaylist {
  """Curator of the playlist."""
  curator: String!

  """Playlist's Description."""
  description: String!

  """The playlist's unique id (an Amazon Standard Identification Number)."""
  id: ID!

  """URL to the playlist's main image."""
  imageURL: String!

  """Is the playlist featured."""
  isFeatured: Boolean!

  """The playlist's title."""
  title: String!

  """List of tracks in the playlist."""
  tracks: [RadioTrack!]
}

"""Filters for querying the playlists."""
enum RadioPlaylistFilter {
  """Get all playlists."""
  ALL

  """Get only featured playlists."""
  FEATURED
}

"""Content recently played in the client."""
type RadioRecentlyPlayed {
  """The type of content the ID maps to."""
  contentType: RadioRecentlyPlayedType!

  """The id of the recently played item."""
  id: ID!

  """Recently played playlist metadata."""
  playlist: RadioPlaylist

  """Recently played station metadata."""
  station: RadioStation

  """The time this ID was last recently played by the current user."""
  updatedAt: Time!
}

"""Filter for recentlyPlayed."""
enum RadioRecentlyPlayedFilter {
  """Get all recently played items."""
  ALL

  """Retrieve only playlists."""
  PLAYLISTS
}

"""The types of content we can register recent plays for."""
enum RadioRecentlyPlayedType {
  """A radio playlist."""
  PLAYLIST

  """A radio station."""
  STATION
}

"""A Twitch Radio station."""
type RadioStation {
  """The station's unique id (an Amazon Standard Identification Number)."""
  id: ID!

  """URL to the station's main image."""
  imageURL: String!

  """Is the station featured."""
  isFeatured: Boolean!

  """
  Page token to be passed back to the Client Gateway when requesting additional tracks.
  """
  pageToken: String

  """The station's title."""
  title: String!

  """List of tracks in the station."""
  tracks: [RadioTrack!]
}

"""A Twitch Radio track."""
type RadioTrack {
  """The track album."""
  album: RadioAlbum!

  """The track artists."""
  artists: [RadioArtist!]!

  """The duration of the track in seconds."""
  duration: Int!

  """Track's Genre."""
  genre: String!

  """The track's unique id (an Amazon Standard Identification Number)."""
  id: ID!

  """Industry standard track's unique id."""
  isrc: String!

  """The title of the track."""
  title: String!
}

"""
A raid represents a broadcaster directing their viewers to another channel
in a synchronized "raid" on the channel after a countdown during which
each viewer has a chance to opt out of the raid.

Raids are created by a broadcaster from their dashbboard where they can search
and select the channel they wish to target. Once selected the raid takes counts
down to prepare after which the broadcaster can tell the raid to "Go", redirecting
all joined raiders to the target channel.
"""
type Raid {
  """Timestamp of raid announcement."""
  announceAt: Time

  """Timestamp of raid go time."""
  goAt: Time

  """The ID of the raid."""
  id: ID!

  """Channel hosting the raid."""
  sourceChannel: User

  """Target of the raid."""
  targetChannel: User

  """Number of viewers in raid."""
  viewerCount: Int
}

"""A user's raid settings."""
type RaidSettings {
  """Determines what other channels can raid this channel."""
  incomingRaidsPolicy: IncomingRaidsPolicy!
}

"""An integer range with a minimum and a maximum."""
type Range {
  """The maximum value of the Range."""
  max: Int!

  """The minimum value of the Range."""
  min: Int!
}

"""Possible errors returned by the RateExtension mutation."""
enum RateExtensionError {
  """Internal service error eg. database timeout."""
  INTERNAL_ERROR
}

"""
RateExtensionInput submits a user's rating and feedback on a Twitch extension.
"""
input RateExtensionInput {
  """The ID of the extension being rated."""
  extensionClientID: ID!

  """The version of the extension being rated."""
  extensionVersion: String!

  """Whether the user recommends the extension or not."""
  isRecommended: Boolean!

  """Indicates from where the user submitted the rating."""
  location: ExtensionRatingLocation!

  """The ID of the user performing the rating."""
  userID: ID!
}

"""The result of a rateExtension mutation."""
type RateExtensionPayload {
  """The error if the mutation fails to submit the extension rating."""
  error: RateExtensionError

  """The resulting ExtensionRating record."""
  rating: ExtensionRating
}

union ReactableContent = Clip | Post | Stream | Video

type Reaction {
  """count of users that reacted with a particular Emote."""
  count: Int!

  """The Emote associated with the Reaction."""
  emote: Emote!

  """The authenticated user's relationship with this reaction."""
  self: ReactionSelfConnection!
}

type ReactionSelfConnection {
  """Did the authenticated user react."""
  hasReacted: Boolean!
}

input ReadNotificationsInput {
  """
  IDs of the notifications to set as read. The minimum number is 1 and the maximum is 100.
  """
  ids: [ID!]!
}

type ReadNotificationsPayload {
  """The amount of notifications that were set to read."""
  count: Int!

  """
  The notifications that were set to read. Only ID and isRead are accessible.
  """
  notifications: [OnsiteNotification]!
}

"""Feedback from a user about a piece of content."""
type RecommendationFeedback {
  """Reason for feedback."""
  category: RecommendationFeedbackCategory!

  """Feedback target."""
  content: RecommendationFeedbackContent

  """
  Recommendation Feedback ID. Generated from the type, category, content id, and user id.
  """
  id: ID!

  """Last time this feedback was given."""
  lastUpdated: Time!

  """Feedback target type."""
  type: RecommendationFeedbackType!

  """Feedback giver."""
  user: User
}

"""Reason for feedback."""
enum RecommendationFeedbackCategory {
  """
  Only returned when there is an issue. Shouldn't be returned, should not be used for fetching.
  """
  UNSPECIFIED

  """The user is not interested in this type of content."""
  NOT_INTERESTED

  """The user finds this type of content to be offensive."""
  OFFENSIVE

  """The user has already seen this content."""
  ALREADY_WATCHED

  """
  Used when the other reasons do not capture the reason a user is giving feedback.
  """
  OTHER
}

"""Connection between a user and recommendation feedback."""
type RecommendationFeedbackConnection {
  """Contains the edges for the recommendation feedback."""
  edges: [RecommendationFeedbackEdge!]

  """Contains pagination metadata."""
  pageInfo: PageInfo!
}

"""Feedback target."""
union RecommendationFeedbackContent = Channel | Game | Video

"""Edge containing the node and cursor for recommendation feedback items."""
type RecommendationFeedbackEdge {
  """Cursor for the feedback edge."""
  cursor: Cursor!

  """Node for the feedback edge."""
  node: RecommendationFeedback
}

"""Feedback target type."""
enum RecommendationFeedbackType {
  """
  Only returned when there is an issue. Shouldn't be returned, should not be used for fetching.
  """
  UNSPECIFIED

  """Feedback given about channels."""
  CHANNEL

  """Feedback given about a game / category."""
  CATEGORY

  """Feedback given about a shelf."""
  SHELF

  """Feedback given about a video."""
  VOD
}

type Recommendations {
  """
  The recommended community gifting quantities to display to the user when they intend to gift subscriptions.
  The trackingID is not a unique ID for the recommendations, but a passthrough
  value for backend logging to link to purchases made by the user after being
  shown these recommendations.
  """
  communityGiftQuantities(trackingID: ID!): [Int!]

  """A list of recommended friends."""
  friends: [RecommendedFriend]

  """
  Live recommendations.
  recRequestID is a tracking id created by the caller. Should be unique per request.
  """
  liveRecommendations(first: Int = 10, recRequestID: String!, language: String!, location: String, context: RecommendationsContext): LiveRecommendationConnection

  """Stream recommendations."""
  streams(first: Int = 10): RecommendedStreamConnection @deprecated(reason: "use a specific recommendation instead")

  """A list of recommended VODs."""
  videos(first: Int = 10, after: Cursor): RecommendedVideoConnection @deprecated(reason: "this feature has been sunset")
}

"""
RecommendationsContext define parameters which can control recommendations logic.
Clients should strive to fill in as many fields as possible for the highest quality recommendaitons.
Many of these fields should be identical to what is sent in pageview events:
https://blueprint.di.xarth.tv/#/schema/pageview.
"""
input RecommendationsContext {
  """The 'app_window_height' field sent in pageview events."""
  appWindowHeight: Int

  """The 'app_window_width' field sent in pageview events."""
  appWindowWidth: Int

  """The 'client_app' field sent in pageview events."""
  clientApp: String

  """
  Optional ISO country code, defaults to use the country code from the geoip of the request.
  """
  country: String

  """
  The 'location' field sent in pageview events (signifying the location on the site or app).
  """
  location: String

  """Web, ios, android, etc."""
  platform: String

  """The 'referrer_domain' field sent in pageview events."""
  referrerDomain: String

  """The 'viewport_height' field sent in pageview events."""
  viewportHeight: Int

  """The 'viewport_width' field sent in pageview events."""
  viewportWidth: Int
}

type RecommendedFriend {
  """Reason why this recommendation was made."""
  reason: String

  """The user recommended to be a friend of the source user."""
  user: User
}

"""
The response of a recommended games request which contains a list of recommended games.
"""
type RecommendedGamesConnection {
  """A list of recommended games."""
  edges: [RecommendedGamesEdge!]

  """Per-generation tracking id for identifying a recommendation model."""
  generationID: ID!

  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  pageInfo: PageInfo!

  """Unique tracking id per response."""
  responseID: ID!
}

"""The content to render from a recommended game."""
type RecommendedGamesEdge {
  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  cursor: Cursor!

  """The underlying game content to render."""
  node: Game

  """Globally unique id per category used in client tracking."""
  trackingID: ID!
}

interface RecommendedStream {
  """The recommended stream."""
  stream: Stream

  """
  The type of recommendation. Different types contain different metadata about why the recommendation was made.
  """
  type: StreamRecommendationType
}

"""NOTE: this type will soon be removed."""
type RecommendedStreamConnection {
  """This field is deprecated."""
  nodes: [RecommendedStream] @deprecated(reason: "This field has been sunset")
}

"""
The response of a recommended streams request which contains a list of recommended streams.
"""
type RecommendedStreamsConnection {
  """A list of recommended streams."""
  edges: [RecommendedStreamsEdge!]

  """Per-generation tracking id for identifying a recommendation model."""
  generationID: ID!

  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  pageInfo: PageInfo!

  """Unique tracking id per response."""
  responseID: ID!
}

"""The content to render from a recommended stream."""
type RecommendedStreamsEdge {
  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  cursor: Cursor!

  """The underlying stream content to render."""
  node: Stream

  """Globally unique id per stream used in client tracking."""
  trackingID: ID!
}

type RecommendedVideoConnection {
  edges: [RecommendedVideoEdge]
  pageInfo: PageInfo

  """A unique ID for this generated list of recommendations."""
  setID: String
}

type RecommendedVideoEdge {
  cursor: Cursor
  node: Video
}

"""Record ad event error."""
type RecordAdEventError {
  """Error from recording ad event."""
  code: RecordAdEventErrorCode!
}

"""Enumeration of RecordAdEvent error status codes."""
enum RecordAdEventErrorCode {
  """The RAd token in the request was not valid."""
  INVALID_TOKEN

  """The event payload was invalid."""
  INVALID_JSON

  """An internal error has occurred, other than a 500."""
  UNKNOWN_ERROR
}

"""The input for recording an ad event."""
input RecordAdEventInput {
  """The ad event name."""
  eventName: String!

  """Ad details JSON encoded as a string."""
  eventPayload: String!

  """The RAd service token used for validation."""
  radToken: String!
}

"""The payload returned after recording an ad event."""
type RecordAdEventPayload {
  """Error from mutation, if one exists."""
  error: RecordAdEventError
}

type RecurlyConfigs {
  """
  For interacting with the Braintree gateway and Paypal (supported by Recurly).
  """
  braintreeClientAuthorization: String!

  """For interacting with Pay With Amazon gateway (supported by Recurly)."""
  payWithAmazonConfigs: PayWithAmazonConfigs!

  """Sent to Recurly to identify requests."""
  publicKey: String!
}

"""
Payment Method information for a recurring payment.
An abstraction for a set of Payments models, existing here to surface to the Payments Management Page.
"""
type RecurringPaymentDetail {
  """Time that the payment will attempt to renew."""
  expiresAt: Time

  """Product type of the purchase."""
  productType: SubscriptionProductType!

  """Currency for the renewalPrice, e.g. "USD"."""
  renewalCurrency: String

  """
  Expected renewal price of the product in the smallest subunit of the currency, e.g. "499".
  """
  renewalPrice: Int

  """Divisor for renewalPrice for display: e.g. "100" for USD."""
  renewalPriceDivisor: Int

  """Subscription benefit, if still active."""
  subscriptionBenefit: SubscriptionBenefit

  """Twitch user ID, owner of the entitlement benefit."""
  ticketOwnerID: ID

  """
  Twitch user ID, owner of the channel that was subscribed to.
  Can be null if product type is Turbo.
  """
  ticketProductOwnerID: ID

  """
  Whether this subscription will renew in the future and charge the user's payment method.
  """
  willRenew: Boolean!
}

"""Redeem claimable error."""
type RedeemClaimableError {
  """Error code while redeeming."""
  code: RedeemClaimableErrorCode!
}

"""Redeem claimable error status codes."""
enum RedeemClaimableErrorCode {
  """The request has been throttled."""
  REQUEST_THROTTLED

  """The user is not allowed to redeem this key."""
  UNAUTHORIZED

  """The key has already been claimed."""
  ALREADY_CLAIMED

  """Unknown error being returned from service."""
  UNKNOWN

  """
  Invalid PIN/Claimable.
  Currently only used for Gift Card PINs.
  """
  INVALID_PIN

  """
  PIN already redeemed.
  Currently only used for Gift Card PINs.
  """
  ALREADY_REDEEMED

  """
  User can't redeem due to wallet balance limit
  Currently only used for Gift Card PINs.
  """
  EXCEEDED_WALLET_BALANCE

  """
  Two Factor Auth is required past a certain balance
  for fraud mitigation. Currently only used for Gift Card PINs.
  """
  TWO_FACTOR_REQUIRED

  """
  Unsupported Country of Residence
  Currently only used for Gift Card PINs.
  """
  INVALID_COUNTRY_OF_RESIDENCE

  """
  User excedded redemption velocity limit.
  Currently only used for Gift Card PINs.
  """
  EXCEEDED_VELOCITY_LIMIT
}

"""The input for claiming a key code."""
input RedeemClaimableInput {
  """
  Optional param for user's self-declared country of residence.
  Currently only used for Gift Card Redemptions.
  """
  countryOfResidence: String

  """The key code that needs to be claimed."""
  keyCode: String!
}

"""The payload returned after claiming a key code."""
type RedeemClaimablePayload {
  """Possible errors returned from the service for this mutation."""
  error: RedeemClaimableError

  """The updated key information."""
  key: Claimable
}

"""An error from redeeming a custom Community Points reward in a channel."""
type RedeemCommunityPointsCustomRewardError {
  """An identifier for the error that occurred."""
  code: RedeemCommunityPointsCustomRewardErrorCode
}

"""
The possible reasons redeeming a custom Community Points reward in a channel could fail.
"""
enum RedeemCommunityPointsCustomRewardErrorCode {
  """The reward was not found."""
  NOT_FOUND

  """The current user is not allowed to redeem this reward in this channel."""
  FORBIDDEN

  """The user does not have sufficient points to redeem the reward."""
  NOT_ENOUGH_POINTS

  """
  The client-provided properties (title, cost, or prompt) did not match the reward's true properties.
  """
  PROPERTIES_MISMATCH

  """
  The client is retrying a redemption with a transaction id that has already been redeemed.
  """
  DUPLICATE_TRANSACTION

  """
  The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
  """
  TRANSACTION_IN_PROGRESS

  """The reward is disabled."""
  DISABLED

  """The stream is not live."""
  STREAM_NOT_LIVE

  """The reward has hit its maximum number of redemptions per stream."""
  MAX_PER_STREAM

  """The user is banned and cannot redeem rewards."""
  USER_BANNED

  """The redemption message contained a blocked phrase."""
  CHANNEL_SETTINGS

  """The redemption message starts with a '/' like a chat command."""
  MESSAGE_IS_COMMAND

  """An unknown error occurred."""
  UNKNOWN

  """
  The reward has hit its maximum number of redempetions per user per stream.
  """
  MAX_PER_USER_PER_STREAM

  """The reward is currently under a cooldown."""
  GLOBAL_COOLDOWN
}

"""Input for redeeming a custom Community Points reward in a channel."""
input RedeemCommunityPointsCustomRewardInput {
  """The channel ID that the reward is being redeemed in."""
  channelID: ID!

  """
  The cost that the client expects this reward to cost.
  If this cost is different from the reward's true cost, the request will fail.
  """
  cost: Int!

  """
  The prompt that the client expects this reward to have.
  If this prompt is different from the reward's true prompt, the request will fail.
  Should be null if the reward does not have a prompt.
  """
  prompt: String

  """The unique reward ID."""
  rewardID: ID!

  """
  For rewards that require text input, this is the user-supplied text.
  Discarded if the reward does not require text input.
  """
  textInput: String

  """
  The title that the client expects this reward to have.
  If this title is different from the reward's true title, the request will fail.
  """
  title: String!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""
The response from redeeming a custom Community Points reward in a channel.
"""
type RedeemCommunityPointsCustomRewardPayload {
  """
  An error that occurred while redeeming a custom Community Points reward in a channel.
  """
  error: RedeemCommunityPointsCustomRewardError

  """The newly created redemption."""
  redemption: CommunityPointsCustomRewardRedemption
}

"""
RedeeemCreatorGiftsInput the input for redeeming subscriptions from a creator's balance.
"""
input RedeemCreatorGiftsInput {
  """
  The amount of balance to redeem. This value must be greater than 0 and less than the creator's
  standing balance.
  """
  amount: Int!
}

"""
RedeemCreatorGiftsPayload the output of redeeming subscriptions from a creator's balance.
"""
type RedeemCreatorGiftsPayload {
  """The container for creator gifts the creator has."""
  creatorGifting: CreatorGifting
}

type RedeemRitualTokenError {
  code: RedeemRitualTokenErrorCode!
}

enum RedeemRitualTokenErrorCode {
  """Token is not in a status that can be redeemed."""
  TOKEN_NOT_AVAILABLE

  """Token does not exist."""
  TOKEN_NOT_FOUND

  """
  User is not a follower and tried redeeming the token in a follower-only chat.
  """
  FOLLOWER_ONLY_MODE_ENFORCEMENT_FAILED

  """
  User is not a subscriber and tried redeeming the token in a subs-only chat.
  """
  SUB_ONLY_MODE_ENFORCEMENT_FAILED

  """User is banned in the channel."""
  USER_CHAT_BANNED

  """User is timed out in the channel."""
  USER_CHAT_TIMED_OUT
}

"""RedeemRitualTokenInput is the input when redeeming a ritual token."""
input RedeemRitualTokenInput {
  """The channel to redeem the token in."""
  channelID: ID!

  """User-specified text to send with the token redemption."""
  messageText: String

  """The type of ritual to be redeemed."""
  type: RitualTokenType!
}

"""
RedeemRitualTokenPayload is the response when redeeming a ritual token.
"""
type RedeemRitualTokenPayload {
  error: RedeemRitualTokenError
  token: RitualToken
}

"""RedeemSubscriptionInput creates a new subscription redemption input."""
input RedeemSubscriptionInput {
  """
  The channelID to which the user is currently subscribed to and is allowing to redeem a subscription.
  """
  fromChannelID: ID!

  """The channelID to which the user wants to redeem their subscription to."""
  targetChannelID: ID!

  """The User who is trying to redeem the subscription."""
  userID: ID!
}

"""
RedeemSubscriptionPayload returns a status code indicating whether the update was successful or not.
"""
type RedeemSubscriptionPayload {
  """
  A code indicating why the redemption of subscription failed, if it did.
  """
  errorCode: RedeemSubscriptionResponseErrorCode

  """The Subscription Product that the user has been entitled to."""
  product: SubscriptionProduct
}

"""An Error indicating why the submit failed, if it did."""
enum RedeemSubscriptionResponseErrorCode {
  """The Channel ID is invalid."""
  INVALID_CHANNEL

  """The User is not Eligible to Redeem Subscription to this Channel."""
  NOT_ELIGIBLE

  """Something unexpected occured when Redeeming the Subscription."""
  UNKNOWN

  """The User has already redeemed the subscription offerd by the channel."""
  USER_HAS_REDEEMED_SUBSCRIPTION

  """
  The channel the user is trying to redeem from has not been off-boarded.
  """
  CHANNEL_NOT_OFF_BOARDED

  """
  The user already has an existing subscription to the target channel they are trying to redeem to.
  """
  USER_HAS_EXISTING_SUBSCRIPTION

  """The target Channel the user is trying to redeem to is Invalid."""
  REDEEM_CHANNEL_INVALID

  """The user is not subscribed to the channel that is being off-boarded."""
  USER_NOT_SUBSCRIBED_TO_OFF_BOARDED_CHANNEL
}

input RedeemTrueXAdInput {
  """
  args are parameters describing the engagement the user just completed for bits.
  """
  args: String!

  """signature is a digital signature protecting the integrity of `args`."""
  signature: String!

  """
  targetID is the `User.id` of the channel where the user is watching the ad.
  """
  targetID: ID

  """
  trueXAd is descriptive information about the engagement that was just shown.
  This information is useful for logging errors on the server-side.
  """
  trueXAd: TrueXAd
}

type RedeemTrueXAdPayload {
  """
  currentUser is the authenticated user object which includes the updated
  `Wallet` info after the message bits have been spent.
  """
  currentUser: User

  """
  grantedBits is the number of bits the user earned from this engagement.
  """
  grantedBits: Int!
}

"""How to group the referral sources."""
enum ReferralsDimension {
  """Return referrals grouped by platforms."""
  PLATFORM

  """Return referrals grouped by country."""
  COUNTRY

  """Return referrals grouped by channel."""
  CHANNEL

  """Return referrals grouped by internal source."""
  INTERNAL

  """Return referrals grouped by external source."""
  EXTERNAL
}

"""Which subset of referrals to return."""
enum ReferralsFilter {
  """Return all referral sources."""
  ALL

  """
  Return live video play referrals from external sources, filtered by the web platform.
  """
  EXTERNAL_LIVE_WEB

  """
  Return live video play referrals from internal channels, filtered by the web platform.
  """
  INTERNAL_CHANNEL_LIVE_WEB

  """
  Return live video play referrals from internal sources, filtered by the web platform.
  """
  INTERNAL_LIVE_WEB
}

"""The required input for an RefreshExtensionToken mutation."""
input RefreshExtensionTokenInput {
  """The id of the channel the extension is currently installed on."""
  channelID: ID!

  """The ID of the extension that the user is refreshing their token for."""
  extensionID: ID!

  """The current extension jwt being refreshed."""
  jwt: String
}

"""The result of a RefreshExtensionToken mutation."""
type RefreshExtensionTokenPayload {
  """Error from an RefreshExtensionToken Call."""
  error: String

  """The user's new token."""
  token: ExtensionToken
}

"""
RegenerateStreamKeyInput is input required to regenerate a broadcaster's stream key.
"""
input RegenerateStreamKeyInput {
  """channelID of the broadcaster."""
  channelID: ID!
}

"""
RegenerateStreamKeyPayload contains the VideoStreamSettings with updated stream key.
"""
type RegenerateStreamKeyPayload {
  """The updated video stream for channel."""
  channel: Channel
}

"""
RegenerateVerificationCodeInput is input required to regenerate a user's verification code in EVS.
"""
input RegenerateVerificationCodeInput {
  """
  Address that the user is verifying. This will most likely be an email address or phone number.
  """
  address: String!

  """
  Key for the entity associated with the address. This is generally the Twitch ID of the user.
  """
  key: String!
}

"""
RegenerateVerificationCodePayload is the VerificationRequest document returned from EVS on success.
"""
type RegenerateVerificationCodePayload {
  """The updated verification request."""
  request: VerificationRequest
}

"""
RegisterPayoutInformationError describes the error that occured when registering
a user's payout information during payout onboarding.
"""
type RegisterPayoutInformationError {
  """
  Code to describe error that occurred while registering payout information.
  """
  code: RegisterPayoutInformationErrorCode!

  """Lists any field names that have an invalid format."""
  invalidFields: [RegisterPayoutInformationFieldName!]
}

"""Enumerates possible errors when registering payout information."""
enum RegisterPayoutInformationErrorCode {
  """Must have auth credentials to register payout information."""
  UNAUTHENTICATED

  """
  User does not have permission to register payout information for the targeted user.
  """
  FORBIDDEN

  """One or more fields have an invalid format."""
  INVALID_FORMAT

  """An internal error has occurred."""
  INTERNAL_ERROR
}

"""Enumerates vaid field names when registering payout information."""
enum RegisterPayoutInformationFieldName {
  """Assigned if Birthdate is given in invalid format."""
  BIRTHDATE

  """Assigned if City is given in invalid format."""
  CITY

  """Assigned if Company Name is given in invalid format."""
  COMPANY_NAME

  """Assigned if Country Code is given in invalid format."""
  COUNTRY_CODE

  """Assigned if Email is given in invalid format."""
  EMAIL

  """Assigned if First Name is given in invalid format."""
  FIRST_NAME

  """Assigned if Last Name is given in invalid format."""
  LAST_NAME

  """Assigned if Middle Name is given in invalid format."""
  MIDDLE_NAME

  """Assigned if Postal is given in invalid format."""
  POSTAL

  """Assigned if State Code is given in invalid format."""
  STATE_CODE

  """Assigned if Primary Address is given in invalid format."""
  STREET_ADDRESS

  """Assigned if Secondary Address is given in invalid format."""
  STREET_ADDRESS_2

  """Assigned if Parent Name is given in invalid format."""
  PARENT_NAME

  """Assigned if Parent Email is given in invalid format."""
  PARENT_EMAIL
}

"""
RegisterPayoutInformationInput is the input required to register a user's payout information during payout onboarding.
"""
input RegisterPayoutInformationInput {
  """
  Birthdate submitted by the user while registering into a payout program.
  """
  birthdate: Time!

  """City submitted by the user while registering into a payout program."""
  city: String!

  """
  Company Name submitted by the user while registering into a payout program.
  """
  companyName: String

  """
  Country Code (ISO-3166) submitted by the user while registering into a payout program.
  """
  countryCode: String!

  """Email submitted by the user while registering into a payout program."""
  email: String!

  """
  First Name submitted by the user while registering into a payout program.
  """
  firstName: String!

  """
  Last Name submitted by the user while registering into a payout program.
  """
  lastName: String!

  """
  Middle Name submitted by the user while registering into a payout program.
  """
  middleName: String

  """
  Parent Email submitted by the under age user while registering into a payout program.
  """
  parentEmail: String

  """
  Parent Name submitted by the under age user while registering into a payout program.
  """
  parentName: String

  """Postal submitted by the user while registering into a payout program."""
  postal: String

  """
  State Code submitted by the user while registering into a payout program.
  """
  stateCode: String

  """
  Primary Address submitted by the user while registering into a payout program.
  """
  streetAddress: String!

  """
  Secondary Address submitted by the user while registering into a payout program.
  """
  streetAddress2: String

  """
  TargetUserID is the ID of the user whose payout information will be registered.
  """
  targetUserID: ID!
}

"""
RegisterPayoutInformationPayload is the updated workflow after registration is accepted.
"""
type RegisterPayoutInformationPayload {
  """Describes error that occured when registering payout information."""
  error: RegisterPayoutInformationError

  """New workflow state."""
  workflow: PayoutOnboardingWorkflow
}

"""Error returned during a invalid user request."""
type RegisterTwoFactorConfirmationError {
  """Error code returned by the backend."""
  code: RegisterTwoFactorConfirmationErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to confirm registeration for two factor authentication.
"""
enum RegisterTwoFactorConfirmationErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """
  The user cannot confirm two factor registration since the initial registration was never started or has expired.
  """
  REGISTRATION_NOT_STARTED

  """The one time password provided is invalid."""
  INVALID_OTP

  """The one time password provided is missing."""
  MISSING_OTP

  """The phone number provided is used for too many Twitch accounts."""
  LIMIT_REACHED

  """The user does not have a verified email."""
  EMAIL_NOT_VERIFIED

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a registerTwoFactorConfirmation mutation."""
input RegisterTwoFactorConfirmationInput {
  """The one time password required to complete two factor registration."""
  oneTimePassword: String!

  """
  The ID of the user that is requesting to complete registration of two factor authentication.
  """
  userID: ID!
}

"""The result of a registerTwoFactorConfirmationPayload mutation."""
type RegisterTwoFactorConfirmationPayload {
  """New access token returned for clients to use after turning on 2FA."""
  accessToken: String

  """error code and localized error."""
  error: RegisterTwoFactorConfirmationError
}

"""Error returned during a invalid user request."""
type RegisterTwoFactorError {
  """Error code returned by the backend."""
  code: RegisterTwoFactorErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to register for two factor authentication.
"""
enum RegisterTwoFactorErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """Phone number was not provided."""
  MISSING_PHONE_NUMBER

  """Phone number was not valid."""
  INVALID_PHONE_NUMBER

  """
  The user has requested to register for two factor authentication too many times.
  """
  REQUEST_THROTTLED

  """The user does not have a verified email."""
  EMAIL_NOT_VERIFIED

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a registerTwoFactor mutation."""
input RegisterTwoFactorInput {
  """The phone number used for two factor registration."""
  phoneNumber: String!

  """
  The ID of the user that is requesting to register for two factor authentication.
  """
  userID: ID!
}

"""The result of a registerTwoFactorPayload mutation."""
type RegisterTwoFactorPayload {
  """error code and localized error."""
  error: RegisterTwoFactorError
}

"""
The registration type signifies the policy for participants to join the competition.
"""
enum RegistrationType {
  """Competition that any Twitch user can join."""
  OPEN

  """Competition that only invited participants can join."""
  INVITATIONAL

  """Open competition where only followers of the channel can join."""
  FOLLOWERS

  """Open competition where only subscribers of the channel can join."""
  SUBSCRIBERS

  """
  Open competition where only followers and subscribers of the channel can join.
  """
  FOLLOWER_AND_SUBSCRIBERS

  """Unknown type."""
  UNKNOWN
}

type RejectedChatMessage {
  """Original message's raw body."""
  body: String

  """
  Optional list of fragments from the messages's body that lead to the message rejection.
  """
  failedFragments: [String]

  """The ID of the message."""
  id: ID

  """Specifies if a action by a moderator has been taken on the message."""
  isResolved: Boolean @deprecated(reason: "Use status field instead")

  """The extracted caught message."""
  message: Message

  """The user that created the message."""
  sender: User

  """Status of the message."""
  status: CaughtMessageStatus!

  """The channel where the message was originally sent."""
  target: User
}

input RejectFriendRequestInput {
  """
  The authenticated user will reject the friend request sent by the user with an ID equal to targetID.
  """
  targetID: ID!
}

type RejectFriendRequestPayload {
  """The user whose friend request was just rejected."""
  user: User
}

"""Errors from rejectSquadStreamInvitation mutation."""
type RejectSquadStreamInvitationError {
  """Error from request to reject invitation."""
  code: RejectSquadStreamInvitationErrorCode!
}

"""Possible errors from this mutation."""
enum RejectSquadStreamInvitationErrorCode {
  """Invitation to be rejected does not exist."""
  INVITATION_NOT_FOUND

  """Squad associated with the invitation does not exist."""
  SQUAD_NOT_FOUND

  """User does not have permissions to reject invitation."""
  UNAUTHORIZED

  """Invitation not in pending state cannot be rejected."""
  INVITATION_CANNOT_BE_REJECTED
}

"""Inputs to the rejectSquadStreamInvitation mutation."""
input RejectSquadStreamInvitationInput {
  """ID of the invitation to be rejected."""
  invitationID: ID!
}

"""Outputs from the rejectSquadStreamInvitation mutation."""
type RejectSquadStreamInvitationPayload {
  """Error from mutation if exists."""
  error: RejectSquadStreamInvitationError

  """The rejected invitation."""
  invitation: SquadStreamInvitation
}

"""
RejectSquadStreamOutOfNetworkInvitationsError is the error associated with a rejectSquadStreamOutOfNetworkInvitations.
"""
type RejectSquadStreamOutOfNetworkInvitationsError {
  """The associated error code."""
  code: RejectSquadStreamOutOfNetworkInvitationsErrorCode!
}

"""
RejectSquadStreamOutOfNetworkInvitationsErrorCode are the possible errors that this mutation returns.
"""
enum RejectSquadStreamOutOfNetworkInvitationsErrorCode {
  """
  The user is not authorized to reject invitations on behalf of the recipient.
  """
  UNAUTHORIZED
}

"""Inputs to the rejectSquadStreamOutOfNetworkInvitations mutation."""
input RejectSquadStreamOutOfNetworkInvitationsInput {
  """ID of the user whose out of network invitations will be rejected."""
  recipientID: ID!
}

"""Outputs from the rejectSquadStreamOutOfNetworkInvitations mutation."""
type RejectSquadStreamOutOfNetworkInvitationsPayload {
  """The possible error returned from the service."""
  error: RejectSquadStreamOutOfNetworkInvitationsError
}

"""
RemoveAutohostChannelsInput remove channelIDs from a user's list to autohost.
"""
input RemoveAutohostChannelsInput {
  """ChannelIDs that will be removed from the list to autohost."""
  channelIDs: [ID!]!

  """UserID to update autohost list for."""
  userID: ID!
}

"""
RemoveAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
"""
type RemoveAutohostChannelsPayload {
  """User whose autohostChannels field had been updated."""
  user: User
}

"""
RemoveCollectionItemInput accepts a collectionID and item ID and parameters to remove the item from a collection.
"""
input RemoveCollectionItemInput {
  """The id of the collection."""
  collectionID: ID!

  """The id of the item of which will be added to the collection."""
  itemID: ID!

  """The type of item ie. video."""
  itemType: String!
}

"""The response from removing an item from a collection."""
type RemoveCollectionItemPayload {
  """The newly updated collection."""
  collection: Collection
}

"""
RemoveCompetitionPhaseInput contains the inputs required to remove a phase.
"""
input RemoveCompetitionPhaseInput {
  """The competition id of the competition."""
  competitionID: ID!

  """The id of the competition phase."""
  phaseID: ID!
}

"""
RemoveCompetitionPhasePayload is the success response for removing a phase.
"""
type RemoveCompetitionPhasePayload {
  """The new state of competition after removing a phase."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""
Remove a player from a Competition. If you remove a player that is part of a
team, the player will removed from the team as well. If that player is a captain
of the team, the team will no longer have a captain.
"""
input RemoveCompetitionPlayerInput {
  """Unique Competition ID."""
  competitionID: ID!

  """Twitch user id of the player."""
  userID: ID!
}

"""Indication that the player was removed."""
type RemoveCompetitionPlayerPayload {
  """
  The new state of competition after removing a competition player from the competition.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Inputs for removing a competition team from a competition."""
input RemoveCompetitionTeamInput {
  """ID of the competition."""
  competitionID: ID!

  """ID of the team."""
  teamID: ID!
}

"""
RemoveCompetitionTeamPayload is the success response removing a competition team from the competition.
"""
type RemoveCompetitionTeamPayload {
  """
  The new state of competition after removing a competition team from the competition.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""RemoveEditorError contains details about a client error that occurred."""
type RemoveEditorError {
  """The type of error that occurred when revoking a user's editor status."""
  code: RemoveEditorErrorCode!
}

"""
RemoveEditorErrorCode defines a client error that occurred while removing an editor.
"""
enum RemoveEditorErrorCode {
  """The channel does not exist."""
  CHANNEL_NOT_FOUND

  """The target user does not exist."""
  TARGET_USER_NOT_FOUND
}

"""
RemoveEditorInput contains the parameters to revoke the editor status from a user for a channel.
"""
input RemoveEditorInput {
  """The channel from which the editor status of the user will be revoked."""
  channelID: ID!

  """
  The ID of the user whose editor status will be revoked.
  Either targetUserID or targetUserLogin must be provided.
  """
  targetUserID: ID

  """
  The login of the user whose editor status will be revoked.
  Either targetUserID or targetUserLogin must be provided.
  """
  targetUserLogin: String
}

"""
RemoveEditorPayload is the response after attempting to revoke the editor status of a user.
"""
type RemoveEditorPayload {
  """The channel for which the editor status of the target user is removed."""
  channel: User

  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: RemoveEditorError

  """The user whose editor status was revoked."""
  targetUser: User
}

"""Error returned after attempting to remove an emote from its group."""
type RemoveEmoteFromGroupError {
  """The error code associated with this error."""
  code: RemoveEmoteFromGroupErrorCode!
}

"""Possible error codes for RemoveEmoteFromGroupError."""
enum RemoveEmoteFromGroupErrorCode {
  """The specified emote does not exist."""
  EMOTE_NOT_FOUND

  """The user is not allowed to remove this emote from its group."""
  PERMISSION_DENIED

  """Unknown error."""
  UNKNOWN
}

"""The input for remove emote from group."""
input RemoveEmoteFromGroupInput {
  """ID of the emote to be removed from its group."""
  emoteID: ID!
}

"""Result of remove emote from group."""
type RemoveEmoteFromGroupPayload {
  """The updated emote if successful."""
  emote: Emote

  """Error returned after attempting to remove an emote from its group."""
  error: RemoveEmoteFromGroupError
}

"""
RemoveOrganizationMemberError is the error associated with a RemoveOrganizationMember.
"""
type RemoveOrganizationMemberError {
  """The associated error code."""
  code: RemoveOrganizationMemberErrorCode!
}

"""
RemoveOrganizationMemberErrorCode defines a client error that occurred while removing an organization member.
"""
enum RemoveOrganizationMemberErrorCode {
  """User does not have permission to remove another member."""
  PERMISSION_DENIED

  """The user to be removed does not exist."""
  USER_NOT_FOUND

  """
  Can not remove this user because it is assigned as an extension billing manager. Need to unassign first.
  """
  ASSIGNED_BILLING_MANAGER

  """Deprecated: code not used, a resolver error is returned instead."""
  INTERNAL_ERROR
}

"""Inputs to the removeOrganizationMember mutation."""
input RemoveOrganizationMemberInput {
  """The ID of the organization."""
  organizationID: ID!

  """The twitch ID of the organization member."""
  userID: ID!
}

"""Outputs from the removeOrganizationMember mutation."""
type RemoveOrganizationMemberPayload {
  """The possible error returned from the service."""
  error: RemoveOrganizationMemberError

  """The user who is removed from organization."""
  targetUser: User
}

input RemoveReactionInput {
  emoteID: ID!
  entityID: ID!
}

type RemoveReactionPayload {
  content: ReactableContent!
}

"""
RemoveSquadStreamMemberError is the error associated with a removeSquadStreamMember.
"""
type RemoveSquadStreamMemberError {
  """The associated error code."""
  code: RemoveSquadStreamMemberErrorCode!
}

"""
RemoveSquadStreamMemberErrorCode are the possible errors that this mutation returns.
"""
enum RemoveSquadStreamMemberErrorCode {
  """The user is not authorized to remove members from the squad."""
  UNAUTHORIZED

  """The user to be removed is not in the squad specified."""
  USER_NOT_IN_SQUAD
}

"""Inputs to the removeSquadStreamMember mutation."""
input RemoveSquadStreamMemberInput {
  """
  The user ID of the member that should be removed from the squad stream.
  """
  memberUserID: ID!

  """The ID of the squad stream."""
  squadStreamID: ID!
}

"""Outputs from the removeSquadStreamMember mutation."""
type RemoveSquadStreamMemberPayload {
  """The possible error returned from the service."""
  error: RemoveSquadStreamMemberError

  """The updated squad stream."""
  squadStream: SquadStream
}

"""
Inputs for removing a stucco (from the library).
- Active stuccos cannot be removed, they have to be inactive first (not part of a stucco pack).
"""
input RemoveStuccoInput {
  """ID of the channel the stucco is removed from."""
  channelID: ID!

  """Unique ID of the stucco to be removed."""
  stuccoID: ID!
}

"""
The output payload for removing a stucco, returns the library of stuccos after removal.
"""
type RemoveStuccoPayload {
  """The list of stuccos available in the channel's library after removal."""
  stuccos: [Stucco!]
}

"""RenewalPolicy defines whether the charge model will renew or not."""
enum RenewalPolicy {
  """Will not renew automatically."""
  NO_RENEW

  """Will renew automatically."""
  AUTO_RENEW

  """Unknown renewal policy."""
  UNKNOWN
}

"""
ReorderCollectionItemInput accepts a collectionID and item ID and parameters to update the item order of a collection.
"""
input ReorderCollectionItemInput {
  """The id of the collection."""
  collectionID: ID!

  """The id of the item of which will be moved in the collection."""
  itemID: ID!

  """The type of item ie. video."""
  itemType: String!

  """The new position of the item."""
  position: Int!
}

"""The response from reordering an item in a collection."""
type ReorderCollectionItemPayload {
  """The newly updated collection."""
  collection: Collection
}

input ReportContentInput {
  """Content type being reported."""
  content: ReportContentType!

  """ID of the content being reported."""
  contentID: ID!

  """The description of the report."""
  description: String!

  """Extra (content specific) data for the report."""
  extra: String!

  """Extra arguments required for NetzDG reporting."""
  netzDGArgs: ReportContentNetzDGInput

  """The reason ID for the report."""
  reason: ID!

  """ID of the user being reported."""
  targetID: ID!

  """The path taken through the report wizard."""
  wizardPath: [String!]
}

"""Valid values for ReportContentNetzDGInput.contentDirectedTo."""
enum ReportContentNetzDGContentDirectedTo {
  """The reported content is directed at the reporter."""
  ME

  """The reported content is directed at someone the reporter represents."""
  SOMEONE_I_REPRESENT

  """The reported content is directed at someone else."""
  SOMEONE_ELSE
}

"""Extra fields that are required for NetzDG reporting."""
input ReportContentNetzDGInput {
  """Who the reporter thinks the offending content is directed to."""
  contentDirectedTo: ReportContentNetzDGContentDirectedTo!

  """The email address of the reporter."""
  reporterEmail: String!

  """Who the reporter is reporting on behalf of."""
  reportingFor: ReportContentNetzDGReportingFor!
}

"""Valid values for ReportContentNetzDGInput.ReportingFor."""
enum ReportContentNetzDGReportingFor {
  """The reporter is reporting for themselves."""
  MYSELF

  """The reporter is reporting on behalf of a complaints office."""
  COMPLAINTS_OFFICE

  """
  The report is reporting on behalf of an agency of the german government.
  """
  GOVERNMENT_AGENCY
}

type ReportContentPayload {
  """Content type that was reported."""
  content: ReportContentType!

  """ID of the content that was reported."""
  contentID: ID!
}

"""Types of content that can be reported."""
enum ReportContentType {
  """Report against a channel feed comment."""
  CHANNEL_FEED_COMMENT_REPORT

  """Report against a channel feed post."""
  CHANNEL_FEED_POST_REPORT

  """Report against a chat message."""
  CHAT_REPORT

  """Report against a channel's channel points."""
  CHANNEL_POINTS_REPORT

  """Report against a clip."""
  CLIP_REPORT

  """(Deprecated) Report against a vod collection."""
  COLLECTION_REPORT

  """(Deprecated) Report against a curse private group."""
  CURSE_PRIVATE_GROUP

  """(Deprecated) Report against a curse public group."""
  CURSE_PUBLIC_GROUP

  """(Deprecated) Report against a curse whisper."""
  CURSE_WHISPER

  """Report against an emote."""
  EMOTE_REPORT

  """Report against an oracle event."""
  EVENT_REPORT

  """Report against an extension."""
  EXTENSION_REPORT

  """Report against a live up notification."""
  LIVE_UP_REPORT

  """Report against a livestream."""
  LIVESTREAM_REPORT

  """Report against a poll."""
  POLL_REPORT

  """Report against a raid."""
  RAID_REPORT

  """Report against a reward redemption."""
  REWARD_REDEMPTION_REPORT

  """Report against a chatroom."""
  ROOM_REPORT

  """Report against sings group name."""
  SINGS_GROUP_NAME_REPORT

  """Report against sings group biography."""
  SINGS_GROUP_BIO_REPORT

  """Report against sings group chat."""
  SINGS_GROUP_CHAT_REPORT

  """Report against a sings group vod comment."""
  SINGS_VOD_COMMENT_REPORT

  """Report against sings duet seed."""
  SINGS_DUET_SEED_REPORT

  """Report against an unban request."""
  UNBAN_REQUEST_REPORT

  """Report against a live user."""
  USER_REPORT

  """Report against a twitch vod comment."""
  VOD_COMMENT_REPORT

  """Report against a twitch vod."""
  VOD_REPORT

  """
  Report against a whisper. Deprecated in favor of the whisperReport mutation.
  """
  WHISPER_REPORT @deprecated(reason: "use whisperReport mutation instead.")
}

"""A valid reason for a report."""
type ReportReason {
  """The unique ID of the reason."""
  id: ID!

  """
  Whether or not this report reason is in-scope for a country-specific law.
  """
  isApplicableToCountryRegulations: Boolean!

  """The displayed text for this reason localized based on Accept-Language."""
  text: String!
}

"""A valid country and ToS reasons for a report."""
type ReportToSAndCountryReasons {
  """
  The countryCode of the country-specific reporting flow that applies to the user.
  If null then there is no relevant country-specific reporting flow for the user.
  """
  countryCode: String

  """
  Localized string that should be displayed to the user as a disclosure that their report.
  Falls under given legislation, and may be viewed by legal authorities.
  """
  disclosureText: String

  """The list of report reasons that apply for the content type."""
  toSAndCountryReasons: [ReportReason!]!
}

"""Possible error reasons returned by reportWhisper mutation."""
enum ReportWhisperErrorReason {
  """Invalid user ID."""
  INVALID_USER_ID

  """There are no whispers from the target user to the reporter."""
  NO_WHISPERS_FROM_TARGET_USER

  """The reporter is currently rate limited."""
  RATE_LIMITED

  """Unauthorized."""
  UNAUTHORIZED

  """Unknown error."""
  UNKNOWN
}

"""Input to the reportWhisper mutation."""
input ReportWhisperInput {
  """The description of the report."""
  description: String!

  """The reason option for the report."""
  reason: String!

  """ID of the user being reported."""
  targetID: ID!

  """The path taken through the report wizard."""
  wizardPath: [String!]
}

"""Payload returned from the reportWhisper mutation."""
type ReportWhisperPayload {
  """Reports aren't queryable in GQL, so only an error is returned."""
  error: ReportWhisperPayloadError
}

"""
Error type that may be returned returned from the reportWhisper mutation.
"""
type ReportWhisperPayloadError {
  """Reason that the report wasn't created."""
  reason: ReportWhisperErrorReason!
}

input ReportWhisperThreadInput {
  """Reason why the user is reporting the thread."""
  reason: String

  """ID of user being reported."""
  targetUserID: ID!

  """ID of thread to report."""
  threadID: ID!
}

type ReportWhisperThreadPayload {
  thread: WhisperThread!
}

"""Metadata about a GraphQL request."""
type RequestInfo {
  """
  The country code where the request originated. Defaults to "US" if geoip lookup fails.
  """
  countryCode: String!

  """
  Whether the request came from a country belonging to the European Union.
  """
  fromEU: Boolean!

  """The IP address where the request originated."""
  ipAddress: String

  """
  Whether the request came from a country belonging to the European Economic Area.
  """
  isFromEEA: Boolean!
}

type RequestRitualTokenError {
  code: RequestRitualTokenErrorCode!
}

enum RequestRitualTokenErrorCode {
  """Token is not in a status that can be requested."""
  TOKEN_NOT_AVAILABLE

  """Token does not exist."""
  TOKEN_NOT_FOUND
}

"""RequestRitualTokenInput is the input when requesting a ritual token."""
input RequestRitualTokenInput {
  """The channel to request a ritual token in."""
  channelID: ID!

  """The type of ritual token to request."""
  type: RitualTokenType!
}

"""
RequestRitualTokenPayload is the response when requesting a ritual token.
"""
type RequestRitualTokenPayload {
  error: RequestRitualTokenError
  token: RitualToken
}

"""
ResendVerificationEmailInput is input required to resend the verification email.
"""
input ResendVerificationEmailInput {
  """ID of the user to resend a verification email to."""
  userID: ID!
}

"""
ResendVerificationEmailPayload is the output after resending a verification email.
"""
type ResendVerificationEmailPayload {
  """The modified user."""
  user: User
}

"""Error returned during an invalid username reset request."""
type ResetUsernameCodeError {
  """Error code returned by the backend."""
  code: ResetUsernameErrorCode!
}

"""Possible error codes returned from a username reset."""
enum ResetUsernameErrorCode {
  """Authorization token is not valid."""
  TOKEN_INVALID

  """Too many attempts to update login."""
  REQUESTS_THROTTLED

  """Login is not available."""
  LOGIN_UNAVAILABLE

  """Login is too short."""
  LOGIN_TOO_SHORT

  """Login is too long."""
  LOGIN_TOO_LONG

  """Login contains characters that are not allowed."""
  LOGIN_CONTAINS_INVALID_CHARACTERS

  """Unrecognized error returned from the backend service."""
  UNKNOWN_ERROR
}

"""Input for a username reset."""
input ResetUsernameInput {
  """The new login for the user."""
  login: String!

  """The authorization token for the username reset."""
  resetUsernameToken: String!
}

"""The result of a username reset."""
type ResetUsernamePayload {
  """Error code for error from returned the username reset."""
  error: ResetUsernameCodeError

  """The modified username for the user."""
  login: String
}

"""An error returned from the resolvePredictionEvent mutation."""
type ResolvePredictionEventError {
  """Code describing the error."""
  code: ResolvePredictionEventErrorCode!
}

"""Possible error codes from the resolvePredictionEvent mutation."""
enum ResolvePredictionEventErrorCode {
  """The current user is forbidden from resolving this Prediction Event."""
  FORBIDDEN

  """
  This Prediction Event has already either been resolved or canceled, and as such this action cannot be taken.
  """
  EVENT_ENDED

  """An unknown error occurred."""
  UNKNOWN
}

"""
Input for resolving a Prediction Event (and paying out all of the users who predicted correctly).
"""
input ResolvePredictionEventInput {
  """The unique identifier of the Prediction Event to resolve."""
  eventID: ID!

  """
  The unique identifier of the Prediction Outcome to select as the winner.
  """
  outcomeID: ID!
}

"""Payload for resolving a prediciton event."""
type ResolvePredictionEventPayload {
  """If present, there was an error with the request."""
  error: ResolvePredictionEventError

  """The resolved Prediction Event."""
  predictionEvent: PredictionEvent
}

"""A restriction for a specific resource."""
type ResourceRestriction {
  """The list of exemptions for a given resource restriction."""
  exemptions: [ResourceRestrictionExemption!]

  """The restriction's unique identifier."""
  id: ID!

  """
  The list of options that were applied at time of creation for a given resource restriction.
  """
  options: [ResourceRestrictionOption!]!

  """The type of restriction on this resource."""
  type: ResourceRestrictionType!
}

"""Exemption information for a specific resource restriction."""
type ResourceRestrictionExemption {
  """
  The list of description data a user make take to become exempt for the given restriction.
  """
  actions: [ResourceRestrictionExemptionAction!]

  """The time that the restriction is no longer active."""
  endsAt: Time

  """The keys needed for a given restriction."""
  keys: [String!]

  """The time that the restriction becomes active."""
  startsAt: Time

  """The type of exemption."""
  type: ResourceRestrictionExemptionType!
}

"""Description data for clients to get for user actions to get exempt."""
type ResourceRestrictionExemptionAction {
  """Name of the action need. e.g. Ticket Product short name."""
  name: String!

  """The human readable title of the restriction."""
  title: String!
}

"""An enumeration of the different exemption types."""
enum ResourceRestrictionExemptionType {
  """The restriction is exempt for an unknown reason."""
  UNKNOWN

  """The restriction is exempt for all users."""
  ALL

  """The restriction is exempt for staff accounts."""
  STAFF

  """The restriction is exempt for site admins."""
  SITE_ADMIN

  """The restriction is exempt for owning a product."""
  PRODUCT

  """
  The restriction is exempt for viewers that are in the same org as the channel owner.
  """
  ORGANIZATION_MEMBER

  """The restriction is exempt for the preview duration."""
  PREVIEW

  """The restriction is exempt for channel moderators."""
  CHANNEL_MODERATOR

  """The restriction is exempt for channel VIPs."""
  CHANNEL_VIP
}

"""An enumeration of the different restriction options."""
enum ResourceRestrictionOption {
  """Allows users holding the channel VIP role to access the resource."""
  ALLOW_CHANNEL_VIP

  """
  Allows users holding the channel moderator role to access the resource.
  """
  ALLOW_CHANNEL_MODERATOR

  """Allows only users with tier 3 subscriptions to access the resource."""
  ALLOW_TIER_3_ONLY

  """
  Allows only users with tier 2 and 3 subscriptions to access the resource.
  """
  ALLOW_TIER_2_AND_3_ONLY

  """Allows users with any tier subscriptions to access the resource."""
  ALLOW_ALL_TIERS
}

"""An enumeration of the different restriction types."""
enum ResourceRestrictionType {
  """The resource is restricted for an unknown reason."""
  UNKNOWN

  """The resource is restricted by a subscription."""
  SUB_ONLY_LIVE

  """The resource is restricted by the All-Access Pass."""
  ALL_ACCESS_PASS

  """
  The resource is restricted by the organization membership logic in RBAC.
  """
  ORGANIZATION_ACCESS_ONLY
}

"""Inputs to the respondToTeamInvitation mutation."""
input RespondToTeamInvitationInput {
  """Whether the user accepts or declines the team invite."""
  accepted: Boolean!

  """The team whose invite the user will be responding to."""
  teamID: ID!

  """
  The authenticated user who will respond to the team invitation with an ID equal to userID.
  """
  userID: ID!
}

"""Outputs from the respondToTeamInvitation mutation."""
type RespondToTeamInvitationPayload {
  """The user who just accepted a team invitation."""
  user: User
}

"""An enumeration of the different restriction types."""
enum RestrictionResource {
  """For non-live video content, e.g. VODs."""
  VIDEO

  """For live video content."""
  LIVE
}

"""A recent resub token to use for sending a special message."""
type ResubNotification {
  """The number of months of total subbing."""
  cumulativeTenureMonths: Int!

  """A unique ID for the resub notification."""
  id: ID!

  """The number of months of consecutive subbing."""
  months: Int!

  """The number of months of consecutive subbing."""
  streakTenureMonths: Int!

  """The token to use when submitting a sub/resub message."""
  token: String!

  """If the resub notification is caused by a gift or not"""
  isGiftSubscription: Boolean!

  """Gifter who gave the gift, null if no gifter or anon"""
  gifter: User
}

"""The possible erors when resuming a schedule."""
enum ResumeScheduleError {
  """Not authorized to resume this schedule."""
  PERMISSION_DENIED

  """The schedule was not found."""
  NOT_FOUND
}

"""The input to resume a schedule."""
input ResumeScheduleInput {
  """The id of the schedule."""
  scheduleID: ID!
}

"""The returned payload when resuming a schedule."""
type ResumeSchedulePayload {
  """The possible error."""
  error: ResumeScheduleError

  """The updated schedule input."""
  schedule: Schedule
}

"""Revenue configuration data related to a subscription product."""
type RevenueConfig {
  """Unique identifier for the revenue configuration."""
  id: ID!

  """0-100 percent value of revenue the broadcaster will earn."""
  splitPercent: Int!

  """Start time of when the revenue split configuration takes effect."""
  startAt: Time
}

"""RevokeVIPError contains details about a client error that occurred."""
type RevokeVIPError {
  """The type of error that occurred when revoking a user's VIP status."""
  code: RevokeVIPErrorCode!
}

"""
RevokeVIPErrorCode defines a client error that occurred while revoking a VIP status.
"""
enum RevokeVIPErrorCode {
  """The channel does not exist."""
  CHANNEL_NOT_FOUND

  """
  The revoker does not have permission to revoke the VIP status in this channel.
  """
  FORBIDDEN

  """The user whose VIP status is to be revoked does not exist."""
  REVOKEE_NOT_FOUND

  """
  The user whose VIP statu is to be revoked does not actually have the VIP status to be revoked.
  """
  REVOKEE_NOT_VIP
}

"""
RevokeVIPInput contains the parameters to revoke the VIP status of a user from a channel.
"""
input RevokeVIPInput {
  """The channel from which the VIP status of the user will be revoked."""
  channelID: ID!

  """
  The ID of the user whose VIP status will be revoked.
  Either revokeeID or revokeeLogin must be provided.
  """
  revokeeID: ID

  """
  The login of the user whose VIP status will be revoked.
  Either revokeeID or revokeeLogin must be provided.
  """
  revokeeLogin: String
}

"""
RevokeVIPPayload is the response after attempting to revoke the VIP status of a user.
"""
type RevokeVIPPayload {
  """The channel that the user is revoked as a VIP to."""
  channel: User

  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: RevokeVIPError

  """The user whose VIP status is revoked."""
  revokee: User
}

"""Rewarded Video information."""
type RewardedVideo {
  """A flag indicating if the user is eligible for rewarded videos."""
  isEligible: Boolean!

  """
  A flag indicating if the user needs to do a captcha in order to use rewarded videos.
  """
  shouldCaptcha: Boolean!
}

type RichOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  html: String!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
  width: Int!
}

"""
A ritual is an opportunity for a viewer to better connect with a streamer's
community by announcing when they reach milestones in the channel.
A ritual token is issued when a user is eligible for the ritual, and can be
redeemed to send the announcement in a channel.
"""
type RitualToken {
  """The channel that the user can redeem the ritual token in."""
  channel: User

  """
  The time after which the ritual is considered expired and can no longer be
  redeemed. Clients should dismiss the ritual UI if it's still shown after
  this time. Null if the ritual never expires.
  """
  expiresAt: Time

  """A unique ID for the ritual token."""
  id: ID!

  """The status of the ritual token."""
  status: RitualTokenStatus

  """The type of the ritual to be redeemed."""
  type: RitualTokenType

  """The user that owns the ritual token."""
  user: User
}

enum RitualTokenStatus {
  """ELIGIBLE means a user does not have this token, but can request one."""
  ELIGIBLE

  """
  AVAILABLE means a user has been granted this token and it can be redeemed.
  """
  AVAILABLE

  """DISMISSED means a user has opted out of redeeming this token."""
  DISMISSED

  """REDEEMED means a user has successfully consumed this token."""
  REDEEMED
}

enum RitualTokenType {
  """
  NEW_CHATTER is granted 5 minutes after a user joins a channel for the first time.
  """
  NEW_CHATTER
}

"""
DEPRECATED.
A chatroom associated with a channel where members of the room can exchange messages.
"""
type Room {
  """UUID of the room."""
  id: ID! @deprecated(reason: "The Rooms product has been sunset")

  """Whether the room can be read by non-members and logged out users."""
  isPreviewable: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """Paginated list of members of the chatroom."""
  members(first: Int = 100, after: Cursor): RoomMemberConnection @deprecated(reason: "The Rooms product has been sunset")

  """
  List of messages to the room, in reverse chronological order. If fromTime is used, that time is used
  as the cursor instead of after/before.
  """
  messages(first: Int, after: Cursor, last: Int, before: Cursor, fromTime: Time): RoomMessageConnection @deprecated(reason: "The Rooms product has been sunset")

  """
  Minimum role required to join the room. For example, in a sub room, subs can join,
  but also the broadcaster, mods, and staff.
  """
  minimumAllowedRole: RoomRole! @deprecated(reason: "The Rooms product has been sunset")

  """Room modes (e.g. slow mode)."""
  modes: RoomModes @deprecated(reason: "The Rooms product has been sunset")

  """The name of the room (e.g. subs-only)."""
  name: String! @deprecated(reason: "The Rooms product has been sunset")

  """The user the room belongs to."""
  owner: User! @deprecated(reason: "The Rooms product has been sunset")

  """
  rolePermissions describes the role necessary to perform actions in the room.
  """
  rolePermissions: RoomRolePermissions @deprecated(reason: "The Rooms product has been sunset")

  """Returns the current user's settings for the room."""
  self: RoomView @deprecated(reason: "The Rooms product has been sunset")

  """The room topic (e.g. "serious discussion only")."""
  topic: String @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
Paginated list of room members (users).
"""
type RoomMemberConnection {
  """The elements of the list."""
  edges: [RoomMemberEdge]! @deprecated(reason: "The Rooms product has been sunset")

  """Information about this page."""
  pageInfo: PageInfo! @deprecated(reason: "The Rooms product has been sunset")
}

"""Element in a list of room members."""
type RoomMemberEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor! @deprecated(reason: "The Rooms product has been sunset")

  """The user who is a member of the room."""
  node: User @deprecated(reason: "The Rooms product has been sunset")

  """Type of user for grouping users in the rooms member list."""
  type: RoomMemberType! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
Type of user for grouping users in the rooms member list.
"""
enum RoomMemberType {
  """User that is the broadcaster."""
  BROADCASTER @deprecated(reason: "The Rooms product has been sunset")

  """User that is staff."""
  STAFF @deprecated(reason: "The Rooms product has been sunset")

  """User that is admin."""
  ADMIN @deprecated(reason: "The Rooms product has been sunset")

  """User that is global moderator."""
  GLOBALMOD @deprecated(reason: "The Rooms product has been sunset")

  """User that is a channel moderator."""
  MOD @deprecated(reason: "The Rooms product has been sunset")

  """User that has no special role."""
  REGULAR @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
A message sent from a user to a room.
"""
type RoomMessage {
  """The text and emoticon content of a message."""
  content: RoomMessageContent! @deprecated(reason: "The Rooms product has been sunset")

  """
  Time the message was deleted or purged. Null if the message is not deleted.
  """
  deletedAt: Time @deprecated(reason: "The Rooms product has been sunset")

  """UUID of the message."""
  id: ID! @deprecated(reason: "The Rooms product has been sunset")

  """The room the message was sent in."""
  room: Room! @deprecated(reason: "The Rooms product has been sunset")

  """The user that sent the message."""
  sender: User! @deprecated(reason: "The Rooms product has been sunset")

  """Time the message was sent."""
  sentAt: Time! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
Paginated list of messages in a room.
"""
type RoomMessageConnection {
  """The elements of the list."""
  edges: [RoomMessageEdge]! @deprecated(reason: "The Rooms product has been sunset")

  """Information about this page."""
  pageInfo: PageInfo! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
The content of a user's message to a room.
"""
type RoomMessageContent {
  """
  Parsed list of fragments in the message, include emotes, mentions, and plaintext.
  """
  fragments: [RoomMessageFragment]! @deprecated(reason: "The Rooms product has been sunset")

  """String representation of the user message."""
  text: String! @deprecated(reason: "The Rooms product has been sunset")
}

"""Element in a list of messages."""
type RoomMessageEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor! @deprecated(reason: "The Rooms product has been sunset")

  """The message."""
  node: RoomMessageItem @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
One parsed part of a message, which may be an emote, mention, or plaintext.
"""
type RoomMessageFragment {
  """
  Contains an emote or a mentioned user depending on the text of the fragment.
  """
  content: FragmentContent @deprecated(reason: "The Rooms product has been sunset")

  """Plaintext representation of the fragment."""
  text: String! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
RoomMessageGroupMention represents a group mention, such as @here.
"""
type RoomMessageGroupMention {
  """The type of mention."""
  type: RoomMessageMentionType! @deprecated(reason: "The Rooms product has been sunset")
}

union RoomMessageItem = RoomMessage

"""Represents a group mention, such as @here."""
enum RoomMessageMentionType {
  """An @here mention."""
  HERE @deprecated(reason: "The Rooms product has been sunset")
}

"""Modes that have been enabled for the room."""
type RoomModes {
  """If enabled, messages to the room must contain only emotes."""
  emotesOnlyModeEnabled: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """If enabled, messages to the room must be unique."""
  r9kModeEnabled: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """
  The number of seconds users must wait between messages. If 0, slow mode is disabled.
  """
  slowModeDurationSeconds: Int! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
Represents the permissions a user has in a room.
"""
type RoomPermissions {
  """Whether the user can moderate the room."""
  moderate: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """Whether the user can read messages in the room."""
  readMessages: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """Whether the user can send messages in the room."""
  sendMessages: Boolean! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
Describes the role a user must be in order to perform an action, such as sending messages. Roles are
hierarchical, so users that meet a role also meet all lower roles as well. For example, a moderator
meets the subscriber role, even if they are not subscribed to the channel. Roles are defined in order
from highest to lowest in the enum.
"""
enum RoomRole {
  """The channel owner."""
  BROADCASTER @deprecated(reason: "The Rooms product has been sunset")

  """A moderator for the channel."""
  MODERATOR @deprecated(reason: "The Rooms product has been sunset")

  """A subscriber of the channel."""
  SUBSCRIBER @deprecated(reason: "The Rooms product has been sunset")

  """All users."""
  EVERYONE @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
RoomRolePermissions describes the role necessary to perform actions in a room.
"""
type RoomRolePermissions {
  """Read describes the role necessary to read messages in the room."""
  read: RoomRole! @deprecated(reason: "The Rooms product has been sunset")

  """Send describes the role necessary to send messages in the room."""
  send: RoomRole! @deprecated(reason: "The Rooms product has been sunset")
}

"""
DEPRECATED
A RoomView represents the authenticated user's self connection to a room, and includes the user's
settings and permissions.
"""
type RoomView {
  """Whether the user has archived the room."""
  isArchived: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """Whether the user has muted the room."""
  isMuted: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """Whether the user has unread messages in the room."""
  isUnread: Boolean! @deprecated(reason: "The Rooms product has been sunset")

  """Last time the user read a message in the room."""
  lastReadAt: Time @deprecated(reason: "The Rooms product has been sunset")

  """The permissions the authenticated user has in the room."""
  permissions: RoomPermissions @deprecated(reason: "The Rooms product has been sunset")

  """The room the room view belongs to."""
  room: Room! @deprecated(reason: "The Rooms product has been sunset")

  """
  The number of mentions for the user in the room that the user has not read.
  """
  unreadMentionCount: Int! @deprecated(reason: "The Rooms product has been sunset")
}

"""An error describing why the issue happened, when relevant."""
enum RotateExtensionSecretsError {
  """User has indicated an invalid extension id."""
  INVALID_CLIENT

  """User is unable to delete the extension secrets."""
  UNAUTHORIZED

  """User indicated an Invalid delay; must be greater than zero."""
  INVALID_DELAY
}

"""
RotateExtensionSecretsInput includes the necessary parameters for creating a new extension secrets.
"""
input RotateExtensionSecretsInput {
  """
  Delay is the time delay in seconds between creation & activation of the secret.
  """
  delaySeconds: Int!

  """extensionID to generate a the secret for."""
  extensionID: ID!
}

"""
RotateExtensionSecretsPayload returns the new extension secrets information.
"""
type RotateExtensionSecretsPayload {
  """A user-friendly error, should one occur."""
  error: RotateExtensionSecretsError

  """All the existing secrets for the extension."""
  secrets: [ExtensionSecret!]
}

"""ROW cookie vendor for a user."""
type ROWCookieVendor {
  """User content status for each vendor."""
  consentStatus: ConsentStatus!

  """
  A flag that shows if the consent is given by the user or by consent service as default value.
  """
  hasUserSetConsent: Boolean!

  """A flag that shows if the vendor should be visible to management page."""
  isVisible: Boolean!

  """Vendor name."""
  name: VendorName!
}

"""List of ROW cookie vendor."""
type ROWVendorConsent {
  """status for vendors."""
  status: [ROWCookieVendor!]!
}

"""
RTMPSession is metadata related to the RTMP data sent by the broadcaster.
"""
type RTMPSession {
  """Audio codecs of RTMP session."""
  audioCodecs: String!

  """H.264 advanced video codec."""
  avcLevel: Int

  """
  Staff-only field. The IP address of the broadcaster of the RTMP session.
  """
  clientIP: String

  """Name of the broadcaster's encoder."""
  encoder: String!

  """H.264 encoder Instantaneous Decoder Refresh interval."""
  idrInterval: Int

  """rtmpExitReason tells how the stream session was terminated."""
  rtmpExitReason: String

  """RTMP request parameters sent by the broadcaster."""
  rtmpFlags: String!

  """A full list of RTMP header sent by the broadcaster."""
  rtmpMetadata: String!

  """Duration of each video frame segment in seconds."""
  segmentDurationSeconds: Int!

  """Video codecs of RTMP session."""
  videoCodecs: String!

  """Video resolution height in pixel."""
  videoResolutionHeight: Int!

  """Video resolution width in pixel."""
  videoResolutionWidth: Int!
}

"""Errors that can result from running multiplayer ads."""
enum RunMultiplayerAdErrorCode {
  """The channel is not live, so ads cannot be run on it."""
  CHANNEL_NOT_LIVE

  """At least one of the multiplayer ad offers has expired."""
  OFFER_EXPIRED

  """At least one of the multiplayer ad offers was not found."""
  OFFER_NOT_FOUND

  """An unknown error has occurred."""
  UNKNOWN
}

"""Inputs for running multiplayer ads."""
input RunMultiplayerAdsInput {
  """ID of the channel the ads will run on."""
  channelID: ID!

  """How long the multiplayer ad should run for."""
  desiredAdDurationSeconds: Int

  """The ID of the ad offers to run."""
  offerIDs: [ID!]!
}

"""The response after running multiplayer ads."""
type RunMultiplayerAdsPayload {
  """
  The error that has occurred.
  Null if the operation is successful.
  """
  error: RunMultiplayerAdErrorCode
}

"""
The view configuration of an extension if the component anchor is supported.
"""
input SaveComponentViewInput {
  """
  The developer configured height of the extension as a ratio relative to it's width.
  """
  aspectHeight: Int

  """
  Specifies the width of a component extension in relation to it's targetHeight and aspectRatioY.
  
  NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth.
         however, since both will be used for a short time during the rollout of the new UI,
         aspectWidth and aspectHeight will not be deprecated until later.
  """
  aspectRatioX: Int!

  """
  Specifies the height of a component extension in relation to it's targetHeight and aspectRatioX.
  
  NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
         however, since both will be used for a short time during the rollout of the new UI,
         aspectWidth and aspectHeight will not be deprecated until later.
  """
  aspectRatioY: Int!

  """
  The developer configured width of the extension as a ratio relative to it's height.
  """
  aspectWidth: Int

  """
  Specifies whether to automatically scale the extension iframe using css zoom as the video
  player dimensions change.
  """
  hasAutoscale: Boolean

  """
  Specifies whether CSS zooming should be applied to the CE container, creating a consistent
  size of 1024 pixels along the long edge of the component. Default: true.
  """
  hasZoom: Boolean

  """
  If Autoscale is true, this indicates the baseline width of the extension.
  This fields is optional, but is required if hasAutoscale is true.
  """
  scalePixels: Int

  """
  Size of the long edge of the Component Extension, relative to the length of the corresponding
  interactable dimension of the video.
  """
  size: Float

  """
  The percentage of the available space (0-100) (between the top and bottom player controls)
  that the extension aims to consume.
  
  NOTE:  targetHeight and aspectRatio will replace aspectHeight and aspectWidth,
         however, since both will be used for a short time during the rollout of the new UI,
         aspectWidth and aspectHeight will not be deprecated until later.
  """
  targetHeight: Int!

  """Relative path of the HTML file to load for this view."""
  viewerPath: String!

  """
  If hasZoom is set to true, specify the effective CSS zoom to apply to the long edge of the CE.
  Default: 1024.
  """
  zoomPixels: Int
}

"""
ConfigViewInput holds the view configuration of an extension if the config page is supported.
"""
input SaveConfigViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
ExtensionAssetManifestInput is data related to the assets of an extension.
"""
input SaveExtensionAssetManifestInput {
  """Hash of the asset zip file."""
  assetHash: String!
}

"""
ExtensionCapabilitiesInput contains data about what an Extension can do, in general, and at the time of interaction.
"""
input SaveExtensionCapabilitiesInput {
  """
  The bits support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  """
  bitsSupportLevel: ExtensionBitsSupportLevel = NONE

  """Location of configuration."""
  configurationLocation: ExtensionConfigurationLocation!

  """Does this extension use bits."""
  hasBitsSupport: Boolean!

  """Does this extension support chat."""
  hasChatSupport: Boolean!

  """Required configuration string."""
  requiredConfiguration: String!

  """
  The subscription support level required by the broadcaster for the extension to operate. Defaults to "NONE".
  """
  subscriptionsSupportLevel: ExtensionSubscriptionsSupportLevel

  """Whitelists for restricting extension access and behavior."""
  whitelists: ExtensionWhitelistsInput!

  """Will this extension request an identity link."""
  willRequestIdentityLink: Boolean!
}

"""
ExtensionDeveloperManifestInput is the developer specific extension data.
"""
input SaveExtensionDeveloperManifestInput {
  """Author email."""
  authorEmail: String!

  """Testing uri for extension development."""
  testingBaseURI: String!
}

"""Extension metadata used for discovery."""
input SaveExtensionDiscoveryManifestInput {
  """Name of the extension author."""
  authorName: String!

  """Extension categories."""
  categories: [ID!]!

  """Extension descriprion. 1024 character limit."""
  description: String!

  """games an extension is associated with."""
  games: [ID!]!

  """name of the extension."""
  name: String!

  """Url to an extensions privacy policy."""
  privacyPolicyURL: String!

  """Extension summary. 140 character limit."""
  summary: String!

  """Extension developers support email."""
  supportEmail: String!

  """Extension eula/tos url."""
  termsURL: String!

  """
  A summary of the extension's functionality from a viewer's perspective.
  """
  viewerSummary: String!
}

"""
SaveExtensionManifestError is an error associated with the saveExtensionManifest mutation.
"""
enum SaveExtensionManifestError {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_VERSION

  """At least one anchor must be specified."""
  ANCHOR_REQUIRED

  """HasZoom was specified but ZoomPixels is missing."""
  INVALID_ZOOM

  """The number of whitelisted broadcasters exceeds the limit."""
  MAX_BROADCASTERS

  """The number of whitelisted testing users exceeds the limit."""
  MAX_TESTERS

  """The number of whitelisted config URLs exceeds the limit."""
  MAX_WHITELISTED_CONFIG_URLS

  """The number of whitelisted panel URLs exceeds the limit."""
  MAX_WHITELISTED_PANEL_URLS

  """Extension names must be shorter than 40 characters."""
  INVALID_NAME_LENGTH

  """Extension description must be shorter than 1024 characters."""
  INVALID_DESCRIPTION_LENGTH

  """Extension summary must be shorter than 140 characters."""
  INVALID_SUMMARY_LENGTH

  """
  Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_AUTHOR_EMAIL

  """
  Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_SUPPORT_EMAIL

  """Extension author name length must be > 40."""
  INVALID_AUTHOR_NAME_LENGTH

  """
  Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TESTING_BASE_URI

  """
  Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TERMS_URI

  """
  Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_PRIVACY_URI

  """
  Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_COMPONENT_VIEWER_PATH

  """
  Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_PANEL_VIEWER_PATH

  """
  Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_VIDEO_OVERLAY_VIEWER_PATH

  """
  Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_CONFIG_VIEWER_PATH

  """
  Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_LIVE_CONFIG_VIEWER_PATH

  """
  Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_MOBILE_VIEWER_PATH

  """Extension component aspect width must be < 50 or > 1."""
  INVALID_COMPONENT_ASPECT_WIDTH

  """Extension component aspect height must be < 50 or > 1."""
  INVALID_COMPONENT_ASPECT_HEIGHT

  """Extension panel hiehgt must be < 500 or > 100."""
  INVALID_PANEL_HEIGHT

  """
  Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
  """
  INVALID_BITS_SUPPORT_LEVEL

  """Scale pixels must be set to a positive integer when autoscale is true."""
  INVALID_SCALING_PIXELS

  """Aspect Ratio X must be set to a positive integer."""
  INVALID_COMPONENT_ASPECT_RATIO_X

  """Aspect Ratio Y must be set to a positive integer."""
  INVALID_COMPONENT_ASPECT_RATIO_Y

  """Target Height must be set to a positve integer."""
  INVALID_COMPONENT_TARGET_HEIGHT

  """Extension viewer summary must be shorter than 140 characters."""
  INVALID_VIEWER_SUMMARY_LENGTH
}

"""SaveExtensionManifestInput updates the manifest."""
input SaveExtensionManifestInput {
  """ExtensionAssetManifest is data related to the assets of an extension."""
  assetManifest: SaveExtensionAssetManifestInput!

  """
  Data about what an Extension can do, in general, and at the time of interaction.
  """
  capabilities: SaveExtensionCapabilitiesInput!

  """ExtensionDeveloperManifest is the developer specific extension data."""
  developerManifest: SaveExtensionDeveloperManifestInput!

  """Extension metadata used for discovery."""
  discoveryManifest: SaveExtensionDiscoveryManifestInput!

  """The extension ID of the manifest to update."""
  id: ID!

  """The extension version to update."""
  version: String!

  """Extension views."""
  views: SaveExtensionViewsInput!
}

"""SaveExtensionManifestPayload returns the update Extension manifest."""
type SaveExtensionManifestPayload {
  """The error when the mutation fails to update an extension."""
  error: SaveExtensionManifestError

  """The updated extension manifest."""
  manifest: ExtensionManifest
}

"""The potential anchor-specific configurations and extension can have."""
input SaveExtensionViewsInput {
  """
  The developer configuration of the extension as a component extension, if supported.
  """
  component: SaveComponentViewInput

  """
  The developer configuration of the extension's configuration view, if supported.
  """
  config: SaveConfigViewInput

  """
  The developer configuration of the extension's live configuration dashboard view, if supported.
  """
  liveConfig: SaveLiveConfigViewInput

  """
  The developer configuration of the extension as a mobile extension, if supported.
  """
  mobile: SaveMobileViewInput

  """
  The developer configuration of the extension as a panel extension, if supported.
  """
  panel: SavePanelViewInput

  """
  The developer configuration of the extension as a video overlay extension, if supported.
  """
  videoOverlay: SaveVideoOverlayViewInput
}

"""
ExtensionWhitelistsInput contains whitelists for restricting extension access and behavior.
"""
input SaveExtensionWhitelistsInput {
  """
  List of broadcaster account IDs allowed to install an extension after release.
  If this is empty or missing, all broadcasters can use this extension.
  """
  broadcasters: [ID!]!

  """URLs which are permitted to be opened from the configuration dialog."""
  configURLs: [String!]!

  """
  URLs which are permitted to be opened from an extension set as a panel.
  """
  panelURLs: [String!]!

  """
  List of account IDs which should have access to a version of an extension.
  Users in this list are ignored by the broadcaster whitelist check.
  """
  testers: [ID!]!
}

"""
HiddenView holds the view configuration of an extension if it is a hidden load test extension.
"""
input SaveHiddenViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
LiveConfigViewInput holds the view configuration of an extension if the live config dashboard page is supported.
"""
input SaveLiveConfigViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
MobileViewInput holds the view configuration of an extension if mobile is supported.
"""
input SaveMobileViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
PanelViewInput holds the view configuration of an extension if the panel anchor is supported.
"""
input SavePanelViewInput {
  """The extension developer configured height of the panel extension."""
  height: Int!

  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported.
"""
input SaveVideoOverlayViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
Sony Computer Entertainment (SCE) title properties.
Used as part of stream metadata for PlayStation.
"""
type SCETitle {
  ageRating: Int
  attribute: String
  genre: String
  id: ID
  isPreset: Boolean
  language: String
  metadata: String
  name: String
  presetText: [String]
  presetTextDescription: String
  productID: String
  sessionID: String
  shortName: String
  storeURL: String
}

"""
Sony Computer Entertainment (SCE) user properties.
Used as part of stream metadata for PlayStation.
"""
type SCEUser {
  country: String
  npID: ID
  onlineID: ID
}

"""The channel schedule."""
type Schedule {
  """The ID of the schedule."""
  id: ID!

  """A period during which scheduled events temporarily cease."""
  interruption: ScheduleInterruption

  """The next uncancelled segment of the schedule."""
  nextSegment: ScheduleSegment

  """
  The segments after a specific date ordered by start time. This field can be
  paginated and return segments across week boundaries.
  """
  segmentList(first: Int = 10, after: Cursor, options: ScheduleSegmentListInput): ScheduleSegmentListConnection

  """
  All segments for the specified week. If relativeDate isn't provided, the current week is used.
  """
  segments(utcOffsetMinutes: Int, startingWeekday: String, relativeDate: Time, includeFutureSegments: Boolean): [ScheduleSegment!]
}

"""The interruption of a schedule."""
type ScheduleInterruption {
  """The end time when the schedule will no longer be disabled."""
  endAt: Time!

  """The reason the schedule is disabled."""
  reason: ScheduleInterruptionReason!

  """The start time when the schedule will be disabled."""
  startAt: Time!
}

"""The reason of an interruption of a schedule."""
enum ScheduleInterruptionReason {
  """The user is on vacation."""
  VACATION

  """Fallback value for reason unknown to the GQL schema."""
  OTHER
}

"""The segment of a schedule."""
type ScheduleSegment {
  """The UTC date when the segment is no longer cancelled."""
  cancelledUntil: Time

  """The game categories tied to this segment."""
  categories: [Game!]

  """The end time of the segment."""
  endAt: Time

  """The start date and time of the first occurrence of the segment."""
  firstOccurrenceDate: Time

  """Whether or not the current user has a reminder set for the segment."""
  hasReminder: Boolean!

  """The ID of the segment."""
  id: ID!

  """If this segment is cancelled or not."""
  isCancelled: Boolean!

  """
  A count of users who have a reminder set, available only to the schedule owner.
  """
  reminderCount: Int

  """
  The number of times the segment should repeat. If 1, this is a single segment.
  """
  repeatEndsAfterCount: Int

  """The start time of the segment."""
  startAt: Time!

  """The title of the segment."""
  title: String!
}

"""The days."""
enum ScheduleSegmentDay {
  """SUNDAY."""
  SUNDAY

  """MONDAY."""
  MONDAY

  """TUESDAY."""
  TUESDAY

  """WEDNESDAY."""
  WEDNESDAY

  """THURSDAY."""
  THURSDAY

  """FRIDAY."""
  FRIDAY

  """SATURDAY."""
  SATURDAY
}

"""Paginated list of segments using the Relay cursor specification."""
type ScheduleSegmentListConnection {
  """The list of schedule segments."""
  edges: [ScheduleSegmentListEdge!]

  """Pagination information for this connection."""
  pageInfo: PageInfo!
}

"""Element in a list of endorsed channels."""
type ScheduleSegmentListEdge {
  """Cursor identifying the position of this edge for future queries."""
  cursor: Cursor!

  """The information about the endorsed channel."""
  node: ScheduleSegment!
}

"""The inputs for the segmentList query."""
input ScheduleSegmentListInput {
  """Flag to indicate whether in progress segments should be returned."""
  ignoreInProgress: Boolean

  """
  The reference time to request segments after. If not provided, the current time will be used.
  """
  startTime: Time

  """
  The desired timezone for the times sent with the returned segments. If not set, UTC is used.
  """
  utcOffsetMinutes: Int
}

"""The optional parameters for scheduleSegment."""
input ScheduleSegmentOptions {
  """
  The reference time to request segments after. If not provided, the current time will be used.
  """
  relativeDate: Time

  """
  The desired timezone for the times sent with the returned segments. If not set, UTC is used.
  """
  utcOffsetMinutes: Int

  """
  The weekday that is used to mark the beginning of the week. If not supplied, this will default to "MONDAY".
  """
  startingWeekday: ScheduleSegmentDay
}

"""Whether the image should be set on a benefit or campaign."""
enum Scope {
  """Image is for a benefit."""
  BENEFIT

  """Image is for a campaign."""
  CAMPAIGN
}

"""Contains categories search results."""
type SearchCategoriesConnection {
  """List of matching game results."""
  edges: [SearchCategoriesEdge!]

  """Information about this page of categories."""
  pageInfo: PageInfo!

  """Total number of results."""
  totalCount: Int!
}

"""An element in the categories result, and its metadata."""
type SearchCategoriesEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the extension for the current edge."""
  node: Game!
}

"""Contains results for a searchFor query."""
type SearchFor {
  """Contains results for channels."""
  channels: SearchForResultUsers

  """Contains results for games."""
  games: SearchForResultGames

  """Contains results for live channels."""
  liveChannels: SearchForResultUsers

  """Contains results for related live channels."""
  relatedLiveChannels: SearchForResultRelatedLiveChannels

  """Contains results for users."""
  users: SearchForResultUsers

  """Contains results for videos."""
  videos: SearchForResultVideos
}

"""Contains a single result item and a tracking ID."""
type SearchForEdge {
  """List of matching items."""
  item: SearchForItem!

  """An id used for search metrics."""
  trackingID: ID!
}

"""Contains a single result item and a tracking ID."""
type SearchForEdgeRelatedLiveChannels {
  """List of matching items."""
  item: User!

  """An id used for search metrics."""
  trackingID: ID!
}

"""A result item may be a User, Game, or Video."""
union SearchForItem = Game | User | Video

"""SearchForOptions allows the user to target specific result types."""
input SearchForOptions {
  """List of indices to run a user's query against."""
  targets: [SearchForTarget!]
}

"""Contains game search results."""
type SearchForResultGames {
  """Cursor for fetching the next page of results."""
  cursor: String

  """List of edges containing game results and trackingIDs."""
  edges: [SearchForEdge!]!

  """List of matching game results."""
  items: [Game!]

  """Information about this page."""
  pageInfo: PageInfo!

  """Order in which the result should be displayed."""
  score: Int!

  """Total number of results."""
  totalMatches: Int!
}

"""Contains results for related live channels."""
type SearchForResultRelatedLiveChannels {
  """List of edges containing user results and trackingIDs."""
  edges: [SearchForEdgeRelatedLiveChannels!]!

  """List of matching user results."""
  items: [User!]

  """Optional score associated with the related live section."""
  score: Int
}

"""Contains user search results."""
type SearchForResultUsers {
  """Cursor for fetching the next page of results."""
  cursor: String

  """List of edges containing user results and trackingIDs."""
  edges: [SearchForEdge!]!

  """List of matching user results."""
  items: [User!]

  """Information about this page."""
  pageInfo: PageInfo!

  """Order in which the result should be displayed."""
  score: Int!

  """Total number of results."""
  totalMatches: Int!
}

"""Contains video search results."""
type SearchForResultVideos {
  """Cursor for fetching the next page of results."""
  cursor: String

  """List of edges containing video results and trackingIDs."""
  edges: [SearchForEdge!]!

  """List of matching video results."""
  items: [Video!]

  """Information about this page."""
  pageInfo: PageInfo!

  """Order in which the result should be displayed."""
  score: Int!

  """Total number of results."""
  totalMatches: Int!
}

"""Specify which index to run a user's search."""
input SearchForTarget {
  """
  Pagination cursor for user to optionally provide to request a specific page of results.
  """
  cursor: String

  """Search index to run a user's query against."""
  index: SearchIndex!

  """Limit the number of results returned."""
  limit: Int
}

"""Enumeration of indexes a search query can target."""
enum SearchIndex {
  """Game index."""
  GAME

  """User index."""
  USER

  """Video on demand index."""
  VOD

  """Live channel index."""
  LIVE

  """Channel index."""
  CHANNEL
}

"""SearchOptions to customize results returned by the search query."""
input SearchOptions {
  """
  List of indices to run a user's query against. If no targets are specified,
  the query is run against all the indices listed in SearchIndex.
  """
  targets: [SearchTarget!]
}

"""
Contains the result returned by the search engine for a particular query.
"""
type SearchResult {
  """JSON encoded as a string."""
  result: String!
}

"""List of users."""
type SearchStreamConnection {
  """List of matching channels results."""
  edges: [SearchStreamEdge!]

  """Information about this page of videos."""
  pageInfo: PageInfo!

  """The total number of items in the collection."""
  totalCount: Int!
}

"""An element in a paginated list of videos, and its metadata."""
type SearchStreamEdge {
  """The cursor of the channel record list. This is same for one page."""
  cursor: Cursor!

  """The channel result returned."""
  node: Stream!
}

"""A search suggestion."""
type SearchSuggestion {
  """Extra data for category or channel type of search suggestion."""
  content: SearchSuggestionContent

  """The part of the suggestion that matches the search query."""
  highlight: SearchSuggestionHighlight! @deprecated(reason: "Use 'matchingCharacters' instead.")

  """The search suggestion's unique identifier."""
  id: ID!

  """The part of the suggestion that matches the search query."""
  matchingCharacters: SearchSuggestionHighlight

  """The search suggestion string."""
  text: String!
}

"""A category search suggestion."""
type SearchSuggestionCategory {
  """
  The boxart URL for the category, provided by the endpoint.
  Use this field for lower latency.
  
  The image dimensions are specifiable via the `height` and `width` parameters.
  If `height` or `width` are not specified, the URL will contain
  the template strings `{height}` and/or `{width}` in their respective places.
  """
  boxArtURL(width: Int, height: Int): String!

  """The category."""
  game: Game

  """The category's unique identifier."""
  id: ID!
}

"""A channel search suggestion."""
type SearchSuggestionChannel {
  """The channel's unique identifier."""
  id: ID!

  """
  Whether or not the channel is verified, provided by the endpoint.
  Use this field for lower latency.
  """
  isVerified: Boolean!

  """
  The login of the channel, provided by the endpoint.
  Use this field for lower latency.
  """
  login: String!

  """
  The profile image URL for the channel, provided by the endpoint.
  Use this field for lower latency.
  
  Valid widths are 28, 50, 70, 150, 300, and 600.
  The image height will be the same as the given width.
  """
  profileImageURL(width: Int!): String

  """The user of the channel."""
  user: User
}

"""A list of search suggestions and related tracking data."""
type SearchSuggestionConnection {
  """The list of search suggestions."""
  edges: [SearchSuggestionEdge!]

  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  pageInfo: PageInfo!

  """Tracking data for the search suggestions."""
  tracking: SearchSuggestionTracking
}

"""The types with additional content in a search suggestion."""
union SearchSuggestionContent = SearchSuggestionCategory | SearchSuggestionChannel

"""Edge containing the search suggestion."""
type SearchSuggestionEdge {
  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  cursor: Cursor!

  """The search suggestion."""
  node: SearchSuggestion!
}

"""A range that matches the search query."""
type SearchSuggestionHighlight {
  """The end of the match."""
  end: Int!

  """The start of the match."""
  start: Int!
}

"""An object containing tracking data for a search suggestion."""
type SearchSuggestionTracking {
  """The unique identifier of the model instance."""
  modelTrackingID: ID!

  """The unique identifier generated for every response."""
  responseID: ID!
}

"""Specify which index to run a user's search."""
input SearchTarget {
  """
  When true, response will return  the total number of matching documents in
  index for a given query. The value for limit is ignored and assumed to be zero.
  """
  countTotalMatches: Boolean

  """Search index to run a user's query against."""
  index: SearchIndex!

  """Max number of matching documents that will be returned."""
  limit: Int!
}

"""A list of user returned from forage by user query."""
type SearchUserConnection {
  """List of matching user results."""
  edges: [SearchUserEdge!]

  """Information about this page."""
  pageInfo: PageInfo!

  """Total number of results."""
  totalCount: Int!
}

"""Element in a list of users returned from forage."""
type SearchUserEdge {
  """
  Cursor for fetching the next page of results(only on last edge of current connection).
  """
  cursor: Cursor!

  """The information about user."""
  node: User!
}

"""Season metadata."""
type SeasonDetails {
  """Number of episodes."""
  episodeCount: Int

  """The season number."""
  season: Int
}

"""Inputs for seeding a competition participant."""
input SeedCompetitionParticipantInput {
  """ID of the competition."""
  competitionID: ID!

  """ID of the competition player or competition team."""
  participantID: ID!

  """The assigned seed value."""
  seedValue: Int!
}

"""
SeedCompetitionParticipantPayload is the success response for seeding a competition player or competition team.
"""
type SeedCompetitionParticipantPayload {
  """
  The new state of competition after seeding a competition player or competition team.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""An enumeration of the statuses of suggested segments."""
enum SegmentsStatusType {
  """The suggested segments have successfully been created."""
  COMPLETED

  """There wasn't enough data to generate suggested segments."""
  NOT_ENOUGH_DATA

  """The vod is currently being processed for suggested segments."""
  IN_PROGRESS

  """The backend failed to generate suggested segments."""
  FAILED
}

"""The segment start time input."""
input SegmentStartTimeInput {
  """The day of the segment."""
  day: ScheduleSegmentDay!

  """The hour of the segment 0-23."""
  hour: Int!

  """The minute of the segment 0-59."""
  minute: Int!
}

"""Inputs for selecting a channel badge."""
input SelectChannelBadgeInput {
  """Set ID of the badge to select."""
  badgeSetID: ID!

  """Optional Version of the Badge to select."""
  badgeSetVersion: String

  """ID of the channel this badge is selected on."""
  channelID: ID!
}

"""The output for the select channel badge mutation."""
type SelectChannelBadgePayload {
  """Indicates if selecting the badge was successful."""
  isSuccessful: Boolean

  """The channel (user object of channel) this badge is selected on."""
  user: User
}

"""Inputs for selecting a global badge."""
input SelectGlobalBadgeInput {
  """Set ID of the badge to select."""
  badgeSetID: ID!

  """Optional Version of the Badge to select."""
  badgeSetVersion: String
}

"""The output for the select global badge mutation."""
type SelectGlobalBadgePayload {
  """Indicates if selecting the badge was successful."""
  isSuccessful: Boolean

  """The user of the selected badge."""
  user: User
}

"""
An interface to represent the logged in user's relationship to the claimable.
"""
interface SelfClaimEdge {
  """If the user is eligible to claim the object."""
  canClaim: Boolean!

  """Nullable field for the country where the user redeemed the claimable."""
  countryOfResidence: String

  """The user ID that is claiming."""
  id: ID!

  """Nullable status code for if the user cannot claim the object."""
  statusCode: String
}

"""
Input for sending a chat message through subscriber-only mode with Channel Points.
"""
input SendChatMessageThroughSubscriberModeInput {
  """The channel the message is being sent to."""
  channelID: ID!

  """The client's perception of the reward's cost."""
  cost: Int!

  """The user's message."""
  message: String!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""The response from redeeming the skip subs only chat message reward."""
type SendChatMessageThroughSubscriberModePayload {
  """The user's new Channel Points balance."""
  balance: Int

  """The error that occurred during redemption, if any."""
  error: SendCopoMessageError

  """Whether the message was flagged by Automod and held for review."""
  isHeldByAutomod: Boolean
}

input SendCheerInput {
  """
  bits is the number of bits the message will spend (as parsed by the client).
  """
  bits: Int!

  """content is the text to process and forward to the chat system."""
  content: String!

  """
  Client-generated unique ID used to prevent a cheer from being re-sent (thus spending double bits).
  The server will reject any request with an ID that has already been used.
  """
  id: ID!

  """
  Optional field that dictates the user wants their cheer to appear anonymously (i.e. unassociated with their username).
  """
  isAnonymous: Boolean = false

  """
  Optional field that dictates whether automod should be enabled for the cheer or not.
  """
  isAutoModEnabled: Boolean

  """
  Optional field that dictates the cheer message was sent from a room, as this provides the context for what room
  it was sent from.
  """
  roomID: ID

  """
  Optional field that dictates that the user want to cheer anyways, even though they know it will be automodded.
  """
  shouldCheerAnyway: Boolean

  """targetID is the `User.id` of the channel to send the cheer to."""
  targetID: ID!
}

type SendCheerPayload {
  """
  currentUser is the authenticated user object which includes the updated
  `Wallet` info after the message bits have been spent.
  """
  currentUser: User

  """id is the client-generated value passed in as part of the request."""
  id: ID!

  """If any validation errors occur, this will not be nil."""
  validationError: SendCheerValidationError
}

"""Resolver for validation errors that occur on send cheer."""
type SendCheerValidationError {
  """Error code that describes the validation error."""
  code: SendCheerValidationErrorCode!

  """Error message that is returned from the backend service."""
  message: String!

  """
  Optional rejected message for when the error requires frontend message changes, like AutoMod'd messages.
  """
  messageContent: RoomMessageContent
}

"""Validation error status codes."""
enum SendCheerValidationErrorCode {
  """Bits amount is below the minimum."""
  AMOUNT_BELOW_MIN_BITS

  """The message was auto modded."""
  AUTO_MOD_MESSAGE

  """The channel was ineligible for receiving bits."""
  CHANNEL_INELIGIBLE

  """The emote amount was below the minimum bits emote amount."""
  EMOTE_AMOUNT_BELOW_MIN_BITS

  """The user has insufficient balance."""
  INSUFFICIENT_BALANCE

  """The bits amount is invalid."""
  INVALID_BITS_AMOUNT

  """The bits message is invalid."""
  INVALID_BITS_MESSAGE

  """The event ID is invalid, probably because it's been used."""
  INVALID_EVENT_ID

  """The message length is greater than the max message length."""
  MESSAGE_LENGTH_EXCEEDED

  """The request has been throttled."""
  REQUEST_THROTTLED

  """The bits emotes that were sent were greater than the max allowed."""
  TOO_LARGE_BITS_EMOTE

  """The cheer was over the maximum cheer limit."""
  TOO_LARGE_CHEER

  """An unknown error has occurred, but it was a validation error."""
  UNKNOWN

  """The user is banned from bits."""
  USER_BANNED

  """The user is ineligible to send bits."""
  USER_INELIGIBLE

  """The use is suspended from sending bits."""
  USER_SUSPENDED

  """The message contained Zalgo text."""
  ZALGO_MESSAGE

  """The message was not processed due to an automodded pending cheer."""
  AUTO_MOD_PENDING

  """The message contained term(s) blocked by the channel."""
  CHANNEL_BLOCKED_TERMS

  """The anonymous message contained text that is invalid."""
  INVALID_ANONYMOUS_MESSAGE

  """
  The bits message contained an anonymous cheermote when it's not allowed (ex: in public cheers).
  """
  ANONYMOUS_CHEERMOTE_NOT_ALLOWED
}

"""An error from redeeming a chat message Channel Points reward."""
type SendCopoMessageError {
  """The error code."""
  code: SendCopoMessageErrorCode
}

"""Possible errors from redeeming a chat message Channel Points reward."""
enum SendCopoMessageErrorCode {
  """User has previously sent an identical message."""
  MSG_DUPLICATE

  """The user is suspended from Twitch."""
  USER_SUSPENDED

  """The user is banned in the channel."""
  USER_BANNED

  """The user is timed out in the channel."""
  USER_TIMED_OUT

  """The chat is emote-only mode and the message contained text."""
  EMOTE_ONLY

  """The chat is in slow mode and the user has recently sent a message."""
  SLOW_MODE

  """
  The chat is in followers-only mode and the user has not been following long enough.
  """
  FOLLOWERS_ONLY

  """The chat is in followers-only mode and the user is not following."""
  FOLLOWERS_ONLY_ZERO

  """The chat is in subs-only mode and the user is not subbed."""
  SUBS_ONLY

  """
  The chat is in r9k-only mode (relatively unique messages) and the message was not unique.
  """
  R9K_MODE

  """
  The chat is in Blizzard connect mode and the user does not have their Blizzard account connected.
  """
  BLIZZARD_CONNECT_MODE

  """
  The chat is in verified account mode and the user's account is not verified.
  """
  VERIFIED_ACCOUNT

  """The user's message contained a blocked phrase."""
  CHANNEL_SETTINGS

  """The user's message was flagged by Automod and is being reviewed."""
  AUTOMOD_HELD @deprecated(reason: "use isHeldByAutomod on the payload instead")

  """
  The user's message was rejected for another reason- possibly intentionally hidden, such as IP block.
  """
  MESSAGE_REJECTED

  """The request failed due to an underlying server error."""
  SERVER_ERROR

  """The user does not have sufficient points to redeem the reward."""
  INSUFFICIENT_POINTS

  """
  The client is retrying a redemption with a transaction id that has already been redeemed.
  """
  TRANSACTION_ALREADY_COMMITTED

  """
  The client is retrying a redemption with a transaction id that is currently being redeemed in another request.
  """
  TRANSACTION_IN_PROGRESS

  """The reward cost has changed since the user has tried to redeem it."""
  REWARD_COST_MISMATCH

  """The reward is currently disabled."""
  REWARD_DISABLED

  """The user is not allowed to redeem this reward on this channel."""
  REWARD_FORBIDDEN

  """The user's message starts with a '/' like a chat command."""
  MESSAGE_IS_COMMAND

  """An unknown error occurred."""
  UNKNOWN
}

"""Error type."""
type SendExtensionMessageError {
  """Error code."""
  code: SendExtensionMessageErrorCode!
}

"""Possible error reasons returned by sendExtensionMessage mutation."""
enum SendExtensionMessageErrorCode {
  """Unauthorized."""
  UNAUTHORIZED

  """Unknown error."""
  UNKNOWN
}

"""Input to the sendExtensionMessage mutation."""
input SendExtensionMessageInput {
  """The channelID the extension is active on."""
  channelID: ID!

  """The type of the content."""
  contentType: String!

  """A JWT token signed with the shared secret for this extension."""
  extAuthToken: String!

  """The ID of the extension which is sending the message."""
  extensionID: ID!

  """The content of the message to be sent."""
  message: String!

  """The set of target message receievers to send to, e.g. "broadcast"."""
  targets: [String!]!
}

"""Payload returned from the sendExtensionMessage mutation."""
type SendExtensionMessagePayload {
  """error, if any."""
  error: SendExtensionMessageError

  """Information about what rate limits, if any, were applied to this send."""
  rateLimitsApplied: [SendExtensionMessageThrottleData!]
}

"""Information about a rate limit throttle."""
type SendExtensionMessageThrottleData {
  """Was the rate limit exceeded."""
  isLimitExceeded: Boolean!

  """The limit itself."""
  limit: String!

  """Name of the rate limiter applied."""
  rateLimiterName: String!

  """How much quota remains."""
  remainingQuota: Int!

  """Time when this rate limit will reset."""
  resetsAt: Time
}

"""Input for sending a highlighted chat message with Channel Points."""
input SendHighlightedChatMessageInput {
  """The channel the message is being sent to."""
  channelID: ID!

  """The client's perception of the reward's cost."""
  cost: Int!

  """The user's message."""
  message: String!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""The response from redeeming the highlighted chat message reward."""
type SendHighlightedChatMessagePayload {
  """The user's new Channel Points balance."""
  balance: Int

  """The error that occurred during redemption, if any."""
  error: SendCopoMessageError

  """Whether the message was flagged by Automod and held for review."""
  isHeldByAutomod: Boolean
}

type SendRoomMessageError {
  code: SendRoomMessageErrorCode!

  """
  On SLOW_MODE_ENFORCEMENT_FAILED, USER_CHAT_TIMED_OUT: the number of remaining
  seconds user must wait before sending another message.
  """
  remainingDurationSeconds: Int

  """
  On SLOW_MODE_ENFORCEMENT_FAILED: the number of seconds users must wait in between sending messages.
  """
  slowModeDurationSeconds: Int
}

enum SendRoomMessageErrorCode {
  """User not allowed to chat in room."""
  FORBIDDEN

  """Message failed automod check."""
  AUTO_MOD_ENFORCEMENT_FAILED

  """Room is in emotes only mode and message contained non-emote text."""
  EMOTE_ONLY_MODE_ENFORCEMENT_FAILED

  """Room is in R9K mode and message was not unique."""
  R9K_MODE_ENFORCEMENT_FAILED

  """User is rate limited."""
  RATE_LIMIT_FAILED

  """Room is in slow mode and user tried to send a message to quickly."""
  SLOW_MODE_ENFORCEMENT_FAILED

  """Message failed spam check."""
  SPAM_ENFORCEMENT_FAILED

  """Message contained zalgo characters."""
  ZALGO_ENFORCEMENT_FAILED

  """User is banned in the channel."""
  USER_CHAT_BANNED

  """User is timed out in the channel."""
  USER_CHAT_TIMED_OUT

  """User is suspended from Twitch."""
  USER_SUSPENDED
}

input SendRoomMessageInput {
  message: String!

  """
  Optional nonce which will be included in the pubsub event for this message.
  """
  nonce: String
  roomID: ID!
}

type SendRoomMessagePayload {
  error: SendRoomMessageError
  message: RoomMessage
}

"""Error code for when a mutation fails."""
type SendWhisperError {
  """Error code for the failed whisper send."""
  code: SendWhisperErrorCode!
}

"""Possible errors returned by the sendWhisper mutation."""
enum SendWhisperErrorCode {
  """Target is banned."""
  TARGET_BANNED

  """Message body is empty."""
  BODY_EMPTY

  """Target's settings prevent them from receiving message."""
  TARGET_RESTRICTED

  """Sender does not have a verified account."""
  SENDER_NOT_VERIFIED

  """Whisper was not delivered for an unspecified reason."""
  NOT_DELIVERED
}

input SendWhisperInput {
  """Message to send to user."""
  message: String!

  """
  Random string generated by the client and should be unique across messages.
  """
  nonce: String!

  """User to send a whisper to."""
  recipientUserID: ID!
}

type SendWhisperPayload {
  """If an error occurred, the error code. Otherwise null."""
  error: SendWhisperError

  """The message that was sent, or null if there was an error."""
  message: WhisperMessage
}

"""The SEO metatag of a twitch webpage."""
type SEOMetatag {
  """The attributes of the tag."""
  attributes: [SEOMetatagAttribute!]!

  """The name of the tag."""
  name: String!
}

"""An attribute of a metatag."""
type SEOMetatagAttribute {
  """The key of the attribute."""
  key: String!

  """The value of the attribute."""
  value: String!
}

"""Series metadata."""
type SeriesDetails {
  """Number of seasons."""
  seasonCount: Int
}

"""Sets the auto ad density for the channel."""
input SetAutoAdDensityInput {
  """Input for auto ad length seconds."""
  autoAdLengthSeconds: Int!

  """Input for auto ad period minutes."""
  autoAdPeriodMinutes: Int!

  """Input for target ID of channel."""
  targetChannelID: ID!
}

"""Shows the newly updated values for autoad settings."""
type SetAutoAdDensityPayload {
  """The user whose channels ad density was set."""
  autoAdLengthSeconds: Int

  """Auto ad period minutes."""
  autoAdPeriodMinutes: Int

  """Input for target ID of channel."""
  targetChannelID: ID
}

"""SetAutohostChannelsInput sets the user's list to autohost."""
input SetAutohostChannelsInput {
  """ChannelIDs that will be on the list to autohost."""
  channelIDs: [ID!]!

  """UserID to update autohost list for."""
  userID: ID!
}

"""
SetAutohostChannelsPayload returns the user whose autohostChannels field had been updated.
"""
type SetAutohostChannelsPayload {
  """User whose autohostChannels field had been updated."""
  user: User
}

"""Input for setting auto refill settings."""
input SetAutoRefillSettingsInput {
  """The charge instrument information for starting a purchase."""
  chargeInstrument: ChargeInstrumentInput!

  """The currency this should be charged in."""
  currency: Currency!

  """
  The gross amount (of currency) that can be charged on the charge instrument.
  """
  grossAmount: Int!

  """Optional id of the auto refill settings that are being modified."""
  id: ID

  """Indicates if the profile is active."""
  isEnabled: Boolean!

  """Id of the refill offer used on auto refill."""
  offerID: ID!

  """The threshold amount a balance must go below to trigger a reload."""
  threshold: Int!
}

"""The payload for the set auto refill settings mutation."""
type SetAutoRefillSettingsPayload {
  """The changed auto refill profile."""
  autoRefillProfile: AutoRefillProfile
}

"""Input for the set bits user settings mutation."""
input SetBitsUserSettingsInput {
  """
  Optional field that dictates whether a user has exited out of the first cheer tutorial by clicking out of the experience.
  """
  abandonedFirstCheerTutorial: Boolean

  """
  Optional field that dictates whether a user has skipped the first cheer tutorial by clicking the skip button.
  """
  skippedFirstCheerTutorial: Boolean
}

"""Payload for set bits user settings mutation."""
type SetBitsUserSettingsPayload {
  """
  currentUser is the authenticated user object which includes the updated
  `Wallet` info after the message bits have been spent.
  """
  currentUser: User
}

input SetChannelFeedEnabledInput {
  """The new desired value for channel_feed_enabled."""
  enabled: Boolean!
}

type SetChannelFeedEnabledPayload {
  """The user whose channel feed setting was toggled."""
  user: User!
}

input SetChannelNotificationSettingInput {
  category: String!
  channelID: ID!
  platform: String!
  settingState: String!
}

type SetChannelNotificationSettingPayload {
  settingState: String!
}

"""
SetChannelTrailerErrorCode are the types of errors that the setChannelTrailer mutation may return.
"""
enum SetChannelTrailerErrorCode {
  """The caller is not authorized to update the user's trailer settings."""
  UNAUTHORIZED

  """The vod is longer than 60 seconds (max time for channel trailers)."""
  VOD_TOO_LONG
}

"""Inputs to the setChannelTrailer mutation."""
input SetChannelTrailerInput {
  """The channel whose trailer should be updated."""
  channelID: ID!

  """
  The ID of the video that should be used as the channel's trailer,
  or null if the trailer should be cleared.
  """
  trailerVideoID: ID
}

"""Output of the setChannelTrailer mutation."""
type SetChannelTrailerPayload {
  """The channel whose trailer vod was modified."""
  channel: Channel

  """
  The error if the mutation failed in an expected way, or null if the mutation was successful.
  """
  error: SetChannelTrailerErrorCode
}

"""The required input to set a user's chat pause setting."""
input SetChatPauseSettingInput {
  """The desired method for a user to pause chat."""
  chatPauseSetting: ChatPauseSetting!
}

"""Result of a setChatPauseSetting mutation."""
type SetChatPauseSettingPayload {
  """The newly saved chat pause setting."""
  chatPauseSetting: ChatPauseSetting
}

"""Update tags associated with CLIP, STREAM, or VOD with contentID."""
input SetContentTagsInput {
  """ID of the channel owning the content."""
  authorID: ID!

  """
  ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  """
  contentID: ID!

  """
  Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  """
  contentType: ContentType!

  """List of tag IDs to be replaced from the content."""
  tagIDs: [ID!]!
}

"""Result of mutation is the contentID."""
type SetContentTagsPayload {
  """Content which tags have been updated."""
  content: TaggedContent
}

"""The input to be provided to the SetCreatorBadgeFlair mutation."""
input SetCreatorBadgeFlairInput {
  """ID for channel to apply setting for."""
  channelID: ID!

  """Setting to apply to channel setting for badge flair."""
  creatorBadgeFlair: CreatorBadgeFlairSetting!
}

type SetCreatorBadgeFlairPayload {
  """Channel whose badge flair setting was updated."""
  channel: Channel
}

"""
SetDashboardAlertQueueActivityStatusError is the error associated with SetDashboardAlertQueueActivityStatus.
"""
type SetDashboardAlertQueueActivityStatusError {
  """The associated error code."""
  code: SetDashboardAlertQueueActivityStatusErrorCode!
}

"""
SetDashboardAlertQueueActivityStatusErrorCode are the possible errors that this mutation returns.
"""
enum SetDashboardAlertQueueActivityStatusErrorCode {
  """The input activity ID is invalid."""
  INVALID_ACTIVITY_ID

  """The input alert status is invalid."""
  INVALID_ALERT_STATUS

  """The input channel ID is invalid."""
  INVALID_CHANNEL_ID

  """The alert is not found."""
  NOT_FOUND
}

"""Inputs to the SetDashboardAlertQueueActivityStatus mutation."""
input SetDashboardAlertQueueActivityStatusInput {
  """
  The ID corresponding to the activity whose alert queue activity status should be updated.
  """
  activityID: ID!

  """The value to set the status to."""
  alertStatus: DashboardActivityFeedActivityAlertStatus!

  """
  The ID corresponding to the user whose alert queue activity status should be updated.
  """
  userID: ID!
}

"""Outputs from the SetDashboardAlertQueueActivityStatus mutation."""
type SetDashboardAlertQueueActivityStatusPayload {
  """The updated activity."""
  activity: DashboardActivityFeedActivity

  """The possible error returned from the service."""
  error: SetDashboardAlertQueueActivityStatusError
}

"""
SetDashboardAlertQueuePreferenceError is the error associated with SetDashboardAlertQueuePreference.
"""
type SetDashboardAlertQueuePreferenceError {
  """The associated error code."""
  code: SetDashboardAlertQueuePreferenceErrorCode!
}

"""
SetDashboardAlertQueuePreferenceErrorCode are the possible errors that this mutation returns.
"""
enum SetDashboardAlertQueuePreferenceErrorCode {
  """The input channel ID is invalid."""
  INVALID_CHANNEL_ID
}

"""
Inputs to the SetDashboardAlertQueuePreference mutation. Only one of the boolean settings should be set at once.
"""
input SetDashboardAlertQueuePreferenceInput {
  """If true, cannot publish alerts to the user."""
  shouldEnableDNDMode: Boolean

  """If true, cannot publish bits alerts to the user."""
  shouldHideBits: Boolean

  """If true, cannot publish follows alerts to the user."""
  shouldHideFollows: Boolean

  """If true, cannot publish subscription gift alerts to the user."""
  shouldHideGiftSubscriptions: Boolean

  """If true, cannot publish hosts alerts to the user."""
  shouldHideHosts: Boolean

  """If true, cannot publish raids alerts to the user."""
  shouldHideRaids: Boolean

  """
  If true, cannot publish regular subscriptions alerts to the user (gift subs are still shown).
  """
  shouldHideSubscriptions: Boolean

  """
  The ID corresponding to the user whose alert queue preference should be updated.
  """
  userID: ID!
}

"""Outputs from the SetDashboardAlertQueuePreference mutation."""
type SetDashboardAlertQueuePreferencePayload {
  """The possible error returned from the service."""
  error: SetDashboardAlertQueuePreferenceError

  """The updated preferences for dashboard alert queue."""
  preferences: DashboardAlertQueuePreferences
}

"""Enumerates possible errors when setting a default payment method."""
enum SetDefaultPaymentMethodErrorCode {
  """Must have auth credentials to set default payment method."""
  UNAUTHENTICATED

  """
  User does not have permission to set default payment method for the targeted user.
  """
  FORBIDDEN

  """One or more fields are invalid or missing."""
  INVALID_REQUEST

  """An internal error has occurred."""
  INTERNAL_ERROR
}

"""The input to be provided to the setDefaultPaymentMethod mutation."""
input SetDefaultPaymentMethodInput {
  """
  Country (ISO-3166) associated to the billing info for the customer's payment method.
  """
  billingCountry: String

  """The last four digits of the user provided account number."""
  lastFour: String

  """Payment type used via the payment provider."""
  paymentType: PaymentInstrumentType!

  """The payment provider we're updating the payment method on."""
  provider: PaymentProvider!

  """The token used to verify the selected payment method."""
  token: String!

  """The user to set default payment method for."""
  userID: ID!
}

"""The result of the setDefaultPaymentMethod mutation."""
type SetDefaultPaymentMethodPayload {
  """
  Code to describe error that occurred while setting the default payment method.
  """
  errorCode: SetDefaultPaymentMethodErrorCode

  """User who had their payment method updated."""
  user: User
}

"""The required input to set a user's deleted message display setting."""
input SetDeletedMessageDisplaySettingInput {
  """The desired deleted message display setting to be saved."""
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting!
}

"""Result of a setDeletedMessageDisplaySetting mutation."""
type SetDeletedMessageDisplaySettingPayload {
  """The newly saved deleted message display setting."""
  deletedMessageDisplaySetting: DeletedMessageDisplaySetting
}

"""
SetDropBenefitsOnDropInput has fields required to update a drop's list of benefits.
"""
input SetDropBenefitsOnDropInput {
  """The benefits that should be awarded when this drop is claimed."""
  benefitIDs: [ID!]!

  """The drop to update."""
  dropID: ID!
}

"""
SetDropBenefitsOnDropPayload returns the result of the creation/update.
"""
type SetDropBenefitsOnDropPayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
SetDropCampaignAccessInput has fields required to update a campaign's access.
"""
input SetDropCampaignAccessInput {
  """A list of channels that are allowed for this campaign."""
  allowedChannels: [ID!]

  """A list of channels that are blocked from this campaign."""
  blockedChannels: [ID!]

  """The campaign ID."""
  campaignID: ID!

  """
  Is the allowedChannels list in effect. Just having allowedChannels present
  does not mean the access list should be enabled.
  """
  isAllowedChannelsEnabled: Boolean!

  """
  Is the blockedChannels list in effect. Just having blockedChannels present does not mean the block list should be enabled.
  """
  isBlockedChannelsEnabled: Boolean!

  """
  A list of users that are able to view this campaign and functionalities while the campaign is in the testing state.
  """
  testViewers: [ID!]
}

"""SetDropCampaignAccessPayload returns the result of the update."""
type SetDropCampaignAccessPayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
SetDropCampaignStatusInput has fields required to update a campaign's status.
"""
input SetDropCampaignStatusInput {
  """The campaign ID."""
  campaignID: ID!

  """The status the campaign should receive."""
  status: DropCampaignStatus!
}

"""
SetDropCampaignStatusPayload returns the result of the creation/update.
"""
type SetDropCampaignStatusPayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
SetDropCampaignSummaryInput has fields required to update a campaign summary.
"""
input SetDropCampaignSummaryInput {
  """The redirect URL where a user can link their account."""
  accountLinkURL: String!

  """The campaign ID."""
  campaignID: ID!

  """
  The type of a campaign defines what type of drops are allowed to be added to the campaign.
  """
  campaignType: CampaignType

  """The description of this campaign."""
  description: String!

  """The URL that links to the details / marketing page for this drop."""
  detailsURL: String!

  """
  The date at which this campaign ends and all contained drops end at the latest.
  """
  endAt: Time!

  """The game associated with this campaign."""
  gameID: ID!

  """The name of the campaign."""
  name: String!

  """
  This is the Organization ID (RBAC) to determine access / ownership of the campaign and attached drops.
  """
  ownerID: ID!

  """
  The date at which this campaign starts and all contained drops start the earliest.
  """
  startAt: Time!
}

"""
SetDropCampaignSummaryPayload returns the result of the creation/update.
"""
type SetDropCampaignSummaryPayload {
  """Returns the created/updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
SetDropEventRuleInput has the fields required to set an event based rule on a drop.
"""
input SetDropEventRuleInput {
  """How long the viewer has to claim their reward."""
  claimDurationSeconds: Int!

  """The associated drop for the rule to update."""
  dropID: ID!

  """The in-game conditions that must be met for the drop to trigger."""
  eventRules: [DropEventConditionInput!]!

  """A textual description of what has to occur for the drop to trigger."""
  questDescription: String!

  """Name of the drop."""
  questName: String!
}

"""SetDropRulePayload returns the result of the rule creation."""
type SetDropEventRulePayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
SetDropManualTriggerRuleInput has the fields required to set a manual trigger based rule on a drop.
"""
input SetDropManualTriggerRuleInput {
  """How long the viewer has to claim their reward."""
  claimDurationSeconds: Int!

  """The associated drop for the rule to update."""
  dropID: ID!
}

"""
SetDropManualTriggerRulePayload returns the result of the rule creation.
"""
type SetDropManualTriggerRulePayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""SetDropSummaryInput has fields required to update a drop's summary."""
input SetDropSummaryInput {
  """The associated drop for the summary to update."""
  dropID: ID!

  """The date at which this drop can no longer occur."""
  endAt: Time

  """The friendly name of this drop."""
  name: String!

  """The date at which this drop can start to occur."""
  startAt: Time
}

"""SetDrop2BenefitPayload returns the result of the creation/update."""
type SetDropSummaryPayload {
  """Returns the created/updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
SetDropTimeBasedRuleInput has fields required to update a drop's rule to a minutes watched based rule.
"""
input SetDropTimeBasedRuleInput {
  """The associated drop for the rule to update."""
  dropID: ID!

  """
  The ID of the drop that must be claimed before you can make progress on this drop.
  """
  preconditionDropID: ID!

  """
  The amount of minutes a viewer must have watched before they can claim this drop.
  """
  requiredMinutesWatched: Int!
}

"""SetDropTimeBasedRulePayload returns the result of the rule update."""
type SetDropTimeBasedRulePayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""The required input to set a user's emote animations setting."""
input SetEmoteAnimationsEnabledInput {
  """Whether emote animations should be enabled for the current user."""
  isEmoteAnimationsEnabled: Boolean!
}

"""Result of a setEmoteAnimationsEnabled mutation."""
type SetEmoteAnimationsEnabledPayload {
  """Whether emote animations are enabled for the current user."""
  isEmoteAnimationsEnabled: Boolean
}

"""
The required input to set a user's emote animations setting callout dismissed.
"""
input SetEmoteAnimationsSettingCalloutDismissedInput {
  """Whether the emote animations setting callout is dismissed by the user."""
  isEmoteAnimationsSettingCalloutDismissed: Boolean!
}

"""Result of a setEmoteAnimationsSettingCalloutDismissed mutation."""
type SetEmoteAnimationsSettingCalloutDismissedPayload {
  """Whether the emote animations setting callout is dismissed by the user."""
  isEmoteAnimationsSettingCalloutDismissed: Boolean
}

"""Possible errors from this mutation."""
type SetEmoteModifierGroupsError {
  """Error code from the mutation."""
  code: SetEmoteModifierGroupsErrorCode!
}

"""Possible error codes from this mutation."""
enum SetEmoteModifierGroupsErrorCode {
  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """The provided input is invalid."""
  INVALID_ARGUMENT

  """The user is not authorized to set emote modifiers."""
  USER_UNAUTHORIZED

  """Unknown error returned from service."""
  UNKNOWN
}

"""
SetEmoteModifierGroupsInput is the input required when a creator sets their emote modifiers.
"""
input SetEmoteModifierGroupsInput {
  """Emote modifier groups to set."""
  groups: [EmoteModifierGroupInput!]!
}

"""The result of setting emote modifier groups for a user."""
type SetEmoteModifierGroupsPayload {
  """Error from the mutation if it exists."""
  error: SetEmoteModifierGroupsError

  """The modified emote groups that were set."""
  groups: [EmoteModifierGroupPayload!]
}

"""
SetExtensionConfigurationError returns an error code for the frontend to handle.
"""
type SetExtensionConfigurationError {
  """The standardized code used by the frontend."""
  code: SetExtensionConfigurationErrorCode!
}

"""The standardized codes used by the frontend."""
enum SetExtensionConfigurationErrorCode {
  """User is unable to set the configuration."""
  UNAUTHORIZED

  """An unknown error occurred."""
  UNKNOWN
}

"""The required input for a setExtensionConfiguration mutation."""
input SetExtensionConfigurationInput {
  """The channel to which this configuration applies to."""
  channelID: ID!

  """The version of the configuration."""
  configVersion: String!

  """The configuration string to post."""
  content: String!

  """The extension ID."""
  extensionID: ID!
}

"""
SetExtensionConfiguration returns the Input as the extensions configuration endpoint returns a 204.
"""
type SetExtensionConfigurationPayload {
  """The channel to which this configuration applies to."""
  channelID: ID

  """The version of the configuration."""
  configVersion: String

  """The configuration string to post."""
  content: String

  """Error code for the frontend to handle."""
  error: SetExtensionConfigurationError

  """The extension ID."""
  extensionID: ID
}

"""
SetExtensionFeatureFlagsError is wrapper for error associated with the setExtensionFeatureFlags mutation.
"""
type SetExtensionFeatureFlagsError {
  """Error code."""
  code: SetExtensionFeatureFlagsErrorCode!

  """The missing installation id if got EXTENSION_NOT_INSTALLED error."""
  missingInstallationID: ID
}

"""
SetExtensionFeatureFlagsErrorCode is an error code associated with SetExtensionFeatureFlagsError.
"""
enum SetExtensionFeatureFlagsErrorCode {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Channel id is invalid, for example, is empty."""
  INVALID_CHANNEL_ID

  """The extension is not installed on the channel."""
  EXTENSION_NOT_INSTALLED
}

"""The required input to set feature flags for an installation."""
input SetExtensionFeatureFlagsInput {
  """Optional value to enable/disable chat for the specified installation."""
  canSendChat: Boolean

  """Optional value to enable/disable bits for the specified installation."""
  canUseBits: Boolean

  """Optional value for dynamicManagement flag on games."""
  dynamicManagement: [ExtensionDynamicManagementInput]

  """The ID of the extension installation to set feature flags for."""
  id: ID!
}

"""The result of setting feature flags on an installation."""
type SetExtensionFeatureFlagsPayload {
  """The error when the mutation fails to set feature flags."""
  error: SetExtensionFeatureFlagsError

  """
  The new state of the installation after the setExtensionFeatureFlags mutation.
  """
  installedExtension: ExtensionInstallation
}

"""The required input to set oauth on an installation."""
input SetExtensionInstallationOAuthInput {
  """The installation ID we're setting the oauth token for."""
  id: ID!

  """The OAuth token created for the extension."""
  oauthToken: String!
}

"""The resulting installedExtension state after setting OAuth."""
type SetExtensionInstallationOAuthPayload {
  """
  The new state of the installation after the setExtensionInstallationOAuth mutation.
  """
  installedExtension: ExtensionInstallation
}

"""
SetGameDropAccountLinkClientInput has fields necessary to update a game's account link
client ID used to verify a user has connected their in-game account.
"""
input SetGameDropAccountLinkClientInput {
  """
  The client ID used to verify that users have linked their accounts properly.
  """
  clientID: ID!

  """The ID of the game to link the client ID to."""
  gameID: ID!
}

"""SetGameDropAccountLinkClientPayload returns the result of the update."""
type SetGameDropAccountLinkClientPayload {
  """A mapped error returned by the drops management service."""
  error: DropsError

  """The updated game record."""
  game: Game
}

"""
SetHeroAsAvatarError contains details about an error that occured when copying the hero to an avatar.
"""
type SetHeroAsAvatarError {
  """The type of error that occured when copying the hero to the avatar."""
  code: SetHeroAsAvatarErrorCode!
}

"""
SetHeroAsAvatarErrorCode defines a client error that occured while copying the hero to an avatar.
"""
enum SetHeroAsAvatarErrorCode {
  """The requesting user did not have permission to update the avatar."""
  FORBIDDEN

  """Some other unexpected error occured."""
  UNKNOWN_ERROR
}

"""
SetHeroAsAvatarInput contains the parameters to copy the user's hero to their avatar.
no parameters are required, because this mutation copies the requesting user's hero to
the requesting user's avatar, but we're passing the heroID here
because of a bug in the way `make check` works.
"""
input SetHeroAsAvatarInput {
  """The ID of the hero to copy to its owning user's profile picture."""
  heroID: ID!
}

"""SetHeroAsAvatarPayload is the response after setting the avatar."""
type SetHeroAsAvatarPayload {
  """
  The error that occured.
  Null if the operation was successful.
  """
  error: SetHeroAsAvatarError

  """The user object post mutation - null if error."""
  user: User
}

"""The required input to set a role's moderator logs' access."""
input SetModLogsAccessInput {
  """The access level to moderator logs to be given to the role."""
  accessLevel: ModLogsAccessLevel!

  """The Channel for which to set moderator log access."""
  channelID: ID!

  """The user role for which to set the moderator log access permission."""
  channelRole: ChannelUserRole!
}

"""Result of a setModLogsAccess mutation."""
type SetModLogsAccessPayload {
  """The access level of the role set."""
  modLogsAccess: ModLogsAccess
}

"""
The required input to set a user's mod view settings relating to turorial.
"""
input SetModViewSettingsInput {
  """The time the tutorial on the mod view page was seen."""
  tutorialSeenAt: Time!

  """The viewed state of the tutorial on the mod view page."""
  tutorialState: TutorialState!
}

"""Result of a setModViewSettings mutation."""
type SetModViewSettingsPayload {
  """The newly resolved modviewsettings resolver."""
  modViewSettings: ModViewSettings
}

input SetNotificationSettingInput {
  category: String!
  platform: String!
  settingState: String!
}

type SetNotificationSettingPayload {
  settingState: String!
}

"""
SetOverwatchLeagueTeamPreferenceInput contains the OverwatchLeagueTeamPreference ID to set.
"""
input SetOverwatchLeagueTeamPreferenceInput {
  """The channelID from the channel this event is taking place on."""
  OverwatchTeamPreferenceOptionID: ID!
}

"""
SetOverwatchLeagueTeamPreferencePayload is the success response for setting an Overwatch League Team preference, and
the corresponding updated OverwatchLeagueTeamPreference struct.
"""
type SetOverwatchLeagueTeamPreferencePayload {
  """A possible error returned from the service."""
  error: SetOverwatchTeamPreferenceError

  """The updated OverwatchLeagueTeamPreference struct."""
  overwatchLeagueTeamPreference: OverwatchLeagueTeamPreference
}

"""Error code for an error that occurs while claiming the bounty."""
type SetOverwatchTeamPreferenceError {
  """Error code for error that occurred while claiming the bounty."""
  code: SetOverwatchTeamPreferenceErrorCode!
}

"""
Error types recognized by the SetOverwatchLeagueTeamPreference mutation.
"""
enum SetOverwatchTeamPreferenceErrorCode {
  """Unknown error being returned from service."""
  UNKNOWN
}

"""The required input for a setPreferredLanguageTag mutation."""
input SetPreferredLanguageTagInput {
  """The preferred language tag to set onto the user."""
  preferredLanguageTag: LanguageTag!

  """The user to modify."""
  userID: ID!
}

"""The result of a setPreferredLanguageTag mutation."""
type SetPreferredLanguageTagPayload {
  """The user whose preferred language tag was changed."""
  user: User
}

"""Error from a failed currently playing track mutation."""
type SetRadioCurrentlyPlayingError {
  """Mutation error code."""
  code: SetRadioCurrentlyPlayingErrorCode
}

"""Currently playing error codes."""
enum SetRadioCurrentlyPlayingErrorCode {
  """The ID provided was malformed."""
  INVALID_ID

  """Permission denied to add/update a currently playing item."""
  PERMISSION_DENIED

  """No record found for the request params."""
  NO_RECORD
}

"""
The required input to set radio track information currently being played.
"""
input SetRadioCurrentlyPlayingInput {
  """The type of content the ID maps to."""
  contentType: RadioCurrentlyPlayingType

  """Whether the track is currently playing or not."""
  isCurrentlyPlaying: Boolean!

  """The ID of the source."""
  sourceID: ID

  """The ID of the currently playing track."""
  trackID: ID
}

"""Result of a setRadioCurrentlyPlaying mutation."""
type SetRadioCurrentlyPlayingPayload {
  """The currently playing radio track addition result."""
  currentTrack: RadioCurrentTrackResponse

  """Error code."""
  error: SetRadioCurrentlyPlayingError
}

"""The required input to set a user's readable chat colors setting."""
input SetReadableChatColorsEnabledInput {
  """Whether readable chat colors should be enabled for the current user."""
  isReadableChatColorsEnabled: Boolean!
}

"""Result of a setReadableChatColorsEnabled mutation."""
type SetReadableChatColorsEnabledPayload {
  """Whether readable chat colors are enabled for the current user."""
  isReadableChatColorsEnabled: Boolean!
}

"""
SetResourceRestrictionInput sets a restriction for the given resourceID.
"""
input SetResourceRestrictionInput {
  """The ID of the resource to set the restriction on."""
  resourceID: ID!

  """The type of resource that will be restricted."""
  resourceType: RestrictionResource!

  """
  The restriction options, if any, to apply to the restriction being created.
  """
  restrictionOptions: [ResourceRestrictionOption!]

  """
  The type of restriction that should be placed onto the channel. If empty, the restriction will be deleted.
  """
  restrictionType: ResourceRestrictionType
}

"""
SetResourceRestrictionPayload returns the updated restriction for a channel.
"""
type SetResourceRestrictionPayload {
  """The channel if a live resource restriction was updated."""
  channel: Channel

  """The stream if a live resource restriction was updated."""
  stream: Stream

  """The video if a video resource restriction was updated."""
  video: Video
}

"""
An error that has been mapped from a Reminder service twirp error. Can sometimes include messages.
"""
type SetScheduleReminderError {
  """The error code."""
  code: SetScheduleReminderErrorCode!

  """The error message string."""
  message: String
}

"""Enum for set schedule reminders errors."""
enum SetScheduleReminderErrorCode {
  """The error code is unknown."""
  UNKNOWN

  """The request for setting a reminder was invalid."""
  INVALID_ARGUMENT

  """
  The schedule segment you're attempting to set a reminder for was not found.
  """
  NOT_FOUND

  """
  The schedule segment you're attempting to set a reminder for was cancelled.
  """
  FAILED_PRECONDITION
}

"""
SetScheduleReminderInput has fields required to set a schedule event reminder.
"""
input SetScheduleReminderInput {
  """The ID of the segment to set a reminder for."""
  segmentID: ID!

  """Whether the reminder should be enabled or disabled."""
  shouldEnable: Boolean!
}

"""SetScheduleReminderPayload returns the result of the creation/update."""
type SetScheduleReminderPayload {
  """A mapped error returned by the Reminder service."""
  error: SetScheduleReminderError

  """The new reminder state, if operation completed with no error."""
  isEnabled: Boolean
}

"""
SetSessionStatusInput represents a user's status within a single session (browser tab, game, desktop application,
mobile application, etc.).
"""
input SetSessionStatusInput {
  """
  activity is the action the user is performing in your application. The purpose of an activity is to allow the user's
  friends and related users to join in on whatever the user is doing. If the user is not performing any action that
  other users can join in on (e.g. watching a VOD, browsing their settings page) or is not performing any action at
  all, this should be set to null.
  """
  activity: ActivityInput

  """
  availability is the state of the user's session in your application. You should set it to ONLINE if the user is
  known to be at their device, IDLE if they are not, and OFFLINE if your application is currently terminating.
  
  Note that if your application fails to send an OFFLINE heartbeat before terminating, the session will automatically
  expire after some time without a heartbeat.
  """
  availability: AvailabilityInput!

  """
  sessionID must be supplied and can be any string unique to this session. Generating a random UUID when your
  application starts and sending it for each setSessionStatus is a good idea.
  
  Each instance of your application should send the same ID for each of its setSessionStatus calls, but two instances
  of your application running at the same time should never have the same session ID.
  """
  sessionID: String!
}

type SetSessionStatusPayload {
  """
  The number of seconds your application should wait before sending another setSessionStatus. If your application does
  not call setSessionStatus again within roughly this duration, it will be assumed to have terminated unexpectedly and
  its session status for this user will expire.
  """
  setAgainInSeconds: Int!

  """The modified user."""
  user: User
}

"""Inputs to the setSquadStreamPrimaryPlayer mutation."""
input SetSquadStreamPrimaryPlayerInput {
  """ID of the device viewing squad stream."""
  deviceID: ID!

  """ID of the channel as the current primary player."""
  primaryPlayerID: ID!

  """ID of the squad stream."""
  squadID: ID!
}

"""Outputs to the setSquadStreamPrimaryPlayer mutation."""
type SetSquadStreamPrimaryPlayerPayload {
  """The current primary player of the squad stream."""
  primaryPlayer: User
}

"""Error from set unban requests settings mutation."""
type SetUnbanRequestsSettingsError {
  """Error code from the set unban requests settings mutation."""
  code: SetUnbanRequestsSettingsErrorCode!
}

"""Error codes for from set unban requests settings mutation."""
enum SetUnbanRequestsSettingsErrorCode {
  """Unknown error."""
  UNKNOWN

  """User is not authorized to set unban request settings on the channel."""
  UNAUTHORIZED

  """User attempted to set with an invalid value."""
  INVALID_VALUE
}

"""Required input to set unban requests settings on a channel."""
input SetUnbanRequestsSettingsInput {
  """The channel on which to update settings for."""
  channelID: ID!

  """The amount of time after a ban before an unban request can be made."""
  cooldownMinutes: Int!

  """Whether unban requests are allowed to be created on the channel."""
  isEnabled: Boolean!
}

"""Result of setting a channel's unban requests settings."""
type SetUnbanRequestsSettingsPayload {
  """Error from attempting to set unban requests settings."""
  error: SetUnbanRequestsSettingsError

  """The updated settings on the channel."""
  settings: UnbanRequestsSettings
}

"""SetUserResidenceInput is input required to set a user's residence."""
input SetUserResidenceInput {
  """User's country in ISO alpha-2."""
  countryCode: String!

  """Target user for setting residence."""
  userID: ID!

  """User's zip code."""
  zipCode: String
}

"""
SetUserResidencePayload is the response from the SetUserResidence mutation.
"""
type SetUserResidencePayload {
  """User whose residence was set for."""
  user: User
}

type Share {
  """The user that created this share."""
  author: User

  """Time the share was created by the user."""
  createdAt: Time

  """Share ID."""
  id: ID!

  """The item that was shared."""
  target: ShareTarget
}

union ShareTarget = Clip | Post | Stream | Video

"""An ordered list of content to render with metadata on the content."""
type Shelf {
  """The ordered content for the shelf."""
  content: ShelfContentConnection!

  """How to present the content in the shelf."""
  displayType: String!

  """A unique identifier for the shelf for use in tracking and pagination."""
  id: ID!

  """The title for the shelf."""
  title: ShelfTitle!

  """Information used for recommendation tracking."""
  trackingInfo: TrackingInfo!
}

"""
Paginated list of Shelves. (pagination not yet implemented)
Implements the Relay cursor connections specification.
See: https://facebook.github.io/relay/graphql/connections.htm.
"""
type ShelfConnection {
  """The list of shelves to display."""
  edges: [ShelfEdge!]

  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  pageInfo: PageInfo!
}

"""The content to render in a shelf."""
union ShelfContent = Clip | Game | Stream | Tag | Video

"""The list of content to render in a shelf."""
type ShelfContentConnection {
  """The list of content to display."""
  edges: [ShelfContentEdge!]

  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  pageInfo: PageInfo!
}

"""The content to render in a shelf."""
type ShelfContentEdge {
  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  cursor: Cursor!

  """The metadata to show for each content edge."""
  metadata: ShelfContentMetadata

  """The underlying content to render."""
  node: ShelfContent

  """Used to associate promotions for tracking."""
  promotionsCampaignID: ID!

  """Used to determine what the source of the shelf content is from."""
  sourceType: SourceType!

  """Used in client tracking."""
  trackingID: ID!
}

"""The metadata for content to render in a shelf."""
type ShelfContentMetadata {
  """Whether the content has a live event."""
  hasLive: Boolean!

  """The localized subtitle for a content item in a shelf."""
  subtitle: ShelfTitle

  """The localized title for a content item in a shelf."""
  title: ShelfTitle!
}

"""
Contains information about a Shelf's relationship to a given page (connection),
and the Shelf itself.
"""
type ShelfEdge {
  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  cursor: Cursor!

  """The shelf."""
  node: Shelf!
}

"""The title for the shelf."""
type ShelfTitle {
  """A resource to interpolate into the title string."""
  context: ShelfTitleContext

  """
  The fallback localized title, only to be used if client fails to parse the localizedTitleTokens.
  """
  fallbackLocalizedTitle: String!

  """
  The name of the shelf being presented, used for backwards compatibility. Allows for localization and interpolation.
  """
  key: String!

  """The localized shelf title in the form of a list of tokens."""
  localizedTitleTokens: [TitleTokenEdge]!
}

"""Metadata used to render the shelf title."""
union ShelfTitleContext = Game

"""
A set of options for configuring which shelf data to return to the user.
"""
input ShelvesAvailableOptions {
  """
  The ID of the collection. Only valid when shelfType is set to
  VideoShelfType.COLLECTION.
  """
  collectionID: ID

  """
  The ID of the game shelf to query. Only valid when shelfType is set to
  VideoShelfType.GAME_VIDEOS.
  """
  gameID: ID

  """
  Which shelf type to query. Currently required.
  In future, omitting this option returns all valid shelves.
  """
  shelfType: VideoShelfType
}

"""
A set of options to configuring how the shelves data is returned to the consumer.
"""
input ShelvesOptions {
  """Should indicate whether the response includes empty shelves."""
  includeEmpty: Boolean = false
}

"""A short video from a ShortVideoFeed and its relevant metadata."""
type ShortVideo {
  """The actual short form video content to display."""
  content: ShortVideoContent

  """The ID of the short form video."""
  id: ID!

  """All of the reactions on this short form video."""
  reactions: [ShortVideoReaction!]!
}

"""All of the different content types that make up "short form video"."""
union ShortVideoContent = Clip

"""A paginated list of short videos."""
type ShortVideoFeedConnection {
  """
  The list edges contain ShortVideoFeedEdges with pagination information.
  """
  edges: [ShortVideoFeedEdge!]!

  """Information about pagination in this connection."""
  pageInfo: PageInfo!
}

"""An element in a paginated list of short videos."""
type ShortVideoFeedEdge {
  """Uniquely identifies this item's position in a connection."""
  cursor: Cursor!

  """The short video."""
  node: ShortVideo
}

"""
Options used to determine the content returned in the short video feed.
"""
input ShortVideoFeedOptions {
  """The platform of the viewer -- used to curate content in the feed."""
  platform: ShortVideoFeedPlatform

  """The type of short video feed to return."""
  type: ShortVideoFeedType
}

"""The platform from which the short video feed is requested."""
enum ShortVideoFeedPlatform {
  """The mobile web site."""
  MOBILE_WEB

  """The iOS app."""
  IOS

  """The Android app."""
  ANDROID
}

"""The type of short form video feed."""
enum ShortVideoFeedType {
  """Return a video feed based off the channels the user is following."""
  FOLLOWING

  """Return a video feed based off an recommendations model."""
  RECOMMENDED
}

"""
An aggregated counter for the contained emote to display how many reactions to a ShortVideo there have been.
"""
type ShortVideoReaction {
  """The number of times this emote has been used to react to this video."""
  count: Int!

  """The emote that was used to react."""
  emote: Emote

  """The ID is the same as emote.ID."""
  id: ID!
}

"""The type representing Community Points Smart Costs Acknowledgements."""
type SmartCostsAcknowledgement {
  """The last acknowledged cost."""
  lastAcknowledgedCost: Int!

  """The type of automatic reward the smart costs acknowledgement is for."""
  rewardType: CommunityPointsAutomaticRewardType!
}

"""The input representing Community Points Smart Costs Acknowledgements."""
input SmartCostsAcknowledgementInput {
  """The last acknowledged cost."""
  lastAcknowledgedCost: Int!

  """The type of automatic reward the smart costs acknowledgement is for."""
  rewardType: CommunityPointsAutomaticRewardType!
}

"""Wrapper around the standard emoticon groups for Prime Emoticons."""
type SmiliesSet {
  """The list of emotes which belong to this set."""
  emotes: [Emote!]

  """ID for the current smilies set."""
  id: ID
}

"""A social media item that is an attribute of Channel."""
type SocialMedia {
  """The social media's unique identifier."""
  id: ID!

  """
  The name of the domain which will be used to determine which favicon to render.
  """
  name: String

  """The label displayed to the client."""
  title: String!

  """The web address to a social media website."""
  url: String!
}

type SocialStream implements RecommendedStream {
  """The friend who generated the recommendation."""
  friend: User

  """The recommended stream."""
  stream: Stream

  """
  The type of recommendation. Different types contain different metadata about why the recommendation was made.
  """
  type: StreamRecommendationType
}

"""Sort direction."""
enum SortOrder {
  """Ascending (A-Z, 1-9)."""
  ASC

  """Descending (Z-A, 9-1)."""
  DESC
}

"""The type of source the shelf content is coming from."""
enum SourceType {
  """The target source is from promotional campaign that is free."""
  PROMOTION

  """The target source is from recommendations."""
  RECOMMENDED

  """The target source is from a promotional campaign that is paid."""
  SPONSORED

  """The target source is from a fallback candidate."""
  POPULAR

  """The target source is from a boost promotional campaign."""
  COMMUNITY_BOOST

  """The target source is unknown so we default to UNKNOWN."""
  UNKNOWN_SOURCE_TYPE
}

"""Error returned when attempting to spend subscription credit."""
type SpendSubscriptionCreditError {
  """
  Error code for error that occured while attempting to spend subscription credit.
  """
  code: SpendSubscriptionCreditErrorCode!
}

"""
Possible error codes returned when attempting to spend subscription credit.
"""
enum SpendSubscriptionCreditErrorCode {
  """
  Occurs if a Twitch Prime user attempts to spend subscription credit that is (still) unavailable.
  """
  UNABLE_TO_SPEND

  """
  Occurs if a Twitch Prime user attempts to spend multiple times, acting as a flag for fraud.
  """
  TOO_MANY_RECENT_SPENDS
}

"""Input requires the broadcaster to be payed and user to deduct credit."""
input SpendSubscriptionCreditInput {
  """The user id of streamer being subscribed to."""
  broadcasterID: String!

  """Twitch user ID."""
  userID: ID!
}

"""Mutated data after spending the subscription credit."""
type SpendSubscriptionCreditPayload {
  """Possible error returned from the service."""
  error: SpendSubscriptionCreditError

  """The modified subscription benefit data."""
  subscriptionBenefit: SubscriptionBenefit

  """Twitch user ID."""
  userID: ID!
}

"""The connection of sponsored cheermote channel settings to user."""
type SponsoredCheermoteChannelSettingsConnection {
  """The list of key pool edges associated with the user."""
  edges: [SponsoredCheermoteChannelSettingsEdge!]!

  """
  The metadata about having more key pools to fetch, or if there is a previous page of key pools.
  """
  pageInfo: PageInfo!

  """The total number of key pools for the given user."""
  totalCount: Int!
}

"""
The sponsored cheermote channel settings edge which contains our cursor and node.
"""
type SponsoredCheermoteChannelSettingsEdge {
  """The cursor of the edge, which is also the key pool ID."""
  cursor: Cursor!

  """
  The node of the edge, which contains all information about the key pool.
  """
  node: SponsoredCheermoteChannelSettingsNode
}

"""
The information associated with a given sponsored cheermote channel setting.
"""
type SponsoredCheermoteChannelSettingsNode {
  """Brand's image to display, in the form of a URL."""
  brandImageURL: String!

  """Brand name to display."""
  brandName: String!

  """Time the campaign ends."""
  endTime: Time!

  """The campaign ID, which is unique."""
  id: ID!

  """The opt in status of the campaign."""
  isOptedIn: Boolean!

  """Time the campaign starts."""
  startTime: Time!

  """Thresholds for matching on sponsored cheering."""
  thresholds: [CheermoteCampaignThreshold!]!
}

"""
A squad stream represents a group of broadcasters that are streaming together.  When a squad
stream is live, viewers can opt to watch the streams of all its members together from a
single view.

Squad streams are created by a broadcaster who invites other broadcasters to participate.
Each broadcaster who accepts an invitation becomes a member of the squad stream and can also
invite other broadcasters to participate.  At the moment, a squad stream can have up to
four members and a broadcaster can only belong to a single squad stream.

A squad stream ends when all its members leave or stop streaming.
"""
type SquadStream {
  """The ID of the squad stream."""
  id: ID!

  """
  The invitations with the given status that have been sent by members to other users to join to squad stream.
  """
  invitations(status: SquadStreamInvitationStatus!): [SquadStreamInvitation!]

  """Broadcasters who are currently participating in the squad stream."""
  members: [User!]

  """The owner can remove members from the squad stream."""
  owner: User

  """The current status of the squad stream."""
  status: SquadStreamStatus!
}

"""Determines who can send the user invitations to join a squad stream."""
enum SquadStreamIncomingInvitePolicy {
  """This user should never receive invitations."""
  NONE

  """
  This user can receive invitations from friends, teammates and followed channels.
  """
  NETWORK

  """This user can receive invitations from anyone."""
  ALL
}

"""
SquadStreamInvitation represents an invitation sent by a member of a squad stream to another user to
join the squad stream.
"""
type SquadStreamInvitation {
  """When the invitation was created."""
  createdAt: Time!

  """ID of the invitation."""
  id: ID!

  """
  Network type of the invitation. This field is only non nil when the invitation
  is fetched for User.IncomingSquadStreamInvitations.
  """
  networkType: SquadStreamInvitationNetworkType

  """If the invitation's status is rejected, the reason for the rejection."""
  reasonRejected: SquadStreamInvitationRejectedReason

  """The user that the invitation is sent to."""
  recipient: User

  """The user that sent the invitation."""
  sender: User

  """The squad stream that the recipient is invited to join."""
  squadStream: SquadStream

  """The status of the invitation."""
  status: SquadStreamInvitationStatus!
}

"""List of Squad Stream invitations."""
type SquadStreamInvitationConnection {
  """The elements of the list."""
  nodes: [SquadStreamInvitation!]

  """The total count of invitations."""
  totalCount: Int
}

"""Describes the network type of a squad stream invitation."""
enum SquadStreamInvitationNetworkType {
  """
  The invitation is from within the recipient's network (friends, teammates and followed channels).
  """
  IN_NETWORK

  """The invitation is from outside of the recipient's network."""
  OUT_OF_NETWORK
}

"""Describes the reason a squad stream invitation was rejected."""
enum SquadStreamInvitationRejectedReason {
  """The recipient rejected the invitation."""
  RECIPIENT_REJECTED

  """
  The recipient cannot access the squad stream product (e.g. due to missing transcode, partner-only launch).
  """
  RECIPIENT_CANNOT_ACCESS_SQUAD_STREAM

  """
  The recipient does not allow the sender of the invitation to invite them (e.g. due to their squad stream settings).
  """
  RECIPIENT_CANNOT_BE_INVITED
}

"""Describes the current state of a squad stream invitation."""
enum SquadStreamInvitationStatus {
  """The recipient has accepted the invitation."""
  ACCEPTED

  """A squad stream owner has deleted the invitation."""
  DELETED

  """
  The invitation has been sent to the recipient and the sender is waiting for a response.
  """
  PENDING

  """The recipient has rejected the invitation."""
  REJECTED

  """The invitation has an unknown status."""
  UNKNOWN
}

"""A user's squad stream settings."""
type SquadStreamSettings {
  """
  Denotes whether or not a user can access squad management features like
  accepting/receiving invites and viewing the Squad Stream dashboard widget.
  """
  canAccessSquads: Boolean!

  """
  Determines who can send the user invitations to join a squad stream.
  Resolves for anyone who can access the user's dashboard (editors, staff, etc.).
  """
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy
}

"""Describes the status of a squad stream."""
enum SquadStreamStatus {
  """The squad stream is live and is being broadcast to viewers."""
  LIVE

  """The squad stream is being set up, and should not be shown to viewers."""
  PENDING

  """The squad stream has ended."""
  ENDED

  """The squad stream has an unknown status."""
  UNKNOWN
}

"""
A link between a single sign-on (SSO) app and a Twitch account.
SSO apps are the Twitch apps on console and smart TV.
"""
type SSOLink {
  """
  The name of the SSO app that is linked to the authenticated user's Twitch account.
  """
  app: String

  """
  The identifier of the device or user account on XboxLive, PSN, etc.
  that is linked to the authenticated user's Twitch account.
  """
  ssoID: String
}

"""StartAdError ..."""
type StartAdError {
  """
  code is the code for the error that occurs while trying to run an ad break.
  """
  code: StartAdErrorCode!

  """
  retryAfterSeconds is the amount of time in seconds remaining before user can run another ad.
  """
  retryAfterSeconds: Int
}

"""StartAdErrorCode ..."""
enum StartAdErrorCode {
  """
  The user has requested an ad break before the rate limit timer has expired.
  """
  RATE_LIMITED

  """
  The user is not authorized to run an ad break on the requested channel.
  """
  USER_NOT_AUTHORIZED

  """An unknown error occured while trying to run an ad break."""
  UNKNOWN_ERROR
}

"""StartAdInput ..."""
input StartAdInput {
  """channelID is the ID of the channel the ad will run on."""
  channelID: ID!

  """
  lengthSeconds is the requested ad break length in seconds (30s ad, 60s ad, etc).
  """
  lengthSeconds: Int
}

"""StartAdPayload ..."""
type StartAdPayload {
  """adSession is the response object from an ad request."""
  adSession: AdSession

  """error is the StartAdError object from a failed request."""
  error: StartAdError
}

"""Error code for an error that occurs while starting the bounty."""
type StartBountyError {
  """Error code for error that occurred while starting the bounty."""
  code: StartBountyErrorCode!
}

"""Error types recognized."""
enum StartBountyErrorCode {
  """Invalid parameter in the request."""
  INVALID_PARAMETER

  """The bounty cannot be started because it is not live."""
  BOUNTY_NOT_LIVE

  """The stream title contains banned words."""
  STREAM_TITLE_BANNED_WORDS

  """The stream title is too long."""
  STREAM_TITLE_TOO_LONG

  """The user is not authorized to start the bounty."""
  UNAUTHORIZED

  """Unknown error being returned from service."""
  UNKNOWN_ERROR
}

"""StartBountyInput includes the bounty a user is trying to start."""
input StartBountyInput {
  """Unique Identifier for the bounty."""
  bountyID: ID!

  """Title of the stream for the bounty. Must start with #sponsored."""
  title: String!

  """UserID of the user that will start the bounty."""
  userID: ID!
}

"""Data that was mutated after starting the bounty."""
type StartBountyPayload {
  """The possible error returned from the service."""
  error: StartBountyError

  """The started bounty with the updated status."""
  startedBounty: Bounty

  """The user that now has the started bounty."""
  user: User
}

"""Error associated with a failed attempt to start a cloud broadcast."""
type StartCloudBroadcastError {
  """The cause of the error."""
  cause: StartCloudBroadcastErrorCause!

  """An optional error message associated with the error."""
  message: String
}

"""Errors returned by attempting to start a cloud broadcast."""
enum StartCloudBroadcastErrorCause {
  """No subscription was found for the given channel and provider."""
  NO_SUBSCRIPTION

  """An unknown error occurred, use message for more information."""
  UNKNOWN
}

"""
Input for remotely and asynchronously starting a cloud broadcast for the given channelID.
"""
input StartCloudBroadcastInput {
  """The desired framerate of the broadcast."""
  framerate: Int

  """The desired height of the broadcast."""
  height: Int

  """The cloud provider to send a start cloud broadcast request to.."""
  providerID: ID!

  """The desired width of the broadcast."""
  width: Int
}

"""Response to start a cloud broadcast."""
type StartCloudBroadcastPayload {
  """
  If the broadcast was successfully started, properties of that broadcast.
  """
  broadcast: CloudBroadcast

  """An optional error if the mutation failed, contaning actionable errors."""
  error: StartCloudBroadcastError
}

"""
StartPayoutOnboardingWorkflowInput returns the required input when starting a new workflow for payout onboarding.
"""
input StartPayoutOnboardingWorkflowInput {
  """TargetUserID is the ID of the user whose workflow will be started."""
  targetUserID: ID!
}

"""
StartPayoutOnboardingWorkflowPayload returns a new workflow when starting payout onboarding.
"""
type StartPayoutOnboardingWorkflowPayload {
  """A new workflow status."""
  workflow: PayoutOnboardingWorkflow
}

"""Input for starting a PV Watch Party."""
input StartWatchPartyInput {
  """Amazon LWA access token."""
  accessToken: String!

  """Channel ID of the creator."""
  channelID: ID!

  """Catalog GTI to use."""
  watchPartyItemID: ID!
}

"""Returns the new Watch Party and all decoration/details."""
type StartWatchPartyPayload {
  """Error if the user's token expired."""
  error: WatchPartyError

  """The watch party that was started."""
  watchParty: WatchParty
}

"""Error code for an error that occurs while stopping the bounty."""
type StopBountyError {
  """Error code for error that occurred while stopping the bounty."""
  code: StopBountyErrorCode!
}

"""Error types recognized."""
enum StopBountyErrorCode {
  """Invalid parameter in the request."""
  INVALID_PARAMETER

  """The user is not authorized to stop the bounty."""
  UNAUTHORIZED

  """Unknown error being returned from service."""
  UNKNOWN_ERROR
}

"""StopBountyInput includes the bounty a user is trying to stop."""
input StopBountyInput {
  """Unique Identifier for the bounty."""
  bountyID: ID!

  """UserID of the user that will stop the bounty."""
  userID: ID!
}

"""Data that was mutated after stopping the bounty."""
type StopBountyPayload {
  """The possible error returned from the service."""
  error: StopBountyError

  """The stopped bounty with the updated status."""
  stoppedBounty: Bounty

  """The user that now has the stopped bounty."""
  user: User
}

"""An error associated with a failed call to stopCloudBroadcast."""
type StopCloudBroadcastError {
  """The cause of the error."""
  cause: StopCloudBroadcastErrorCause!

  """Optional message associated with an error."""
  message: String
}

"""Errors returned by attempting to stop a cloud broadcast."""
enum StopCloudBroadcastErrorCause {
  """
  No broadcast was found for the given channel and provider.
  Either because the broadcast is stopped or because the provider did not know about the user.
  """
  BROADCAST_NOT_FOUND

  """An unknown error message occurred, see message for more information."""
  UNKNOWN
}

"""Input for remotely stoping a Cloud broadcast for the given channelID."""
input StopCloudBroadcastInput {
  """The the broadcast id to use when stopping a broadcast."""
  id: ID!
}

"""Response to stop a Cloud broadcast."""
type StopCloudBroadcastPayload {
  """
  If the broadcast was successfully stopped, properties of that broadcast.
  """
  broadcast: CloudBroadcast

  """
  Optional error associated with a failed attempt to stop a cloud broadcast.
  """
  error: StopCloudBroadcastError
}

"""Input for stopping a PV Watch Party."""
input StopWatchPartyInput {
  """Amazon LWA access token."""
  accessToken: String!

  """Channel ID of the creator."""
  channelID: ID!
}

"""Returns LWA authentication errors."""
type StopWatchPartyPayload {
  """Error if the user's token expired."""
  error: WatchPartyError

  """The watch party that was stopped."""
  watchParty: WatchParty
}

"""A live stream."""
type Stream {
  """The associated archive of the stream."""
  archiveVideo: Video
  averageFPS: Float
  bitrate: Float

  """The language the stream is being broadcasted in."""
  broadcastLanguage: Language

  """The user who is broadcasting the live stream."""
  broadcaster: User

  """Software being used for the broadcast."""
  broadcasterSoftware: String

  """channel is deprecated."""
  channel: Channel @deprecated(reason: "Channel fields have been merged into User. Use stream.broadcaster instead.")

  """Number of clips created since stream start."""
  clipCount: Int
  codec: String

  """The time streaming started."""
  createdAt: Time

  """The stream delay in seconds."""
  delayLengthSeconds: Int @deprecated(reason: "Not a supported feature anymore.")

  """Information about what directories the stream is categorized in."""
  directories: [Directory]! @deprecated(reason: "This was made for Communities, but the feature is officially dead. Use 'game' instead")

  """Information about the game being streamed."""
  game: Game

  """The height of the stream's video, in pixels."""
  height: Int

  """The stream's unique identifier."""
  id: ID!

  """Whether the stream is hidden from its directory."""
  isDirectoryHidden: Boolean

  """Information about whether the channel is encrypted."""
  isEncrypted: Boolean

  """
  Whether the broadcaster has indicated the stream is intended for mature audiences only.
  """
  isMature: Boolean @deprecated(reason: "Use broadcaster.broadcastSettings.isMature instead")

  """Whether the broadcaster is partnered with Twitch."""
  isPartner: Boolean

  """
  Whether or not viewers of this stream can receive drops.
  Note: Actually earning drops additionally requires that the game have an
  active drops campaign and is done at the discretion of the developer.
  """
  isStreamDropsEnabled: Boolean

  """The lanugage setting of the streaming user."""
  language: Language

  """When the stream was last updated."""
  lastUpdatedAt: Time

  """The maximum height of the stream's video, in pixels."""
  maxHeight: Int @deprecated(reason: "Not a supported feature anymore")

  """Platform-specific (e.g. Xbox, PlayStation) metadata."""
  platform: Platform

  """
  The playback access token that determines whether the user can watch the stream.
  Fetched for both authed and unauthed users.
  """
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken

  """
  A URL to a dynamically sized image.
  If either `height` or `width` are not given, a templated value will be present instead.
  """
  previewImageURL(height: Int, width: Int): String

  """
  The restriction that is currently active on the channel for restricting a user's access to it.
  """
  restriction: ResourceRestriction @deprecated(reason: "Use Channel.restriction for full restriction data or Stream.restrictionType for stream's restriction type")

  """
  The list of restriction options that were applied in addition to the restriction type for this stream.
  """
  restrictionOptions: [ResourceRestrictionOption!]!

  """The type of restriction this stream currently has."""
  restrictionType: String

  """
  self contains information on the relationship between the current user (anonymous or authenticated) and this stream.
  """
  self: StreamSelfConnection

  """
  Tags are used as a discovery and search mechanism for tags and tagged content.
  The tag data may not be updated immediately after streamers update their tags.
  Please use User.tags instead if you want real time data from Graffiti.
  For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
  """
  tags: [Tag!]

  """A user-defined title describing the stream."""
  title: String @deprecated(reason: "Title field in Users has been deprecated. Use broadcaster.broadcastSettings.title instead")

  """What type of stream this is (e.g. live, playlist, watch_party)."""
  type: String

  """The number of viewers currently watching the stream."""
  viewersCount: Int

  """The width of the stream's video, in pixels."""
  width: Int
}

"""StreamBitrate represents the bitrate of stream session by time."""
type StreamBitrate {
  """Time of recorded bitrate."""
  recordedAt: Time!

  """Bitrate of video stream in Kbps."""
  valueKbps: Float!
}

"""Paginated list of Streams."""
type StreamConnection {
  edges: [StreamEdge]

  """Used for tracking."""
  generationID: ID
  pageInfo: PageInfo

  """Used for tracking."""
  responseID: ID
}

"""
Contains information about a Streams's relationship to a given page (connection),
and the Stream itself.
"""
type StreamEdge {
  cursor: Cursor
  node: Stream

  """
  Unique id per stream response item, used by clients to attribute displays/clicks to items.
  """
  trackingID: ID
}

"""The type of streamer shelf to display."""
enum StreamerShelfType {
  """Shows the streamer's autohost list."""
  AUTOHOST

  """Shows the streamer's team members."""
  TEAM

  """Disables the shelf."""
  DISABLED
}

"""StreamFramerate represents the framerate of strem session by time."""
type StreamFramerate {
  """Time of recorded bitrate."""
  recordedAt: Time!

  """Framerate of video stream in Frame Per Second."""
  valueFPS: Float!
}

type Streaming implements Activity {
  """The stream being broadcasted."""
  stream: Stream

  """This activity's type, i.e. "STREAMING"."""
  type: ActivityType
}

"""StreamKey represents a RTMP stream key with its expiration date."""
type StreamKey {
  """Stream key expiration date."""
  expiresAt: Time

  """RTMP stream key value."""
  value: String!
}

"""
StreamKeyError represents the error code and its translated error message
response that explains why the broadcaster can't start a stream.
"""
type StreamKeyError {
  """
  code is the error code for why the broadcaster is not allow to broadcast.
  """
  code: String!

  """Link is the url link that is associated from the translated message."""
  links: [String!]!

  """
  message is the translated message for why the broadcaster is not allow to broadcast.
  """
  message: String!
}

"""StreamKeyResult represents StreamKey or StreamKeyError."""
union StreamKeyResult = StreamKey | StreamKeyError

"""Mosaic layouts for Dashboard Stream Manager."""
type StreamManagerMosaicLayout implements ChannelDashboardLayout {
  """The actual Mosaic layout data to be stored or fetched."""
  data: MosaicData!

  """A unique identifier to uniquely reference this layout."""
  id: ID!

  """The display name for the layout shown to the user."""
  name: String!

  """
  A version to identify how the MosaicData was generated,
  such as for deprecation purposes.
  """
  version: String!

  """When the layout was last updated"""
  lastUpdated: Time
}

"""
Query to let consumers filter streams that have specific metadata.
e.g. return only those hearthstone streams that have broadcasterheroclass as mage.
FE uses these parameters to implemtent filters.
"""
input StreamMetadataFilterInput {
  """Filter streams by CSGO Map."""
  counterStrikeMap: String

  """Filter streams by CSGO skill."""
  counterStrikeSkill: String

  """Filter streams by Hearthstone hero class e.g "Mage"."""
  hearthstoneBroadcasterHeroClass: String

  """Filter streams by Hearthstone hero name e.g "Jaina"."""
  hearthstoneBroadcasterHeroName: String

  """Filter streams by Hearthstone game mode e.g "arena" or "rank" etc."""
  hearthstoneGameMode: String

  """Filter streams by League Of Legends champion id."""
  leagueOfLegendsChampionID: String

  """The maximum AVC level of the stream. e.g "4.1"."""
  maxAVCLevel: String

  """The maximum AVC profile of the stream."""
  maxAVCProfile: AVCProfile

  """The maximum height of the stream."""
  maxHeight: Int

  """Filter streams by Overwatch broadcaster's character e.g "Widowmaker"."""
  overwatchBroadcasterCharacter: String

  """Filter streams by PUBG game mode."""
  pubgGameMode: String

  """Filter streams by PUBG max number of players alive in game."""
  pubgPlayerAliveMax: String

  """Filter streams by PUBG min number of players alive in game."""
  pubgPlayerAliveMin: String
}

"""
Optional inputs to filter streams
add additional optional fields for filtering streams to the StreamOptions input type.
"""
input StreamOptions {
  """Filter streams based on restriction types."""
  includeRestricted: [StreamRestrictionType!]

  """
  Broadcaster languages to filter the streams by.
  Deprecated: use language tags instead.
  """
  languages: [Language!]

  """The locale of the user."""
  locale: String

  """The platform to filter streams by."""
  platformType: PlatformType = all

  """
  If sorted by relevance, this provides additional context used to influence recommendations.
  """
  recommendationsContext: RecommendationsContext

  """
  A GUID that is created by the caller for tracking. This should be globally
  unique per request and is required if sort=RELEVANCE.
  """
  requestID: ID

  """The sort param can be used to change the default sorting."""
  sort: StreamSort = VIEWER_COUNT

  """List of tags to filter by."""
  tags: [String!]
}

"""The content to render in a live recommendation item."""
type StreamRecommendationEdge {
  """
  As pagination is currently not supported by the backend, this will always be the zero value.
  """
  cursor: Cursor!

  """The underlying stream content to render."""
  node: Stream

  """Unique id per stream used in client tracking."""
  trackingID: ID!
}

"""
StreamRecommendationsFilters defines parameters which filter down stream recommendation results.
"""
input StreamRecommendationsFilters {
  """
  Stream recommendation results will only include streams with these category ids.
  Clients can use this filtering option for flows where a user can select categories to filter on.
  The category IDs should be available from queries in the previous step of the user flow.
  Example: categoryIDs: ["513143", "33214"] where "513143" and "33214" are
  coming from categories selected by the user in the previous page.
  """
  categoryIDs: [ID!]
}

enum StreamRecommendationType {
  """A SocialStream."""
  SOCIAL
}

"""
Type of restricted stream. Currently used as inputs for user.followedLiveUsers, StreamOptions, and GameStreamOptions.
"""
enum StreamRestrictionType {
  """Represents streams that are restricted by OWL all-access pass."""
  OWL_ALL_ACCESS_PASS

  """Represents streams that are restricted to sub-only."""
  SUB_ONLY_LIVE
}

"""The relationship between the authenticated user and a stream."""
type StreamSelfConnection {
  """
  Whether or not the requesting user is authorized to view the channel's stream.
  """
  canWatch: Boolean!

  """Whether the stream is restricted."""
  isRestricted: Boolean!

  """
  If the stream is restricted, the type indicates how the stream is restricted.
  """
  restrictionType: String
}

"""The start and end time of a stream session for a user."""
type StreamSession {
  """The associated archive of the stream."""
  archiveVideo: Video

  """The end time for the stream session."""
  endedAt: Time!

  """The start time for the stream session."""
  startedAt: Time!
}

"""Possible ways of sorting collections of live streams."""
enum StreamSort {
  """
  Sort streams by number of concurrent viewers, descending (most viewers first).
  This is the default if StreamSort is not set or is a deprecated field.
  """
  VIEWER_COUNT

  """
  Sort streams by number of concurrent viewers, ascending (least viewers first).
  """
  VIEWER_COUNT_ASC

  """Sort by stream creation time, most recently started streams first."""
  RECENT

  """Sort by relevance to the current user."""
  RELEVANCE

  """
  Sort streams for the game "Counter-Strike: Global Offensive" by skill, descending (highest skill first).
  Other streams are included last, sorted at random.
  Deprecated: this sort option no longer exists.
  """
  CSGO_SKILL

  """
  Sort streams for the game "League of Legends" by summoner rank, descending (highest rank first).
  Other streams are included last, sorted at random.
  Deprecated: this sort option no longer exists.
  """
  LOL_SUMMONER_RANK
}

"""Analytics information for a streaming session."""
type StreamSummary {
  """The associated archives of the stream."""
  archiveVideos: [Video!]

  """Average viewers for the time period."""
  averageViewers: Float!

  """The ID for the streaming channel."""
  channelID: ID!

  """Unique chatters for the time period."""
  chatters: Int!

  """The number of clips created during the stream summary."""
  clipsCreated: Int!

  """The time that the stream session ended."""
  endedAt: Time!

  """Number of follows for the time period."""
  follows: Int!

  """Notification information for a given stream session."""
  goLiveNotification: GoLiveNotification

  """Live views for the time period."""
  liveViews: Int!

  """Max viewers for the time period."""
  maxViewers: Int!

  """New subscriptions for the time period."""
  newSubscriptions: Int!

  """The time that the stream session started."""
  startedAt: Time!

  """Unique chatters for the time period."""
  uniqueChatters: Int! @deprecated(reason: "Use chatters instead")

  """Unique viewers for the time period."""
  uniqueViewers: Int!
}

"""
A stucco (wide emote) represents an image that can be used for user interaction in specific cases.
"""
type Stucco {
  """
  The description is used to describe the stucco (e.g. for screenreaders).
  """
  description: String!

  """The unique ID of this stucco."""
  id: ID!

  """
  The set of URLS to images related to this stucco, contains URLS for 1x, 2x and 4x images.
  """
  imageSet: StuccoImageSet!

  """
  Indicates if this stucco does not belong to a single channel (available to all channels).
  """
  isGlobal: Boolean!

  """
  The owner of this stucco, usually the channel this has been uploaded to.
  """
  ownerID: ID!

  """The state of the stucco."""
  state: StuccoState!

  """
  The textCode used to represent and identify this stucco, consists of channel prefix + stucco prefix + code.
  """
  textCode: String!
}

"""Image set of different sizes of the stucco."""
type StuccoImageSet {
  """Image url of the 92x28px stucco ("1x") image asset."""
  image1xURL: String!

  """Image url of the 182x56px stucco ("2x") image asset."""
  image2xURL: String!

  """Image url of the 368x112px stucco ("4x") image asset."""
  image4xURL: String!
}

"""
A Stucco pack is a collection of stuccos, the pack can be activated to be used by viewers of that channel.
"""
type StuccoPack {
  """The ID of the stucco pack."""
  id: ID!

  """User id of the owner of this pack (usually a channel)."""
  ownerID: ID!

  """
  The stuccos contained in this pack, represented as slots, containing the slot index and the stucco.
  """
  slots: [StuccoPackSlot!]
}

"""
A stucco pack slot represents a single ordered slot in a pack of stuccos.
"""
type StuccoPackSlot {
  """The index of this slot (used for ordering)."""
  index: Int!

  """The stucco in this slot."""
  stucco: Stucco!
}

"""The state a stucco can be in."""
enum StuccoState {
  """- Active: part of a stucco pack."""
  ACTIVE

  """- Inactive: available in the library."""
  INACTIVE

  """
  - Moderated: stucco was moderated and is no longer available to the broadcaster or viewers.
  """
  MODERATED

  """- Pending: stucco is currently going through moderation."""
  PENDING

  """- Archived: Archived stucco, no longer visible."""
  ARCHIVED
}

"""
Sub Count Series shows a user's sub counts broken down by type, tier, and date.
"""
type SubCountSeries {
  """The duration each datapoint spans (ex: Day)."""
  period: TimeSeriesPeriod!

  """
  The datapoints in the timeseries, ordered ascending order by timestamp.
  """
  subCountSeriesDataPoints: [SubCountSeriesDataPoint!]!

  """The total number of subscriptions for the given time period (ex: 957)."""
  totalCount: Int!
}

"""A single data point in the time series."""
type SubCountSeriesDataPoint {
  """
  The breakdown of which tiers contributed how much to the total gift sub count.
  """
  giftSubTierBreakdown: [SubCountTierDataPoint!]!

  """
  The breakdown of which tiers contributed how much to the total multi month sub count.
  """
  multiMonthSubTierBreakdown: [SubCountTierDataPoint!]!

  """
  The breakdown of which tiers contributed how much to the total paid sub count.
  """
  paidSubTierBreakdown: [SubCountTierDataPoint!]!

  """The timestamp associated with this data point."""
  timeStamp: Time!

  """The total number of gifted subscriptions captured during this period."""
  totalGiftSubCount: Int!

  """
  The total number of multi month subscriptions captured during this period.
  """
  totalMultiMonthSubCount: Int!

  """The number of paid subscriptions captured during this period."""
  totalPaidSubCount: Int!

  """The number of Prime subscriptions captured during this period."""
  totalPrimeSubCount: Int!
}

"""SubCountTierDataPoint shows the breakdown of subcount by tier."""
type SubCountTierDataPoint {
  """
  How many of this type of subscription were captured in this time period.
  """
  count: Int!

  """The type of subscription, i.e. Tier 1, Tier 2, Tier 3."""
  tier: String!
}

"""Wrapper for errors associated with submitCSATFeedback mutation."""
type SubmitCSATFeedbackError {
  """The code associated with the error from submitCSATFeedback mutation."""
  code: SubmitCSATFeedbackErrorCode!
}

"""Possible error codes returned by the submitCSATFeedback mutation."""
enum SubmitCSATFeedbackErrorCode {
  """Unkown backend error."""
  UNKNOWN

  """
  Invalid argument error, such as exceeding max characters in feedback or providing an invalid GUID.
  """
  INVALID_ARGUMENT
}

"""
SubmitCSATFeedbackInput creates or updates a currently authenticated user's rating/feedback of Twitch Developer Products.
"""
input SubmitCSATFeedbackInput {
  """The action that prompted the CSAT callout to appear."""
  actionPrompted: CSATActionPrompted

  """
  The company ID, if the user is submitting the feedback through an organization's console.
  """
  companyID: ID

  """The additional feedback that the user submits after the rating."""
  feedback: String

  """
  The GUID used when updating a CSAT Feedback entry with additional feedback or changes.
  """
  guid: ID

  """The rating that the user submits."""
  rating: CSATRating

  """The page in Twilight that the user responds to the CSAT callout from."""
  source: String!
}

"""The result of a submitCSATFeedback mutation."""
type SubmitCSATFeedbackPayload {
  """The error from a failed submitCSATFeedback mutation."""
  error: SubmitCSATFeedbackError

  """The response of the mutation."""
  response: SubmitCSATFeedbackResponse
}

"""The response of a successful submitCSATFeedback mutation."""
type SubmitCSATFeedbackResponse {
  """Unique identifier returned in the response."""
  guid: ID!
}

"""SubmitEmotePrefix creates a new emoticon prefix for a channel."""
input SubmitEmotePrefixInput {
  """The channel ID whose emote prefix will be updated."""
  channelID: ID!

  """The new emote prefix."""
  name: String!
}

"""
SubmitEmotePrefixPayload returns a status code indicating whether the update was successful or not.
"""
type SubmitEmotePrefixPayload {
  """A code indicating why the prefix submit failed, if it did."""
  errorCode: SubmitEmotePrefixResponseCode

  """The newly submitted prefix."""
  prefix: EmoticonPrefix
}

"""A code indicating why the prefix submit failed, if it did."""
enum SubmitEmotePrefixResponseCode {
  """Only eligible users can update their emoticon prefix."""
  ERR_INVALID_USER

  """The prefix submitted was not the correct length."""
  ERR_INVALID_PREFIX_LENGTH

  """
  The prefix submitted does not meet the regular expression requirements.
  """
  ERR_INVALID_PREFIX_REGEX

  """The prefix is not in a state that it can be updated."""
  ERR_INVALID_PREFIX_STATE

  """Emote prefixes must be unique across the website."""
  ERR_PREFIX_NOT_UNIQUE

  """
  The prefix was updated recently and can't be updated again for a while.
  """
  ERR_PREFIX_UPDATE_TOO_SOON

  """
  The user is not in good standing and therefore cannot update their emoticon prefix.
  """
  ERR_NOT_IN_GOOD_STANDING

  """Something unexpected happened when submitting the emote prefix."""
  ERR_UNKNOWN

  """
  The prefix for the affiliate can not be updated. Affiliates can update prefix once every name change.
  """
  ERR_AFFILIATE_PREFIX_UPDATE_TOO_SOON

  """
  The prefix submitted for the affiliate does not match the auto generated prefix.
  """
  ERR_SUBMITTED_PREFIX_DOES_NOT_MATCH_AUTO_GENERATED_PREFIX
}

"""SubmitEmoticonPrefix creates a new emoticon prefix for a channel."""
input SubmitEmoticonPrefixInput {
  """The channel ID."""
  channelID: ID!

  """Emoticon prefix."""
  name: String!
}

"""SubmitEmoticonPrefixPayload returns the updated emoticon prefix."""
type SubmitEmoticonPrefixPayload {
  """
  The response doesn't return the real state of the prefix. Querying the emoticon
  prefix is required to get the most accurate state.
  """
  response: EmoticonPrefix!
}

"""Possible errors returned by the SubmitExtensionFeedback mutation."""
enum SubmitExtensionFeedbackError {
  """Internal service error eg. database timeout."""
  INTERNAL_ERROR
}

"""
SubmitExtensionFeedbackInput submits a user's feedback for a related rating on a Twitch extension.
"""
input SubmitExtensionFeedbackInput {
  """Feedback that the broadcaster can write."""
  comment: String!

  """The ID of the extension the feedback applies to."""
  extensionClientID: ID!

  """The version of the extension the feedback applies to."""
  extensionVersion: String!

  """ID of the user submitting the feedback for the extension."""
  userID: ID!
}

"""The result of a submitExtensionFeedback mutation."""
type SubmitExtensionFeedbackPayload {
  """The ExtensionRating record that the feedback was attached to."""
  comment: ExtensionComment

  """The error when the mutation fails to submit the extension feedback."""
  error: SubmitExtensionFeedbackError
}

"""A list of channels subscribed to by a user."""
type SubscribedChannelConnection {
  """The subscribed channels."""
  edges: [SubscribedChannelEdge!]

  """Pagination."""
  pageInfo: PageInfo!

  """The total number of subscribed channels."""
  totalCount: Int
}

"""A broadcaster user with cursor."""
type SubscribedChannelEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the user for the current edge."""
  node: User
}

"""
SubscriberBadgeProgress contains progress information for subscription badges based on a user's tenure.
"""
type SubscriberBadgeProgress {
  """
  The ID is a composite of channel_id (owner of badge) / user_id (viewer requesting badge) / version
  """
  id: ID!

  """URL of 18x18 asset."""
  image1xURL: String!

  """URL of 36x36 asset."""
  image2xURL: String!

  """URL of 72x72 asset."""
  image4xURL: String!

  """The percentage of tenure already earned towards this badge."""
  percentCompleted: Float!

  """The total tenure in months required to earn this badge."""
  requiredTenureMonths: Int!

  """Metadata about how a subscriber badge is stored & fetched."""
  version: String!
}

"""Breakdown of number of subscriptions by tier."""
type SubscriberCountBreakdown {
  """The number of subscriptions to the product."""
  count: Int!

  """The tier of the product."""
  tier: String!
}

"""
Information pertaining to user's subscriber score.
Contains subscription count, sub points, emote limits, and information about the next subscriber level.
"""
type SubscriberScore {
  """Breakdown of subscriber score by product tier."""
  breakdown: [SubscriberScoreBreakdown!]

  """Current subscriber count."""
  count: Int!

  """Breakdown of total subs by product tier."""
  countBreakdown: [SubscriberCountBreakdown!]

  """Current subscriber score."""
  current: Int!

  """Current number of emotes unlocked."""
  currentEmoteLimit: Int!

  """
  Next goal to unlock more emotes.
  Will be null if max score already reached.
  """
  next: Int

  """
  Emote limit after reaching nextScoreGoal.
  Will be null if max emote limit reached.
  """
  nextEmoteLimit: Int
}

"""Breakdown of score by tier."""
type SubscriberScoreBreakdown {
  """The score of the product."""
  score: Int!

  """The tier of the product."""
  tier: String!
}

"""Data about a user's subscription to a broadcaster."""
type SubscriptionBenefit {
  """The date that the subscription benefit ends."""
  endsAt: Time

  """gift resolves gift info about a SubscriptionBenefit."""
  gift: SubscriptionGift

  """The unique identifier."""
  id: ID!

  """
  For a recurring subscription, the price is charged at every interval i months.
  """
  intervalNumber: Int!

  """Whether the sub is set to "do not renew"."""
  isDNRd: Boolean!

  """
  Whether this subscription has been extended. This means that a non-recurring
  subscription has been extended with additional months.
  """
  isExtended: Boolean!

  """
  Whether the subscription is in the grace period to be cancelled and refunded.
  """
  isRefundable: Boolean!

  """
  The id of where the subscription originated from. Used when DNRing a recurring subscription.
  """
  originID: String

  """
  If the subscriptionBenefit has a future dated paid upgrade. (ie. a user has
  upgraded a 1-month gift to a recurring subscription).
  """
  paidUpgrade: PaidUpgrade @deprecated(reason: "gift to paid upgrades will now be in the pendingSubscription schema")

  """
  If the subscriptionBenefit has a pending future dated paid subscription.
  """
  pendingSubscription: PendingSubscription

  """The platform the subscription was purchased on."""
  platform: SubscriptionPlatform!

  """Resolves the product that the subscription benefit is to."""
  product: SubscriptionProduct

  """Whether this benefit was achieved using a Twitch Prime subscription."""
  purchasedWithPrime: Boolean!

  """
  The date that the subscription benefit will renew. Will be nil if the subscription benefit
  is not going to renew.
  """
  renewsAt: Time

  """
  The states this benefit has transitioned through. Captures both user-initiated states
  such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
  """
  states: [SubscriptionBenefitStateHistory!]

  """
  Exposes the third party SKU for managing third party subscriptions from the client.
  Will be nil if there is not a thirdPartySKU associated with this subscription benefit.
  """
  thirdPartySKU: String

  """The subscription tier."""
  tier: String!

  """The user who is subscribed to."""
  user: User
}

"""A paginated list of subscription benefits."""
type SubscriptionBenefitConnection {
  """The list of subscription benefits on this page."""
  edges: [SubscriptionBenefitEdge!]

  """Information about this page of payment transactions."""
  pageInfo: PageInfo!
}

"""
Criteria for building paginated list of user's all active subscriptions.
"""
input SubscriptionBenefitCriteriaInput {
  """Only return subscription benefits for a given filter value."""
  filter: SubscriptionBenefitFilter = ALL

  """Platform where subscriptions were purchased."""
  platform: SubscriptionPlatform = WEB
}

"""An element in a paginated list of subscription benefits."""
type SubscriptionBenefitEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The element node."""
  node: SubscriptionBenefit
}

"""Set of ways to filter subscription benefit paginated results."""
enum SubscriptionBenefitFilter {
  """
  Only subscriptions purchased on a platform, specified in the input as platform.
  """
  PLATFORM

  """Only Subscriptions received through gifts from another Twitch user."""
  GIFT

  """All active subscriptions."""
  ALL
}

"""The logic state of the Subscription Benefit."""
enum SubscriptionBenefitState {
  """Unknown (0-value) state."""
  UNKNOWN

  """Active (recurring) state."""
  ACTIVE

  """State when a user has initiated a DNR request."""
  DNR_INITIATED

  """State for when Twitch has completed a DNR request."""
  WILL_NOT_RENEW

  """State for when Twitch has initiated a refund request."""
  CANCEL_INITIATED

  """State for when Twitch has completed a refund request."""
  CANCELLED

  """
  State for when a Subscription has been paused (used to support Android account hold feature).
  """
  ON_HOLD
}

"""
Data about the states a Subscription Benefit has transitioned through. Captures both user-initiated states
such as initiating a DNR request, as well as system-initiated states such as completing a DNR request.
"""
type SubscriptionBenefitStateHistory {
  """When the benefit transitioned to this state."""
  createdAt: Time

  """The logical state the benefit occupied."""
  state: SubscriptionBenefitState!
}

"""Configs that help initiate the subscription checkout flow."""
type SubscriptionCheckoutConfigs {
  """Lists any additional actions for a subscription checkout session."""
  actions: [CheckoutAction!]!

  """
  Whether the initiated checkout flow can complete/succeed and gift the recipient the product.
  """
  canGift: Boolean!

  """Whether the initiated checkout flow can proceed with a purchase."""
  canPurchase: Boolean!

  """
  Whether the purchaser is eligible for a one-time promotion in the subscription purchase checkout flow.
  """
  isOneMonthFreeEligible: Boolean!

  """
  Holds configuration necessary for initializing payment provider client libraries and facilitate checkout flow.
  """
  paymentProviderConfigs: PaymentProviderConfigs!

  """Purchase Ineligibility reason details."""
  purchaseIneligibilityReason: PurchaseIneligibilityReason!
}

"""
An Offer for purchasing community gift subscriptions with associated metadata about the Offer.
Composes the "model" (Offer) with the "view" metadata about the offer.
"""
type SubscriptionCommunityGifting {
  """The image assets for this offer."""
  assets: SubscriptionCommunityGiftingAssets!

  """The Offer document for this Community Gift offer."""
  offer: Offer

  """The default number of subscriptions that this offer is offering."""
  quantity: Int!

  """The type of this community gifting offer."""
  type: SubscriptionCommunityGiftingType!
}

"""Groups image assets related to the community gifting Offer."""
type SubscriptionCommunityGiftingAssets {
  """
  The link to the 1x pixel density image asset for this community gifting offer.
  """
  imageURL1x: String!

  """
  The link to the 2x pixel density image asset for this community gifting offer.
  """
  imageURL2x: String!

  """
  The link to the 3x pixel density image asset for this community gifting offer.
  """
  imageURL3x: String!

  """
  The link to the 4x pixel density image asset for this community gifting offer.
  """
  imageURL4x: String!
}

"""Describes the type of community gifting Offer that is being resolved."""
enum SubscriptionCommunityGiftingType {
  """An unknown gifting type."""
  UNKNOWN

  """A preset bundle of fixed-quantity community gift subscriptions."""
  BUNDLE

  """
  An offer that allows the user to choose how many gift subscriptions they would like to purchase.
  """
  CUSTOM
}

"""Gift information for a subscription benefit."""
type SubscriptionGift {
  """giftDate is the date that the gift was given."""
  giftDate: Time

  """
  Gifter is the user who sent the gift. Will be nil if isGift is false or is the gift is anonymous.
  """
  gifter: User

  """isGift says whether the subscription benefit is a gift or not."""
  isGift: Boolean!
}

"""A parent field for grouping the different types of gift subscriptions."""
type SubscriptionGifting {
  """
  Offers and associated metadata for purchasing community gift subscriptions.
  """
  community: [SubscriptionCommunityGifting!]

  """
  Offers for purchasing a gift subscription to the given user.
  This will prefer the ID if both login and ID are provided.
  If neither are provided, this will return null.
  """
  standard(recipientID: ID, recipientLogin: String): [SubscriptionStandardGifting!]
}

"""
A gift offer that is available on a particular subscription based
on gift type and platform.
"""
type SubscriptionGiftOffer {
  """Unique identifier of a subscription gift offer."""
  id: ID!

  """
  The subscription gift offer price info which contains information about currency, cost and tax information.
  """
  priceInfo(taxCountry: String): PriceInfo!

  """The available promotions on this gift offer."""
  promotion: SubscriptionGiftPromotion

  """The amount of gifts in this offer."""
  quantity: Int!

  """
  thirdPartySKU represents the purchasable third party SKU of the gift the user will purchase.
  Will return an nil if the user has no purchasable skus.
  Will return nil if not on a platform with an external subscription gift offer or if the country is not supported.
  """
  thirdPartySKU: String

  """The type of gift this offer is for."""
  type: SubscriptionGiftType!
}

"""The different types of platforms available for gift offers."""
enum SubscriptionGiftOfferPlatform {
  """Gift offers available for the web clients."""
  WEB

  """Gift offers available for the Android clients."""
  ANDROID
}

"""The promotion offer on a subscription gift offer."""
type SubscriptionGiftPromotion {
  """
  The subscription gift's discount type for this promotion(e.g. "PERCENT_OFF").
  """
  discountType: SubscriptionPromotionDiscountType!

  """The discount value of the subscription gift product (e.g. "50")."""
  discountValue: String!

  """Unique identifier of a subscription gift promotion."""
  id: ID!

  """
  The subscription gift offer price info which contains information about currency, cost and tax information.
  """
  priceInfo(taxCountry: String): PriceInfo!

  """
  The quantity of gifts this promotion is for(ex: 11 gifts for a promotion on 10 gifts).
  """
  quantity: Int!

  """
  Promotion consumable SKU used by third party that the user will purchase.
  """
  thirdPartySKU: String
}

"""The different types of subscription gifting."""
enum SubscriptionGiftType {
  """Unknown or no gift type."""
  NONE

  """Standard gifts are gifts to a specific user given by a user."""
  STANDARD

  """
  Community gifts are one or more gifts given to one or more users by a user.
  """
  COMMUNITY
}

"""Represents the interval of a subscription product."""
type SubscriptionInterval {
  """The unit-less amount of time a subscription lasts for."""
  duration: Int!

  """Denotes the unit of the interval."""
  unit: SubscriptionIntervalUnit!
}

"""Denotes the unit of the period of a subscription product."""
enum SubscriptionIntervalUnit {
  """This subscription product length is unknown."""
  UNKNOWN

  """This subscription product lasts X weeks."""
  WEEK

  """This subscription product lasts X months."""
  MONTH

  """This subscription product lasts X years."""
  YEAR

  """This subscription product lasts forever."""
  ONE_TIME
}

"""Subscription pricing information."""
type SubscriptionOffer {
  """Currency the offer is for."""
  currency: String!

  """Exponent to use when shifting the currency."""
  exponent: Int!

  """Id for offer on subscription product."""
  id: ID!

  """Price for the offer."""
  price: Int!

  """Promotion description."""
  promoDescription: String
}

"""
SubscriptionPlatform enumerates platform options such as WEB, IOS, ANDROID.
"""
enum SubscriptionPlatform {
  """Unknown or no platform."""
  NONE

  """Access from the browser.                                           )."""
  WEB

  """Access from the Twitch iOS application."""
  IOS

  """Access from the Twitch Android application."""
  ANDROID

  """Access from all Twitch Mobile applications (ANDROID + IOS)."""
  MOBILE_ALL
}

"""
A subscription that is purchasable by users.
Once purchased, the subscription entitles the user to use special emote sets on Twitch.
"""
type SubscriptionProduct {
  """The subscription product's display name."""
  displayName: String

  """The maximum number of Emotes that can be associated with this product."""
  emoteLimit: Int

  """
  The maximum number of animated Emotes that can be associated with this product.
  """
  animatedEmoteLimit: Int

  """The emote modifiers associated with the product."""
  emoteModifiers: [EmoteModifier!]

  """
  The identifier of the static EmoteSet that a user gains access to use on Twitch,
  when they purchase this product.
  """
  emoteSetID: ID @deprecated(reason: "Products can have more than one emote set now so use emoteGroups instead.")

  """
  The emote groups that the user gains access to use on Twitch when they purchase this product.
  When using the ALL filter the data is uncached and should only be used on the creator dashboard.
  """
  emoteGroups(state: EmoteStateFilter = ACTIVE): [EmoteSet!]

  """
  A list of Emotes the user gains access to use on Twitch when they purchase
  this product.
  """
  emotes(state: EmoteStateFilter = ACTIVE): [Emote]

  """
  A list of GiftOffers that are available on this subscription product
  depending on which platform and gift type is given
  Used by clients to display different gift prices, quantities and gift promotion information.
  """
  giftOffers(platform: SubscriptionGiftOfferPlatform, type: SubscriptionGiftType!): [SubscriptionGiftOffer!]

  """The subscription product's promotion if it is active."""
  giftPromotion: SubscriptionPromotion

  """The different types of gift subscriptions ("Community" vs "Standard")."""
  gifting: SubscriptionGifting!

  """Whether the subscription hides ads for the channel."""
  hasAdFree: Boolean!

  """
  Whether the subscribers of this product are affected by slow chat mode.
  """
  hasFastChat: Boolean

  """Whether the channel has sub only chatroom restriction."""
  hasSubOnlyChat: Boolean

  """
  Whether the subscribers of this product are able to see the subs-only video archive.
  """
  hasSubonlyVideoArchive: Boolean

  """The subscription product's identifier."""
  id: ID!

  """The interval that the product lasts for. Includes unit + duration."""
  interval: SubscriptionInterval!

  """The subscription product's name."""
  name: String!

  """Available offers for a subscription product."""
  offers: [Offer!]

  """
  The Twitch user that is the owner of the channel associated with this subscription product.
  This is null for SubscriptionProducts like 'turbo' that are not associated with any user.
  """
  owner: User

  """The subscription's USD-formatted price, e.g. "$9.99"."""
  price: String! @deprecated(reason: "Transitioning to priceInfo instead to support multi region pricing")

  """
  PriceInfo holds the products pricing information such as currency, cost, and tax information.
  """
  priceInfo(taxCountry: String): PriceInfo!

  """The subscription product's promotion if it is active."""
  promotion: SubscriptionPromotion

  """
  The currently active revenue configuration record for the subscription product.
  """
  revenueConfig: RevenueConfig

  """The connection for user to the subscription product."""
  self: SubscriptionProductSelfConnection

  """The avaliability state of the product. e.g. "active" or "inactive"."""
  state: SubscriptionState!

  """
  ThirdPartytemplateSKU is used by the frontend to retrieve third party product information such
  as price. templateSKU is exposed separately from purchaseSKU since retrieving purchaseSKU is a
  more expensive operation. A user may not be able to purchase the templateSKU. Use purchaseSKU
  when the user has indiciated they want to purchase.
  Uses Client-ID to determine platform information and IP address to determine location.
  """
  thirdPartyTemplateSKU(platform: String): String

  """The tier of the product."""
  tier: String!

  """The type of subscription, e.g. "chansub" or "teamsub"."""
  type: SubscriptionProductType!

  """The URL for this subscription's purchase page."""
  url: String!
}

"""A set of subscription products."""
type SubscriptionProductsConnection {
  """The resolved subscription products."""
  nodes: [SubscriptionProduct!]!
}

"""The connection between the user and subscription product."""
type SubscriptionProductSelfConnection {
  """
  This user's subscription benefit information for the subscription product.
  """
  benefit: SubscriptionBenefit

  """
  True if the user in this connection is allowed to gift the product in this connection.
  """
  canGiftInChannel: Boolean!

  """
  True if the user in this connection can gift the product in this connection to the user with the supplied user ID.
  """
  canGiftTo(recipientID: ID!): Boolean!

  """
  True if the user in this connection can gift the product in this connection to the user with the supplied login.
  Since this requires an additonal lookup to get the user ID from the login, this is less preferable than canGift.
  """
  canGiftToLogin(recipientLogin: String!): Boolean!

  """
  Holds configuration necessary to start subscription purchase checkout flow for this product for current user.
  """
  checkoutConfiguration(config: CheckoutConfigurationInput!): SubscriptionCheckoutConfigs

  """The subscription's discount type (e.g. "percent_off")."""
  discountType: DiscountType! @deprecated(reason: "Transitioning to promotion field instead")

  """The discount value of the subscription product (e.g. "50")."""
  discountValue: String! @deprecated(reason: "Transitioning to promotion field instead")

  """
  A list of GiftOffers that are available on this subscription product
  depending on which platform, giftType and user that is authenticated.
  Exposed on the self connection as well since user based promotions can be given in the future
  Used by clients to display different gift prices, quantities and user based gift promotion information.
  """
  giftOffers(platform: SubscriptionGiftOfferPlatform, type: SubscriptionGiftType!): [SubscriptionGiftOffer!]

  """If the product is eligible for a discount."""
  isEligibleForDiscount: Boolean! @deprecated(reason: "Transitioning to promotion field instead")

  """The subscription's USD-formatted price after discount (e.g. "$2.49")."""
  newPrice: String! @deprecated(reason: "Transitioning to promotion field instead")

  """The subscription's USD-formatted price before discount (e.g. "$4.99")."""
  oldPrice: String! @deprecated(reason: "Transitioning to promotion field instead")

  """If the subscription product is eligible for a paid upgrade promotion."""
  paidUpgradePromotion: SubscriptionPromotion

  """
  Contains information on the final checkout price of this subscription product.
  """
  productPurchase(quantity: Int!, paymentProvider: PaymentProvider!): ProductPurchase

  """The subscription product's promotion for user if eligible."""
  promotion: SubscriptionPromotion

  """
  This user's subscription purchase details for the subscription product. If this user is not
  subscribed to the product, then the result's state is 'inactive'. If a compatible purchase exists,
  then the result's "compatiblePurchase" field is present.
  """
  purchase: SubscriptionPurchase

  """Subscription tenure data for the user to this subscription product."""
  subscriptionTenure(tenureMethod: SubscriptionTenureMethod!): SubscriptionTenure

  """
  ThirdPartyPurchaseSKU is different from templateSKU since it represents the SKU of the exact item the
  user will purchase. It is more expensive to retrieve purchaseSKU than templateSKU, so only
  use purchaseSKU when the user has indicated they want to checkout. Use templateSKU on channel
  page load to retrieve product information.
  
  Will return an error if the user has no purchasable skus. Will return nil if not on a platform
  with an external subscription product or if the country is not supported.
  Uses Client-ID to determine platform information and IP address to determine location.
  """
  thirdPartyPurchaseSKU(platform: String): String
}

"""A subscription products error."""
type SubscriptionProductsError {
  """A code representing the error state."""
  code: SubscriptionProductsErrorCode!
}

"""
Codes representing subscription products error states clients can respond to.
"""
enum SubscriptionProductsErrorCode {
  """Default code."""
  UNKNOWN

  """
  Code indicating server error occurred while retrieving subscription products.
  """
  ERROR

  """Code indicating subscription products could not be found."""
  MISSING
}

"""
The set of results that can occur when resolving a subscription product.
"""
union SubscriptionProductsResult = SubscriptionProductsConnection | SubscriptionProductsError

"""The types of subscription products that can be purchased."""
enum SubscriptionProductType {
  """Channel sub."""
  CHANSUB

  """Team sub."""
  TEAMSUB

  """Turbo sub."""
  TURBO
}

"""The promotion offer on subscription product."""
type SubscriptionPromotion {
  """Contains information on the final checkout price for this promotion."""
  checkoutPrice(quantity: Int!, paymentProvider: PaymentProvider!): ProductPurchase

  """The subscription's discount type (e.g. "PERCENT_OFF")."""
  discountType: SubscriptionPromotionDiscountType! @deprecated(reason: "No longer supported.")

  """The discount value of the subscription product (e.g. "50")."""
  discountValue: String! @deprecated(reason: "No longer supported.")

  """The subscription's USD-formatted price after discount (e.g. "$2.49")."""
  newPrice: String! @deprecated(reason: "Use SubscriptionPromotion.previewPrice instead.")

  """The subscription's USD-formatted price before discount (e.g. "$4.99")."""
  oldPrice: String! @deprecated(reason: "Use SubscriptionProduct.priceInfo instead.")

  """The price for the promotion."""
  previewPrice: PriceInfo!
}

"""Valid discount types for Subscription promotion."""
enum SubscriptionPromotionDiscountType {
  """No discount on subscription product."""
  NONE

  """Percent off discount on subscription product."""
  PERCENT_OFF

  """Fixed price discount on subscription product."""
  FIXED_VALUE_OFF
}

"""
A user's subscription purchase details, part of the Subscription Checkout workflow.
"""
type SubscriptionPurchase {
  """
  A compatible purchase exists if this user bought a subscription product of a different tier for the
  channel in question.
  
  i.e. this user doesn't have this subscription purchase for the $4.99 sub but they do have a
       compatible purchase for the $9.99 subscription.
  """
  compatiblePurchases: [SubscriptionPurchaseDetails!]

  """
  The purchase details for a Twitch purchaser - Subscription product combination.
  """
  details: SubscriptionPurchaseDetails
}

"""The receipt details for a subscription purchase."""
type SubscriptionPurchaseDetails {
  """Date the purchase was cancelled at, if applicable, else null."""
  cancelledAt: Time

  """Currency for the price, e.g. "USD"."""
  currency: String!

  """
  Divisor for the price based on the currency. e.g. Divisor for USD is 100.
  """
  divisor: Int!

  """Purchase's payment provider."""
  paymentProvider: PaymentProvider!

  """Price in smallest subunit of currency, e.g. "499" cents."""
  price: Int!

  """The tier of the subscription purchase product."""
  productTier: String

  """The type of subscription purchase."""
  productType: SubscriptionProductType!

  """Purchase state."""
  state: SubscriptionPurchaseState!
}

"""The various states of the subscription purchase receipt."""
enum SubscriptionPurchaseState {
  """Active subscription purchase. It could be non-renewing or renewing."""
  ACTIVE

  """Cancelled subscription purchase."""
  CANCELLED

  """
  Inactive subscription purchase. User's subscription benefit from the original purchase has ended
  and has not renewed.
  """
  INACTIVE
}

"""
An Offer for purchasing a Standard (AKA "single" or "targetted") gift subscription for a specific user.
This type exists as a futureproofing measure as gifting will evolve over time.
"""
type SubscriptionStandardGifting {
  """The Offer document for this Standard Gift offer."""
  offer: Offer
}

"""The availability state of a subscription product."""
enum SubscriptionState {
  """Active state."""
  ACTIVE

  """Inactive state."""
  INACTIVE

  """Unknown state."""
  UNKNOWN
}

"""Simple summary of subscription product."""
type SubscriptionSummary {
  """Emotes included with subscription."""
  emotes: [Emote]

  """Subscription product id, for now is the same as the ticket product id."""
  id: ID!

  """Emote modifiers available at this tier."""
  modifiers: [EmoteModifier!]

  """Channel's custom name for their subscription."""
  name: String!

  """
  Pricing information about subscription, filtered to what is available for user.
  """
  offers: [SubscriptionOffer!]

  """Info specific to the user."""
  self: SubscriptionSummarySelf!

  """Tier of subscription, either 1, 2, or 3."""
  tier: SubscriptionSummaryTier!

  """URL for checkout page."""
  url: String!
}

"""Most of the user specific fields for SubscriptionSummary."""
type SubscriptionSummarySelf {
  """What is the cumulative tenure for this user."""
  cumulativeTenure: Int!

  """The tier the user is subbed to (if they have a sub)."""
  subscribedTier: SubscriptionSummaryTier
}

"""Tier of subscription."""
enum SubscriptionSummaryTier {
  """First tier, $4.99 for US market."""
  TIER_1

  """Second tier, $9.99 for US market."""
  TIER_2

  """Third tier, $24.99 for US market."""
  TIER_3
}

"""Tenure to a subscription product."""
type SubscriptionTenure {
  """The days remaining in a user's current tenure period."""
  daysRemaining: Int!

  """The days elapsed in a user's current tenure period."""
  elapsedDays: Int!

  """The ending date of a user's tenure."""
  end: Time

  """The method used to calculate the user's tenure."""
  method: SubscriptionTenureMethod!

  """The total duration of a user's tenure."""
  months: Int!

  """The starting date of a user's tenure."""
  start: Time
}

"""A type of tenure to a subscription product."""
enum SubscriptionTenureMethod {
  """Tenure data calculated cumulatively."""
  CUMULATIVE

  """Tenure data calculated streak-based."""
  STREAK
}

"""
A channel could have multiple subscription products at varying tiers.
Each value will always map to the respective tier for every channel that has the given tier available as a product.

Example:
A channel with a "tier 2" subscription product will always have the tier represented as T_2000.
"""
enum SubscriptionTier {
  """Custom tier."""
  CUSTOM

  """Subscribed with Twitch Prime."""
  PRIME

  """Tier "1000"."""
  T_1000

  """Tier "2000"."""
  T_2000

  """Tier "3000"."""
  T_3000
}

"""Token that a User uses for redeeming Subscriptions."""
type SubscriptionToken {
  """Current token balance of user."""
  balance: Int
}

"""
A SubscriptionTokenBundleProduct can contain multiple Offers.
ex) A Bundle of size 3 tokens, can have 3 other offers such as:
  - Normal offer: "Pay $16.99 for the bundle
  - Discounted, one-time buy offer: "Pay $14.99 for the bundle, but a one-time purchase only"
  - Bits: Use X amount of Bits to purchase this Bundle.
"""
type SubscriptionTokenBundleProduct {
  """Assets assocaited with a certain Token Bundle Product."""
  assets: [TokenBundleAsset!]

  """Subscription token bundle product's identifier."""
  id: ID!

  """
  List of available offers for this bundle product.
  Displays the cheapest offer to the user, if there are promotions to be applied.
  """
  offers: [Offer!]

  """Quantity of tokens the bundle."""
  quantity: Int!
}

"""Describes configurable values for the token product line."""
type SubscriptionTokenProductConfig {
  """Max token balance a user can have."""
  maxBalance: Int
}

"""The individual swap participant input."""
input SwapCompetitionLobbyParticipantInput {
  """The id of the lobby where the lobby participant currently is."""
  lobbyID: ID!

  """
  The id of the lobby participant, which can be competition player id or competition team id, we are swapping with.
  """
  participantID: ID!
}

"""
SwapCompetitionLobbyParticipantsInput exchanges the lobby placements of the two participants within the same phase.
"""
input SwapCompetitionLobbyParticipantsInput {
  """The id of the competition."""
  competitionID: ID!

  """
  The participantID and lobbyID of the first lobby participant to be swapped.
  """
  first: SwapCompetitionLobbyParticipantInput!

  """The id of the phase."""
  phaseID: ID!

  """
  The participantID and lobbyID of the second lobby participant to be swapped.
  """
  second: SwapCompetitionLobbyParticipantInput!
}

"""
SwapCompetitionLobbyParticipantsPayload is the success response for swapping lobby participants.
"""
type SwapCompetitionLobbyParticipantsPayload {
  """The new state of competition after swapping participants."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""
SyncGameOnDropCampaignPayload contains the campaign ID that needs to be synced.
"""
input SyncGameOnDropCampaignInput {
  """The ID of the campaign to sync."""
  campaignID: ID!
}

"""SyncGameOnDropCampaignPayload returns the result of the sync."""
type SyncGameOnDropCampaignPayload {
  """The campaign after the sync."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
Tag(s) are used as a discovery and search mechanism for tagged content, including Streams, Clips, and VODs.
"""
type Tag {
  """Timestamp of the creation of this tag."""
  createdAt: Time

  """This tag's unique identifier."""
  id: ID!

  """Whether this tag is auto generated."""
  isAutomated: Boolean!

  """Whether this tag is a language tag."""
  isLanguageTag: Boolean!

  """Localized description of this tag."""
  localizedDescription: String!

  """Localized Name of this tag."""
  localizedName: String!

  """Scope of the Tag."""
  scope: TagScope!

  """Official Name of this tag in English."""
  tagName: String!
}

"""The frequency of a tag used as filter for a channel."""
type TagAnalytic {
  """A decimal that shows how often a Tag is used."""
  percentage: Float!

  """The tag for the analytic."""
  tag: Tag!
}

"""A paginated list of tags, and its metadata."""
type TagConnection {
  """The list of tags in this page."""
  edges: [TagEdge!]

  """Information about this page of tags."""
  pageInfo: PageInfo!
}

"""An element in a paginated tags, and its metadata."""
type TagEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Node represents the extension for the current edge."""
  node: Tag
}

"""The content that are possibly return for tagging mutation payload."""
union TaggedContent = Clip | Game | Stream | User | Video

"""An enumeration on the different scope of a tag."""
enum TagScope {
  """Tags that can be applied to all content types."""
  ALL

  """Tags that can only be applied to the CATEGORY content type."""
  CATEGORY
}

"""An enumeration on the different tag types of a category."""
enum TagType {
  """Tags applied to the category."""
  CONTENT

  """
  The most popular tags used by other channels streaming this game/category.
  """
  TOP
}

"""
TargetedModerationAction is a ModLogs entry of a chat ban,timeout, or unban.
"""
type TargetedModActionDetails {
  """Timestamp when user was banned/timed-out."""
  bannedAt: Time

  """Duration of the chat timeout (in seconds)."""
  durationSeconds: Int

  """Timestamp when the chat timeout expires."""
  expiresAt: Time

  """Reason of the action."""
  reason: String
}

"""
TaxInterview describes the information for a user's Amazon tax interview during payout onboarding.
"""
type TaxInterview {
  """Amazon tax interview account ID."""
  accountID: ID! @deprecated(reason: "Use interview options instead")

  """Amazon tax interview client ID."""
  clientID: ID! @deprecated(reason: "Use interview options")

  """Legal name of the user completing the Amazon tax interview."""
  governmentAlias: String! @deprecated(reason: "Use interview options")

  """
  The preferred locale for user in the accepted format to initate the Amazon tax interview (e.g. "en_US").
  """
  locale: String! @deprecated(reason: "Use interview options instead")

  """List of key value pairs that were used to generate the signature."""
  options: [TaxInterviewOption!]

  """Unique signature to initiate the Amazon tax interview."""
  signature: String!

  """The type of Amazon tax interview."""
  type: TaxInterviewType! @deprecated(reason: "Use interview options instead")

  """The URL for user to begin their Amazon tax interview."""
  url: String!
}

"""
TaxInterviewOption is a key value pair type used by the tax interview.
Each option represents a form value that musted be passed to the argon website.
"""
type TaxInterviewOption {
  """The name of the option."""
  key: String!

  """The option value."""
  value: String!
}

"""TaxInterviewType enumerates valid Amazon tax interview types."""
enum TaxInterviewType {
  """
  Describes an Amazon tax interview that would allow users to receive royalty income through licensed content.
  """
  ROYALTY

  """
  Describes an Amazon tax interview that would allow users to receive income for their goods and services.
  """
  SERVICE
}

"""
TaxMismatchError enumerates valid registration and tax interview field names for payout onboarding.
"""
enum TaxMismatchError {
  """
  Applied when the user submits a name that does not match the name on their registration.
  If provided, the company name will be compared intead of the user's full legal name.
  """
  NAME

  """
  Applied when the user submits a country that does not match the country on their registration.
  """
  COUNTRY

  """
  Applied when the user submits an email that does not match the email on their registration.
  """
  EMAIL

  """
  Applied when the user submits a street address that does not match the street address on their registration.
  """
  STREET_ADDRESS

  """
  Applied when the user submits a street address 2 that does not match the street address 2 on their registration.
  """
  STREET_ADDRESS_2

  """
  Applied when the user submits a city that does not match the city on their registration.
  """
  CITY

  """
  Applied when the user submits a state that does not match the state on their registration.
  """
  STATE

  """
  Applied when the user submits a postal that does not match the postal on their registration.
  """
  POSTAL
}

"""Represents a tax jurisdiction from which a final price was calculated."""
type TaxRegion {
  """Tax country, required for the TaxRegion object type."""
  countryCode: String!

  """Tax state if applicable."""
  state: String

  """Tax zip code if applicable."""
  zipCode: String
}

"""GDPR cookie vendors for vendors that support TCF strings, for a user."""
type TCFCookieVendor {
  """User content status for each vendor."""
  consentStatus: ConsentStatus!

  """If it’s an advertising, analytics, or essential cookie."""
  cookieVendorType: CookieVendorType!

  """List of features this vendor uses."""
  features: [ConsentFeature!]

  """
  A flag that shows if the consent is given by the user or by consent service as default value.
  """
  hasUserSetConsent: Boolean!

  """A flag that shows if the vendor should be visible to management page."""
  isVisible: Boolean!

  """Vendor name."""
  name: VendorName!

  """Url to the Vendor's privacy policy."""
  policyURL: String!

  """List of purposes this vendor uses."""
  purposes: [ConsentPurpose!]

  """List of special features this vendor uses."""
  specialFeatures: [ConsentSpecialFeature!]

  """List of special purposes this vendor uses."""
  specialPurposes: [ConsentSpecialPurpose!]
}

"""
Team represents a Twitch Team.
Teams are collections of streaming channels, and are owned by a Twitch user.
Teams have landing pages, e.g. https://www.twitch.tv/team/clg.
"""
type Team {
  """ID to an image meant to be the background of the Team's landing page."""
  backgroundImageID: ID

  """URL to an image meant to be the background of the Team's landing page."""
  backgroundImageURL: String

  """ID to the Team's banner image."""
  bannerID: ID

  """URL to the Team's banner image."""
  bannerURL: String

  """
  Retrieves team stats within the start and end time broken down by granularity.
  Default end time will be the current time (now).
  Granularity defaults to 5 minutes.
  ChannelIDs defaults to all team members.
  """
  creatorTimeseriesMetrics(startAt: Time!, endAt: Time, timeZone: String!, granularity: Granularity = FIVE_MINUTE, channelIDs: [ID!] = []): CreatorTimeseriesMetrics

  """Information about the team, formatted in Markdown."""
  description: String

  """Display version of the team name."""
  displayName: String!

  """The Team's ID."""
  id: ID!

  """
  Channels that the Team owner have opted to highlight that are currently live.
  These channels may or may not also be members of the Team.
  They will be returned in the order configured by the Team admin.
  """
  liveFeaturedChannels(first: Int = 10, after: Cursor): UserConnection

  """
  Users that belong to the team that are currently live.
  They will be returned in the order configured by the Team admin.
  """
  liveMembers(first: Int = 10, after: Cursor): UserConnection

  """ID to the Team's logo image."""
  logoID: ID

  """URL to the Team's logo image."""
  logoURL: String

  """
  The list of users that belong to this team.
  They will be returned in the order configured by the Team admin.
  metricsRevealed allows the client to return all `none`, `statsRevealed`, or `revenueRevealed` members.
  Defaults to all members to avoid breaking changes.
  """
  members(first: Int = 10, after: Cursor, metricsRevealedFilter: MemberMetricsRevealedParams): UserConnection

  """The alphanumeric Twitch name of the team."""
  name: String!

  """Owner is the User that owns and manages the Team."""
  owner: User

  """
  Aggregated analytics for several video referral sources, for use in teams dashboard.
  ChannelIDs defaults to all team members.
  """
  videoPlayReferrals(start: Time!, end: Time!, filter: ReferralsFilter = ALL, dimension: ReferralsDimension!, first: Int = 10, channelIDs: [ID!] = []): VideoPlayReferrals
}

"""Inputs for terminating a poll."""
input TerminatePollInChannelInput {
  """The id of the channel with the poll to terminate."""
  channelID: ID!
}

"""Outputs from the terminate poll mutation."""
type TerminatePollInChannelPayload {
  """The terminated poll."""
  poll: Poll
}

"""Inputs for terminating a poll."""
input TerminatePollInput {
  """The id of the poll to terminate."""
  pollID: ID!
}

"""Outputs from the create poll mutation."""
type TerminatePollPayload {
  """The created poll."""
  poll: Poll
}

"""A shelf title token type that contains text with various formatters."""
type TextToken {
  """If this title token should be emphasized or not."""
  hasEmphasis: Boolean!

  """The location that this shelf title token should link to."""
  location: LinkType!

  """The text to display for this token."""
  text: String!
}

type ThumbnailOEmbed {
  height: Int!
  url: String!
  width: Int!
}

"""Possible labels for extra points awarded to resolve ties."""
enum TiebreakerLabel {
  """Tiebreaker Points are awarded for a kill, useful in BR games."""
  KILLS

  """Tiebreaker Points are a generic bonus field determined by the CO."""
  BONUS

  """An unknown label was provided."""
  UNKNOWN
}

"""
RFC3339 timestamp.
For example "2015-07-22T21:41:14Z".
"""
scalar Time

"""A drop triggered by accummulating minutes watched."""
type TimeBasedDrop implements DropType {
  """The rewards for this drop and how often those rewards can be awarded."""
  benefitEdges: [DropBenefitEdge!]

  """The campaign this drop belongs to."""
  campaign: DropCampaign!

  """The time at which this drop becomes unavailable."""
  endAt: Time!

  """A unique identifier."""
  id: ID!

  """The name of this drop."""
  name: String!

  """
  The drops that must have been claimed before this drop can be claimed / made progress for.
  """
  preconditionDrops: [TimeBasedDrop!]

  """
  The number of minutes a user has to watch in order to claim the reward.
  """
  requiredMinutesWatched: Int!

  """User specific data associated with the TimeBasedDrop."""
  self: TimeBasedDropSelfEdge!

  """The time at which this drop becomes available."""
  startAt: Time!
}

"""User specific data associated with this drop."""
type TimeBasedDropSelfEdge {
  """The current progress for a given user towards this drop."""
  currentMinutesWatched: Int!

  """
  The ID of the drop reward granted to the user if the drop is claimable, returns null otherwise.
  """
  dropInstanceID: ID

  """
  Indicates whether or not all preconditions have been met, and the drop is available to get progress.
  """
  hasPreconditionsMet: Boolean!

  """Whether the user has already claimed their reward for this drop."""
  isClaimed: Boolean!
}

"""Single item of stats for the time series."""
type TimeseriesItem {
  """Deprecated: Number of follows during this timestamp."""
  follows: Int @deprecated(reason: "Use user.timeseriesStats.follows instead.")

  """Streamed duration (in minutes)."""
  minutesStreamed: Int!

  """Timestamp of the broken down time series."""
  timestamp: Time!

  """Value at the timestamp."""
  value: Float!
}

"""
The subcount series is able to display each datapoint according to the following durations.
"""
enum TimeSeriesPeriod {
  """Period of one day per datapoint."""
  DAY

  """Period of one month per datapoint."""
  MONTH
}

"""
Stats within a time frame broken down by granularity.
This is used for per channel stats, per team stats use "CreatorTimeseriesMetrics".
"""
type TimeseriesStats {
  """Seconds of ads played per time chunk."""
  adBreaksInSeconds: [TimeseriesItem!]

  """Ad time (in seconds) per hour per time chunk."""
  adTimePerHour: [TimeseriesItem!]

  """Average number of viewers per time chunk."""
  averageViewers: [TimeseriesItem!]

  """Number of chat messages per time chunk."""
  chatMessages: [TimeseriesItem!]

  """Number of clip views per time chunk."""
  clipViews: [TimeseriesItem!]

  """Number of clips created per time chunk."""
  clipsCreated: [TimeseriesItem!]

  """Number of follows during this timestamp."""
  follows: [TimeseriesItem!]

  """Granularity of the time series, default unit is five minutes."""
  granularity: Granularity!

  """Host/Raid viewers per time chunk."""
  hostRaidViewers: [TimeseriesItem!]

  """
  Deprecated: List of the number of follows within a time period, broken up by granularity.
  """
  items: [TimeseriesItem!] @deprecated(reason: "Use specific metric from user.timeseriesStats instead.")

  """Live number of views per time chunk."""
  liveViews: [TimeseriesItem!]

  """Max viewers per time chunk."""
  maxViewers: [TimeseriesItem!]

  """Minutes watched per time chunk."""
  minutesWatched: [TimeseriesItem!]

  """Number of subscriptions per time chunk."""
  newSubscriptions: [TimeseriesItem!]

  """Promotion clicks for the time period."""
  promotionClick: [TimeseriesItem!]

  """Promotion displays for the time period."""
  promotionDisplay: [TimeseriesItem!]

  """Time streamed per time chunk."""
  timeStreamed: [TimeseriesItem!]

  """Number of people chatting per time chunk."""
  uniqueChatters: [TimeseriesItem!]

  """Number of unique people watching per time chunk."""
  uniqueViewers: [TimeseriesItem!]
}

"""A piece of the shelf title in the form of a token."""
type TitleTokenEdge {
  """The token."""
  node: TitleTokenNode
}

"""The content of a shelf title token."""
union TitleTokenNode = DateToken | Game | IntegerToken | Tag | TextToken | User

input ToggleRitualsEnabledInput {
  channelID: ID!
  isEnabled: Boolean!
}

type ToggleRitualsEnabledPayload {
  """Whether the rituals feature is enabled for a channel."""
  isEnabled: Boolean!
  user: User
}

"""
Assets for a TokenBundleProduct.
Each asset will have a 1x, 2x, 3x sizing w/ their respective URLs.
Different sizing is required for mobile clients.
"""
type TokenBundleAsset {
  """URL of asset of size 1x."""
  imageURL1x: String!

  """URL of asset size 2x."""
  imageURL2x: String!

  """URL of asset size 3x."""
  imageURL3x: String!

  """
  Key identifier for an asset.
  ex) "bundleImg", "promoImg", etc.
  """
  key: String!
}

"""
Tournament is an object that contains all information about a tournament
managed within Bits for a specific event tied to cheering.
NOTE: Should have been named CheeringTournament.
"""
type Tournament {
  """Leaderboard of all users who have cheered in the tournament."""
  globalLeaderboard: BitsLeaderboard! @deprecated

  """Event ID of the tournament."""
  id: ID! @deprecated

  """
  The list of global milestones that can be claimed in the tournament.
  For a given threshold, this milestone is reached when cheers from all users on the channel
  is greater than or equal to the threshold. This unlocks a reward for all users who have cheered.
  """
  progress: TournamentProgress! @deprecated

  """
  The list of rewards that are a part of the tournament. This is separated out into global, participant, and individual
  rewards that can be claimed if the user is logged in.
  """
  rewards: TournamentRewards @deprecated

  """
  The list of individual milestones that can be claimed in the tournament.
  for a given threshold, this milestone is reached when an individual user's total cheers in
  the channel is greater than or equal to the threshold. This unlocks a reward
  for the individual user who cheered.
  """
  self: TournamentSelfEdge @deprecated

  """
  Leaderboard of all teams who have been cheered for in the tournament. This leaderboard contains how much each team
  in the tournament was cheered for.
  """
  teamLeaderboard: BitsLeaderboard! @deprecated

  """The list of teams participating in the tournament."""
  teams: [TournamentTeam]! @deprecated
}

"""Contains all rewards information about the Insider rewards."""
type TournamentInsiderRewards {
  """Twitch chat badge rewards."""
  badges: [TournamentReward!]! @deprecated

  """Bits rewards."""
  bits: [TournamentReward!]! @deprecated

  """Hero skin rewards."""
  heroSkins: [TournamentReward!]! @deprecated

  """
  In Game Content rewards, like sprays and avatars (non-hero skin rewards).
  """
  inGameContent: [TournamentReward!]! @deprecated
}

"""
Describes the amount of progress that has been made in a tournament, with corresponding milestones about said progress.
"""
type TournamentProgress {
  """
  The amount of progress that has been made in the tournament. This is not exclusive to cheering in the channel.
  """
  amount: Int! @deprecated

  """
  The milestones associated with the progress made. This is a list of rewards the progress value will unlock.
  """
  milestones: [Milestone!]! @deprecated
}

"""Type containing information about a Reward and claiming information."""
type TournamentReward {
  """The campaign ID associated with the reward."""
  campaignID: ID! @deprecated

  """Can this reward be entitled to the user."""
  canBeFulfilled: Boolean! @deprecated

  """
  Number representing quantity of the reward that user can claim (but not entitled yet) at the time the request is made.
  """
  canBeFulfilledQuantity: Int! @deprecated

  """The reward's description."""
  description: String! @deprecated

  """
  Number representing quantity of the reward that user already claimed and can
  find in his inventory. If the type is In Game Content, Twitch already handed
  off to the game through the fulfiller.
  """
  entitledQuantity: Int! @deprecated

  """The ID of the reward."""
  id: ID! @deprecated

  """The reward's display image URL."""
  imageURL: String! @deprecated

  """The state of the reward is entitled to the user."""
  isEntitled: Boolean! @deprecated

  """Whether the reward is for prime users only."""
  isPrimeOnly: Boolean! @deprecated

  """
  Whether the reward can be earned multiple times (e.g. in game consumables).
  """
  isRepeatable: Boolean! @deprecated

  """Metadata attached to the reward."""
  metadata: CampaignRewardMetadata @deprecated

  """The display name of the reward."""
  name: String! @deprecated

  """Amount of reward (e.g. amount for bits)."""
  quantity: Int! @deprecated

  """A number presenting the rarity of this reward (the higher the rarer)."""
  rarity: Int! @deprecated

  """The type of reward (ex. Twitch Emote, In Game Content)."""
  type: String! @deprecated
}

"""
This type holds all information about rewards that are associated with a tournament. The struct parses out
which rewards are Global, Team, and Individual, as well as if you're logged in that status if you can claim the reward.
"""
type TournamentRewards {
  """
  The list of Cheerbomb rewards. If the user is logged in, this will also show the claim status of the reward.
  """
  cheerbomb: [TournamentReward!]! @deprecated

  """
  The list of Global rewards. If the user is logged in, this will also show the claim status of the reward.
  """
  global: [TournamentReward!]! @deprecated

  """
  The list of Individual rewards. If the user is logged in, this will also show the claim status of the reward.
  """
  individual: [TournamentReward!]! @deprecated

  """
  The list of Insider rewards, which are granted when one subscribes to the insider pass.
  """
  insider: TournamentInsiderRewards! @deprecated

  """
  The list of Team rewards. If the user is logged in, this will also show the claim status of the reward.
  """
  team: [TournamentReward!]! @deprecated
}

"""Tournament progress related to a user."""
type TournamentSelfEdge {
  """
  The leaderboard entry of the user. Gives the current position and score.
  """
  globalLeaderboardItem: BitsLeaderboardItem @deprecated

  """
  Amount of progress a user had made towards the tournament personally. This could be a combination of factors,
  including bits cheered in the channel.
  """
  progress: TournamentProgress! @deprecated

  """
  A list of the amount of bits a user has cheered for a certain team, as well as the
  list of milestones that the user could claim with their claim status.
  """
  teams: [TournamentTeam!]! @deprecated
}

"""
Team is a construct that contains metadata about a team participating in the tournament,
as well as the milestones associated with cheering for them.
"""
type TournamentTeam {
  """
  The division of the team. This string is set by the tournament organizer. (NA, CN, Atlantic League, etc.).
  """
  division: String! @deprecated

  """The ID of the team."""
  id: ID! @deprecated

  """The image URL of the team."""
  logoURL: String! @deprecated

  """Name of the team."""
  name: String! @deprecated
}

"""TrackAppealRequestInput the details needs about which track to appeal."""
input TrackAppealRequestInput {
  """audibleMagicResponseID is the ID of the audible magic response."""
  audibleMagicResponseID: ID!

  """reason is the reason the track is being appealed."""
  reason: String!
}

"""Information used to track recommendation events."""
type TrackingInfo {
  """The target object for the shelf, if it exists."""
  reasonTarget: String

  """The type of the target object, if it exists."""
  reasonTargetType: String

  """The reason why this shelf has been recommended."""
  reasonType: String!

  """The name of the shelf."""
  rowName: String!
}

"""A tracking pixel is used to measure impressions or demographics."""
type TrackingPixel {
  """Where this pixel came from."""
  origin: String

  """What service will be using the pixel."""
  service: String!

  """How long a client needs to view the content before firing the pixel."""
  timeOffsetSeconds: Int

  """The type of tracker."""
  type: TrackingPixelType

  """The URL that is requested when the pixel is fired."""
  url: String!
}

"""The tracking pixel that will be created as part of this campaign."""
input TrackingPixelInput {
  """How long a client needs to view the content before firing the pixel."""
  timeOffsetSeconds: Int

  """The type of tracker."""
  type: TrackingPixelType

  """The URL that is requested when the pixel is fired."""
  url: String!
}

"""The type of the tracking pixel."""
enum TrackingPixelType {
  """Digital Ad Ratings, a Nielsen product that provides demographic data."""
  DAR

  """
  DoubleClick Campaign Manager, a Google product to track ad performance.
  """
  DCM

  """An impression tracking product."""
  SIZMEK
}

"""
A trailer is a video meant to introduce viewers to the creator and the type
of content they produce.
"""
type Trailer {
  """The trailer video. This may be null if the channel has no trailer."""
  video: Video
}

"""TranscodeSession is session metadata related to transcode."""
type TranscodeSession {
  """Transcoded audio codecs."""
  audioCodecs: String!

  """Staff-only field. Hostname of which transcode was processed."""
  host: String

  """Staff-only field. The location of transcode origin."""
  ingestOrigin: String

  """Staff-only field. Profile of transcode."""
  profile: String

  """Transcoded video codecs."""
  videoCodecs: String!
}

"""
TransitionExtensionStateError is an error associated with the transitionExtensionState mutation.
"""
enum TransitionExtensionStateError {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """
  The version does not have an asset hash and it must for the transition.
  """
  MISSING_ASSET_HASH

  """
  Review notes were not specified when transitioning an extension to IN_REVIEW.
  """
  MISSING_REVIEW_NOTES

  """
  Test channel was not specified when transitioning an extension to IN_REVIEW.
  """
  MISSING_TEST_CHANNEL

  """
  Only one version of an Extension can be in a review state (APPROVED, or in IN_REVIEW) at a time.
  """
  MULTIPLE_VERSIONS_IN_REVIEW

  """Author email cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_AUTHOR_EMAIL

  """Author name cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_AUTHOR_NAME

  """Category cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_CATEGORY

  """Support email cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_SUPPORT_EMAIL

  """Name cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_NAME

  """Version cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_VERSION

  """Testing base URI cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_TESTING_BASE_URI

  """Summary cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_SUMMARY

  """Description cannot be empty when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_DESCRIPTION

  """Screenshot URLs cannot be empy when transit to READY_FOR_REVIEW."""
  TRANSITION_MISSING_SCREENSHOT_URLS

  """Invalid state transition."""
  INVALID_STATE_TRANSITION

  """Version specified is invalid."""
  INVALID_VERSION

  """At least one anchor must be specified."""
  ANCHOR_REQUIRED

  """HasZoom was specified but ZoomPixels is missing."""
  INVALID_ZOOM

  """The number of whitelisted broadcasters exceeds the limit."""
  MAX_BROADCASTERS

  """The number of whitelisted testing users exceeds the limit."""
  MAX_TESTERS

  """The number of whitelisted config URLs exceeds the limit."""
  MAX_WHITELISTED_CONFIG_URLS

  """The number of whitelisted panel URLs exceeds the limit."""
  MAX_WHITELISTED_PANEL_URLS

  """Extension names must be shorter than 40 characters."""
  INVALID_NAME_LENGTH

  """Extension description must be shorter than 1024 characters."""
  INVALID_DESCRIPTION_LENGTH

  """Extension summary must be shorter than 140 characters."""
  INVALID_SUMMARY_LENGTH

  """
  Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_AUTHOR_EMAIL

  """
  Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_SUPPORT_EMAIL

  """Extension author name length must be > 40."""
  INVALID_AUTHOR_NAME_LENGTH

  """
  Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TESTING_BASE_URI

  """
  Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TERMS_URI

  """
  Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_PRIVACY_URI

  """
  Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_COMPONENT_VIEWER_PATH

  """
  Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_PANEL_VIEWER_PATH

  """
  Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_VIDEO_OVERLAY_VIEWER_PATH

  """
  Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_CONFIG_VIEWER_PATH

  """
  Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_LIVE_CONFIG_VIEWER_PATH

  """
  Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_MOBILE_VIEWER_PATH

  """Extension component aspect width must be < 50 or > 1."""
  INVALID_COMPONENT_ASPECT_WIDTH

  """Extension component aspect height must be < 50 or > 1."""
  INVALID_COMPONENT_ASPECT_HEIGHT

  """Extension panel hiehgt must be < 500 or > 100."""
  INVALID_PANEL_HEIGHT

  """
  Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
  """
  INVALID_BITS_SUPPORT_LEVEL

  """Scale pixels must be set to a positive integer when autoscale is true."""
  INVALID_SCALING_PIXELS

  """Aspect Ratio X must be set to a positive integer."""
  INVALID_COMPONENT_ASPECT_RATIO_X

  """Aspect Ratio Y must be set to a positive integer."""
  INVALID_COMPONENT_ASPECT_RATIO_Y

  """Target Height must be set to a positve integer."""
  INVALID_COMPONENT_TARGET_HEIGHT
}

"""
TransitionExtesnsionManifest updates the state of an existing extension.
"""
input TransitionExtensionStateInput {
  """The extension ID of the extension to update."""
  id: ID!

  """
  Notes provided to the moderation team while reviewing the extension.
  Required when transitioning to READY_FOR_REVIEW.
  """
  reviewNotes: String

  """The State to transition the extension to."""
  state: ExtensionState!

  """
  URL to a test channel, provided to the moderation team while reviewing the extension.
  Required when transitioning to READY_FOR_REVIEW.
  """
  testChannel: String

  """The extension version to update."""
  version: String!
}

"""
TransitionExtensionStatePayload returns any errors that occur during update.
"""
type TransitionExtensionStatePayload {
  """The error when the mutation fails to update an extension."""
  error: TransitionExtensionStateError

  """The updated extension manifest."""
  manifest: ExtensionManifest
}

"""A result of a try to trigger a drop on a channel."""
type TriggerResult {
  """The channel the drop was tried to be triggered on."""
  channel: Channel

  """The drop instance id in case the drop was successfully triggered."""
  dropInstanceID: ID

  """The status result of the try to trigger the drop."""
  status: ManuallyTriggerDropResultStatus!
}

"""Trigger type determines what type of events activate the trigger."""
enum TriggerType {
  """CHEER type trigger is activated by cheer events."""
  CHEER
}

"""
TrueXAd is descriptive information about an engagement that was show for bits.
Used as input on the redeem trueXAd mutation.
"""
input TrueXAd {
  """campaignID is the ID of the campaign this ad belongs to."""
  campaignID: ID!

  """
  creativeID is the ID of the particular ad experience displayed to the user.
  """
  creativeID: ID!

  """
  currencyAmount is the suggested amount of "currency" to provide to the user based on this ad.
  """
  currencyAmount: String!

  """name is the name of the ad campaign."""
  name: String!
}

"""
TutorialState represents the possible states of the user's viewing of the mod view tutorial.
"""
enum TutorialState {
  """DISMISSED occurs when a user dismisses the tutorial."""
  DISMISSED

  """SEEN occurs when a user has seen every step in a tutorial."""
  SEEN

  """
  UNSEEN is the initial state, before a user has either dismissed or viewed the tutorial entirely.
  """
  UNSEEN
}

"""Mosaic layouts for Twitch Studio."""
type TwitchStudioMosaicLayout implements ChannelDashboardLayout {
  """The actual Mosaic layout data to be stored or fetched."""
  data: MosaicData!

  """A unique identifier to uniquely reference this layout."""
  id: ID!

  """The display name for the layout shown to the user."""
  name: String!

  """
  A version to identify how the MosaicData was generated,
  such as for deprecation purposes.
  """
  version: String!

  """When the layout was last updated"""
  lastUpdated: Time
}

"""Two Factor Methods the user can have enabled."""
enum TwoFactorMethod {
  """
  The user has 2fa enabled but does not have the authy app installed. Only way
  for the user to receive the 2fa verification code is SMS.
  """
  AUTHY_SMS

  """
  The user has 2fa enabled and has the authy app installed. The 2fa verification
  code can be retreived from the authy app OR SMS.
  """
  AUTHY_APP

  """
  The user has 2fa enabled and has gone through the totp onboarding process
  successfully. The 2fa verification code can be retreived from the
  authenticator app the user chose during onboarding.
  """
  AUTHY_TOTP

  """unknown 2fa method."""
  UNKNOWN
}

"""
Used to provide info on the subscription events that might have happened in another device
and not acknowledged in the current device.
"""
type UnacknowledgedSubscriptionEvent {
  """The user of the channel the subscription was for."""
  channel: User

  """The time that the subscription benefits will expire."""
  endDate: Time

  """The external product id."""
  externalProductID: ID!

  """
  The current status of the subscription. One of "active", "will_not_renew", or "canceled".
  """
  status: UnacknowledgedSubscriptionEventState!

  """The UUID of the subscription."""
  subscriptionID: ID!
}

"""Subscrption state of the reported unacknowledged events."""
enum UnacknowledgedSubscriptionEventState {
  """The subscription is active."""
  ACTIVE

  """Subscription will not renew, but may still be active."""
  WILL_NOT_RENEW

  """Subscription will not renew and is not active."""
  CANCELLED

  """Subscription that is on hold."""
  ON_HOLD
}

"""
A request from a channel-banned user to the channel moderators to be unbanned
from the channel.
"""
type UnbanRequest {
  """The channel on which the banned user is appealing a ban."""
  channel: Channel

  """The time at which the unban request was created."""
  createdAt: Time!

  """UUID of the Unban Request."""
  id: ID!

  """The banned user appealing the ban."""
  requester: User

  """Custom message provided by the requester."""
  requesterMessage: String

  """The time at which the unban request was resolved (approved or denied)."""
  resolvedAt: Time

  """The moderator that has taken action on the user."""
  resolvedBy: User

  """Custom message provided by the resolver."""
  resolverMessage: String

  """The status of the unban request."""
  status: UnbanRequestStatus!
}

"""Paginated list of Unban Requests."""
type UnbanRequestConnection {
  """The elements of the list."""
  edges: [UnbanRequestEdge!]

  """Information about this page."""
  pageInfo: PageInfo!

  """Count of all pending unban requests."""
  totalCount(status: UnbanRequestStatus = NONE): Float
}

"""Element in a list of Unban Requests."""
type UnbanRequestEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The unban request."""
  node: UnbanRequest
}

"""Error returned from an update mutation."""
type UnbanRequestError {
  """The error code returned from an update mutation."""
  code: UnbanRequestErrorCode!
}

"""Possible errors arising from an update unban request mutation."""
enum UnbanRequestErrorCode {
  """
  User does not have the permissions required to update the Unban Request.
  """
  UNAUTHORIZED

  """Unban Request was not found."""
  REQUEST_NOT_FOUND

  """Attempted status update was not valid."""
  INVALID_UPDATE

  """Unknown error."""
  UNKNOWN
}

"""Reasons why a user may be restricted from requesting an unban."""
enum UnbanRequestRestrictionReason {
  """User has already created an unban request for the current ban."""
  ALREADY_CREATED

  """User is not banned on the channel."""
  NOT_BANNED

  """
  User is attempting to create a request too since their ban. Must wait for cooldown period to end.
  """
  TOO_SOON_SINCE_BAN

  """Channel is not receiving unban requests."""
  UNBAN_REQUESTS_DISABLED

  """User must be logged in to be able to request an unban."""
  UNAUTHENTICATED

  """Unknown restricted reason."""
  UNKNOWN
}

"""Optional filters that can be applied to an unban requests query."""
input UnbanRequestsOptions {
  """The order of the results, either oldest first or newest first."""
  order: UnbanRequestsSortOrder = NEWEST

  """Filter results to only requests of this status."""
  status: UnbanRequestStatus

  """Filter results to only requests from this user."""
  userID: ID
}

"""Set of preferences set by the channel owner regarding unban requests."""
type UnbanRequestsSettings {
  """
  The number of minutes after being banned before users can request an unban.
  """
  cooldownMinutes: Int!

  """Whether users can create requests on the channel or not."""
  isEnabled: Boolean!
}

"""Ways to sort Unban Requests."""
enum UnbanRequestsSortOrder {
  """The oldest request first."""
  OLDEST

  """The newest request first."""
  NEWEST
}

"""Possible statuses of an unban request."""
enum UnbanRequestStatus {
  """
  Default status. Is an invalid status state. Used as zero value when no specific status is specified.
  """
  NONE

  """Approved; user is unbanned from the channel."""
  APPROVED

  """User's unban request is denied; user remains banned in the channel."""
  DENIED

  """A moderator decision has not been made on the Unban Request."""
  PENDING

  """
  The user has had their unban request approved, and has acknowledged
  the rules on the channel.
  """
  ACKNOWLEDGED

  """The user has canceled their unban request."""
  CANCELED
}

type UnbanUserFromChatRoomError {
  code: UnbanUserFromChatRoomErrorCode!
}

enum UnbanUserFromChatRoomErrorCode {
  """User does not have permission to unban in channel."""
  FORBIDDEN

  """Target does not exist."""
  TARGET_NOT_FOUND

  """Target is not banned in channel."""
  TARGET_NOT_BANNED
}

input UnbanUserFromChatRoomInput {
  bannedUserLogin: String!
  channelID: ID!
}

type UnbanUserFromChatRoomPayload {
  """The new ban status of this user regarding the specified channel."""
  ban: ChatRoomBanStatus

  """Mutation error caused by the user input."""
  error: UnbanUserFromChatRoomError
}

input UnblockUserInput {
  """ID of user to unblock."""
  targetUserID: ID!
}

type UnblockUserPayload {
  """User that was unblocked."""
  targetUser: User!
}

"""Data required to undo recommendation feedback."""
input UndoRecommendationFeedbackInput {
  """The id of the feedback."""
  feedbackID: ID!

  """The page this event was fired from."""
  sourceItemPage: String!

  """The unique id given to this request."""
  sourceItemRequestID: ID!

  """The unique tracking id of the shelf / shelf card."""
  sourceItemTrackingID: ID!
}

"""Returns the created feedback item back to the client."""
type UndoRecommendationFeedbackPayload {
  """The id of the feedback you just undid."""
  feedbackID: ID!
}

"""UnfollowGameInput contains just the game ID of the game to unfollow."""
input UnfollowGameInput {
  gameID: ID!
}

"""UnfollowGamePayload is the response from unfollowing a game."""
type UnfollowGamePayload {
  """The deleted follow relationship, if one existed beforehand."""
  follow: GameFollow

  """
  The game that was unfollowed
  game.self.follow should now be null.
  """
  game: Game
}

input UnfollowUserInput {
  targetID: ID!
}

type UnfollowUserPayload {
  """The deleted follow relationship."""
  follow: Follow
}

input UnfriendUserInput {
  """
  The authenticated user will no longer be friends with the user whose ID is equal to targetID.
  """
  targetID: ID!
}

type UnfriendUserPayload {
  """
  The user whose friend relationship was just destroyed by the authenticated user.
  """
  user: User
}

"""UnhostInput contains the necessary inputs to unhost a channel."""
input UnhostInput {
  """Channel ID to unhost from."""
  channelID: ID!
}

"""UnhostPayload is the response after attempting to unhost."""
type UnhostPayload {
  """The channel that just unhosted."""
  channel: User
}

"""
UninstallExtensionError is wrapper for error associated with the uninstallExtension mutation.
"""
type UninstallExtensionError {
  """Error code."""
  code: UninstallExtensionErrorCode!
}

"""
UninstallExtensionErrorCode is an error code associated with UninstallExtensionError.
"""
enum UninstallExtensionErrorCode {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Channel id is invalid, for example, is empty."""
  INVALID_CHANNEL_ID

  """The extension is not installed on the channel."""
  EXTENSION_NOT_INSTALLED
}

"""The required input for an uninstallExtension mutation."""
input UninstallExtensionInput {
  """
  The composite ID of an extension installation <extensionID:version:channelID>.
  """
  extensionInstallationID: ID!
}

"""The resulting payload of an uninstallExtension mutation."""
type UninstallExtensionPayload {
  """The error when the mutation fails to set feature flags."""
  error: UninstallExtensionError

  """The id of the extension which was uninstalled."""
  id: ID!
}

"""
UnlinkAmazonConnectionInput represent the parameters necessary to unlink an amazon connection.
"""
input UnlinkAmazonConnectionInput {
  """Id of the user that wishes to unlink his amazon connection."""
  userID: ID
}

"""
UnlinkAmazonConnectionPayload indicates whether the unlinking was successful or not.
"""
type UnlinkAmazonConnectionPayload {
  """
  Whether or not the unlink operation was successful. Only reports if the
  underlying call was successful, as such will return true even if no unlinking
  occured (such as when as user doesn't have a linked amazon account, for instance).
  """
  isSuccess: Boolean
}

"""User ID input of the connection being deleted."""
input UnlinkRiotConnectionInput {
  """Twitch User ID to delete."""
  userID: ID!
}

"""Contains a struct of all current accounts connections."""
type UnlinkRiotConnectionPayload {
  """The complete account connections list where Riot will be null."""
  connections: AccountConnectionSet
}

input UnlinkSSOInput {
  """
  The single sign-on (SSO) app that should be unlinked from the authenticated user's account.
  """
  app: String!

  """The token that identifies the user on the linked SSO app."""
  token: String
}

type UnlinkSSOPayload {
  """The deleted SSO links."""
  links: [SSOLink!]
}

"""
Input for unlocking a chosen modified subscriber emote with Community Points.
"""
input UnlockChosenModifiedSubscriberEmoteInput {
  """The channel the emote is being redeemed on."""
  channelID: ID!

  """The client's perception of the reward's cost."""
  cost: Int!

  """The modified emote to unlock."""
  emoteID: ID!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""
The response from redeeming the unlock a chosen modified subscriber emote reward.
"""
type UnlockChosenModifiedSubscriberEmotePayload {
  """The user's new Community Points balance."""
  balance: Int

  """The error that occurred during redemption, if any."""
  error: CommunityPointsUnlockEmoteError
}

"""Input for unlocking a chosen subscriber emote with Community Points."""
input UnlockChosenSubscriberEmoteInput {
  """The channel the emote is being redeemed on."""
  channelID: ID!

  """The client's perception of the reward's cost."""
  cost: Int!

  """The emote to unlock."""
  emoteID: ID!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""
The response from redeeming the unlock a chosen subscriber emote reward.
"""
type UnlockChosenSubscriberEmotePayload {
  """The user's new Community Points balance."""
  balance: Int

  """The error that occurred during redemption, if any."""
  error: CommunityPointsUnlockEmoteError
}

"""Input for unlocking a random subscriber emote with Community Points."""
input UnlockRandomSubscriberEmoteInput {
  """The channel the emote is being redeemed on."""
  channelID: ID!

  """The client's perception of the reward's cost."""
  cost: Int!

  """
  Client-set identifier for the transaction. This ID should be universally unique.
  """
  transactionID: ID!
}

"""
The response from redeeming the unlock a random subscriber emote reward.
"""
type UnlockRandomSubscriberEmotePayload {
  """The user's new Community Points balance."""
  balance: Int

  """The random emote that was unlocked."""
  emote: CommunityPointsEmote

  """The error that occurred during redemption, if any."""
  error: CommunityPointsUnlockEmoteError
}

"""ModUserError contains details about a client error that occurred."""
type UnmodUserError {
  """The enum indicating what error has occurred."""
  code: UnmodUserErrorCode!
}

"""
UnmodUserErrorCode defines a client error that occurred while remove a moderator.
"""
enum UnmodUserErrorCode {
  """
  The requesting user does not have permission to add a moderator in this channel.
  """
  FORBIDDEN

  """The target user does not exist or has a suspended account."""
  TARGET_NOT_FOUND

  """The channel does not exist."""
  CHANNEL_NOT_FOUND

  """The target user is not a moderator."""
  TARGET_NOT_MOD
}

"""
UnmodUserInput contains the parameters to remove a user as a moderator to a channel.
"""
input UnmodUserInput {
  """The channel that the user will be removed as a moderator to."""
  channelID: ID!

  """
  The ID of the user that will be removed as a moderator.
  Either targetID or targetLogin must be provided.
  """
  targetID: ID

  """
  The login of the user that will be removed as a moderator.
  Either targetID or targetLogin must be provided.
  """
  targetLogin: String
}

"""UnmodUserPayload is the response when remove a user as a moderator."""
type UnmodUserPayload {
  """The channel that the user is removed as a moderator to."""
  channel: User

  """
  The client error that has occurred.
  Null if the operation is successful.
  """
  error: UnmodUserError

  """The user that is removed as a moderator."""
  target: User
}

"""
UnsetHypeTrainConfigInput takes series of optional config settings and unsets the custom value for the default..
"""
input UnsetHypeTrainConfigInput {
  """Custom emote to be rendered in Hype Train messaging."""
  calloutEmote: Boolean

  """Length of the cooldown period after a hype train ends."""
  cooldownPeriodMinutes: Boolean

  """The difficulty of hype train levels."""
  difficulty: Boolean

  """Hype Train kickoff settings."""
  eventsThreshold: Boolean

  """Whether hype train should be enabled."""
  isEnabled: Boolean

  """
  A boolean flag that indicates if the hype train settings should be personalized by Twitch.
  """
  shouldUsePersonalizedSettings: Boolean

  """Use creator color as base color of the Hype Train progress bar."""
  willUseCreatorColor: Boolean
}

"""
UnsetHypeTrainConfigPayload is the response that contains the Unsetd config.
"""
type UnsetHypeTrainConfigPayload {
  """The hype train config for the channel."""
  config: HypeTrainConfig
}

"""
Input to the unsubscribe mutation. One of "channel" or "type" fields must be provided.
"""
input UnsubscribeEmailInput {
  """The unique ID of the origin email."""
  sourceEmailID: String!

  """The email type of the origin email."""
  sourceEmailType: String!

  """ID of the channel whose notifications should be blocked."""
  targetChannelID: ID

  """The email type from which the user is unsubscribing."""
  targetEmailType: String

  """ID of the user requesting the unsubscribe action."""
  userID: ID!

  """Server signature to verify authenticity of the link author."""
  validatingHash: String!
}

"""Output from the unsubscribe mutation."""
type UnsubscribeEmailPayload {
  """Specifies whether the action was successful."""
  isSuccess: Boolean!
}

"""Inputs to the updateAdProperties mutation."""
input UpdateAdPropertiesInput {
  """Toggle for disable prerolls for midrolls feature."""
  hasDisablePrerollsAbilityEnabled: Boolean

  """
  Toggle for disable prerolls for midrolls notifcations.
  The "Disable Prerolls" product is a way for streamers to disable preroll ads by running midroll ads.
  The streamer can choose to enable notifications (ie. "Preroll Ads are now disabled for X minutes") for this product.
  """
  hasDisablePrerollsNotificationsEnabled: Boolean

  """Toggle for enable multiplayer ads for subs."""
  isMultiplayerAdsForSubsEnabled: Boolean

  """User the update belongs to."""
  targetUserID: ID!
}

"""Output from the updateAdProperties mutation."""
type UpdateAdPropertiesPayload {
  """User/channel to update the ad settings."""
  targetUser: User
}

"""Inputs for updating all videos viewability by channel id mutation."""
input UpdateAllChannelVideosViewabilityInput {
  """The ID of the channel to update all videos from."""
  channelID: ID!

  """Determines viewability of all the channels videos."""
  scope: VideoPrivacyScope!
}

"""
The returned payload from the UpdateAllChannelVideosViewability mutation.
"""
type UpdateAllChannelVideosViewabilityPayload {
  """The status for this mutation."""
  status: UpdateAllChannelVideosViewabilityStatus
}

"""Status associated with mutation UpdateAllChannelVideosViewability."""
type UpdateAllChannelVideosViewabilityStatus {
  """Error code."""
  code: UpdateAllChannelVideosViewabilityStatusCode!
}

"""The status codes for this mutation."""
enum UpdateAllChannelVideosViewabilityStatusCode {
  """Update job was successful started."""
  SUCCESS

  """User does not have permission to update videos."""
  FORBIDDEN

  """Internal error."""
  INTERNAL_ERROR

  """Invalid Argument."""
  INVALID_ARGUMENT

  """Unknown Error."""
  UNKNOWN
}

input UpdateAllWhisperThreadsInput {
  markAllAsRead: Boolean
}

type UpdateAllWhisperThreadsPayload {
  count: Int!
}

"""UpdateAutohostSettingsInput update a user's autohost settings."""
input UpdateAutohostSettingsInput {
  """True if this channel has the autohost feature turned on."""
  isEnabled: Boolean

  """The strategy to use when choosing channels to autohost."""
  strategy: AutohostSettingsStrategy

  """UserID to update settings for."""
  userID: ID!

  """True if this user autohosts their team members."""
  willAutohostTeam: Boolean

  """True if this channels prefers autohost over vodcast."""
  willPrioritizeAutohost: Boolean
}

"""
UpdateAutohostSettingsPayload returns the user whose settings had been updated.
"""
type UpdateAutohostSettingsPayload {
  """User whose autohost settings has been updated."""
  user: User
}

"""
Defines AutoMod category level settings for a Channel, either overallLevel or detailedAutoModLevels should be non null.
"""
input UpdateAutoModLevelsInput {
  """String ID of the channel AutoModProperties are being updated for."""
  channelID: ID!

  """
  This field represents the detailed AutoMod category settings, which may map to an overallLevel.
  """
  detailedLevels: DetailedAutoModLevelsInput

  """
  This field will be a value between 0 and 4, inclusive, it is not required.
  """
  overallLevel: Int
}

"""Defines the new AutoMod levels of a channel."""
type UpdateAutoModLevelsPayload {
  """The new levels after applying the mutation."""
  autoModConfiguration: AutoModConfiguration
}

input UpdateAutoModPropertiesInput {
  """These fields should be values between 0 and 6 inclusive."""
  aggressiveLevel: Int!

  """String ID of the channel AutoModProperties are being updated for."""
  channelID: String!
  identityLevel: Int!
  profanityLevel: Int!
  sexualLevel: Int!
}

type UpdateAutoModPropertiesPayload {
  """The new properties after applying the mutation."""
  autoModProperties: AutoModProperties
}

"""
UpdateBitsBadgeTierNotificationInput is the input required when updating a bits badge tier notification.
"""
input UpdateBitsBadgeTierNotificationInput {
  """
  Optional message to send when sharing notification. If supplied, will accompany user notice.
  """
  message: String

  """Unique Identifier for the notification."""
  notificationID: ID!

  """New state for notification."""
  notificationState: BitsBadgeTierNotificationState!
}

"""
UpdateBitsBadgeTierNotificationPayload is the payload returned after updating a bits badge tier notification.
"""
type UpdateBitsBadgeTierNotificationPayload {
  """The user that updated the bits badge tier notification."""
  user: User
}

"""Errors for updating bits badges."""
type UpdateBitsBadgeTiersError {
  """The associated error code."""
  code: UpdateBitsBadgeTiersErrorCode!
}

"""Possible error codes returned for updating bits badges."""
enum UpdateBitsBadgeTiersErrorCode {
  """Invalid parameters in the request."""
  INVALID_PARAMETER

  """Badge title is too long."""
  BADGE_TITLE_EXCEEDS_CHARACTER_LIMIT

  """Badge title did not pass moderation check."""
  BADGE_TITLE_FAILED_MODERATION

  """The emote code submitted collides with an existing emote code."""
  EMOTE_CODE_ALREADY_EXISTS

  """
  The emote code submitted is unacceptable (contains offensive, banned, or "bad" words, which violates guidelines).
  """
  EMOTE_CODE_UNACCEPTABLE

  """Data for least one of the image sizes is not provided."""
  INCOMPLETE_BADGE_IMAGE_DATA

  """Other errors returned from the service."""
  UNKNOWN_ERROR
}

"""Settings related to bits badges."""
input UpdateBitsBadgeTiersInput {
  """A list of bits badge tiers to be modified."""
  tiers: [BitsBadgeTierInput!]

  """The owner ID of the channel that the badge tiers belong to."""
  userID: ID!
}

"""Results of bits badge tier updates."""
type UpdateBitsBadgeTiersPayload {
  """
  Whether or not the broadcaster is enabled to upload bits badge tier emote rewards.
  """
  canUploadBadgeTierEmoticons: Boolean

  """Service error, if any."""
  error: UpdateBitsBadgeTiersError

  """Updated bits badge tiers."""
  tiers: [BitsBadgeTier!]
}

"""Error code for an error that occurs while updating boost settings."""
type UpdateBoostSettingsError {
  """Error code for error that occurred while updating boost settings."""
  code: UpdateBoostSettingsErrorCode!
}

"""Error types recognized."""
enum UpdateBoostSettingsErrorCode {
  """Invalid parameter in the request."""
  INVALID_PARAMETER

  """Internal error being returned from service."""
  INTERNAL_ERROR
}

"""The required input for a updateBoostSettings mutation."""
input UpdateBoostSettingsInput {
  """
  The Id of the channel where we want to update the boost enable/disable settings.
  """
  channelID: ID!

  """Whether the channel has enabled boost challenges."""
  isEarnedEnabled: Boolean

  """Whether the channel has enabled boosts."""
  isEnabled: Boolean

  """Whether the channel has enabled boosts paid for by the community."""
  isPaidEnabled: Boolean
}

"""The result of an updateBoostSettings mutation."""
type UpdateBoostSettingsPayload {
  """The updated channel."""
  channel: Channel

  """The possible error returned from the service."""
  error: UpdateBoostSettingsError
}

"""Possible error codes returned from updating broadcast settings."""
enum UpdateBroadcastSettingsErrorCode {
  """User is not authorized to update broadcast settings for this channel."""
  AUTH_FAILURE

  """Too many attempts to update broadcast settings."""
  REQUESTS_THROTTLED

  """Language is invalid."""
  LANGUAGE_NOT_VALID

  """Streaming status is too long."""
  STATUS_TOO_LONG

  """Streaming status uses banned words."""
  STATUS_USES_BANNED_WORDS

  """Game name is too long."""
  GAME_NAME_TOO_LONG

  """Unrecognized error returned from the backend service."""
  UNKNOWN_ERROR
}

"""The required input for a updateBroadcastSettings mutation."""
input UpdateBroadcastSettingsInput {
  """Indicate broadcaster's streaming language."""
  broadcasterLanguage: String

  """The title of the game that the broadcaster is playing."""
  game: String

  """The isMature boolean to set onto the user broadcast."""
  isMature: Boolean

  """Channel's streaming Status."""
  status: String

  """The Id of the user whose broadcast setting is being updated."""
  userID: ID!
}

"""The result of a updateBroadcastSettings mutation."""
type UpdateBroadcastSettingsPayload {
  """The modified broadcast settings."""
  broadcastSettings: BroadcastSettings

  """Error from updating broadcast settings, if any."""
  error: UpdateBroadcastSettingsErrorCode
}

"""Inputs for updating the user's celebration config."""
input UpdateCelebrationConfigInput {
  """ID of channel to update the celebration config."""
  channelID: ID!

  """If turn, celebrations are enabled on the channel."""
  isEnabled: Boolean!
}

"""Outputs from the update celebration config mutation."""
type UpdateCelebrationConfigPayload {
  """The updated celebration config."""
  celebrationConfig: CelebrationConfig

  """If present, there was an error with the request."""
  error: CelebrationError
}

"""Inputs for creating a new celebration."""
input UpdateCelebrationInput {
  """Where on the channel page the celebration will show."""
  area: CelebrationArea

  """ID of celebration to update."""
  celebrationID: ID!

  """ID of channel where the celebration to update exists."""
  channelID: ID!

  """Length the celebration will play."""
  durationMilliseconds: Int

  """Effect which will show when the celebration triggers (ex Fireworks)."""
  effect: CelebrationEffect

  """Threshold which will trigger the celebration (ex: Cheering 100 Bits)."""
  eventThreshold: Int

  """Event type which will trigger the celebration (ex: Cheering Bits)."""
  eventType: CelebrationEventType

  """
  Intensity of the celebration.
  Should be bounded (TBA) value which will determine the spectacle of the celebration.
  """
  intensity: Int

  """If true, the celebration is enabled."""
  isEnabled: Boolean
}

"""Outputs from the Update celebration mutation."""
type UpdateCelebrationPayload {
  """The updated celebration."""
  celebration: Celebration

  """If present, there was an error with the request."""
  error: CelebrationError
}

"""Inputs for updating the user's celebration product config."""
input UpdateCelebrationProductConfigInput {
  """List of celebrations products for purchase in the channel."""
  celebrationProducts: [CelebrationProductConfigInput!]!

  """ID of channel to update the celebration product config."""
  channelID: ID!
}

"""Outputs from the updated celebration product config mutation."""
type UpdateCelebrationProductConfigPayload {
  """The updated celebration products."""
  celebrationProducts: [CelebrationProduct!]

  """If present, there was an error with the request."""
  error: CelebrationError
}

"""Inputs for updating the user's celebration user settings."""
input UpdateCelebrationUserSettingsInput {
  """If true, celebrations are disabled for the user to see."""
  isOptedOut: Boolean
}

"""Outputs from the update celebration config mutation."""
type UpdateCelebrationUserSettingsPayload {
  """The updated logged in user."""
  currentUser: User
}

"""The result of a UpdateChangelogReadTimePayload mutation."""
type UpdateChangelogReadTimePayload {
  """The user whose changelog was marked as read."""
  user: User
}

"""Mutation input for updating chanlet content attributes."""
input UpdateChanletContentAttributesInput {
  """Identifier of the chanlet."""
  chanletID: ID!

  """
  A list of multi-view content attribute IDs.
  The provided list will override the list of IDs currently stored.
  """
  contentAttributeIDs: [ID!]
}

"""Response payload."""
type UpdateChanletContentAttributesPayload {
  """Updated chanlet."""
  chanlet: Channel
}

"""The possible error returned."""
enum UpdateChannelCategoryShelfError {
  """The user making the update is not authorized to do so."""
  FORBIDDEN

  """One or more of the category IDs in the input are invalid."""
  INVALID_CATEGORY

  """The same category ID cannot be both shown and hidden."""
  CANNOT_SHOW_AND_HIDE_CATEGORY
}

"""The required input for a updateChannelClipsSetting mutation."""
input UpdateChannelClipsSettingInput {
  """
  The Id of the channel where we want to update the clips enable/disable setting.
  """
  channelID: ID!

  """
  If isClipsEnabled is true, allow the following roles to create Clips on the channel.
  """
  creationRestrictedTo: ChannelClipsCreationRestrictedToInput

  """
  If there are clip creation restrictions, use the following to add options to those restrictions.
  """
  creationRestrictionOptions: ChannelClipsCreationAuthRestrictionOptionsInput

  """Set whether or not users can create Clips on this channel."""
  isClipsEnabled: Boolean!
}

"""The result of a updateChannelClipsSetting mutation."""
type UpdateChannelClipsSettingPayload {
  """The updated channel."""
  channel: Channel
}

"""The input to update a channel's category shelf content."""
input UpdateChannelHomePreferencesInput {
  """A list of category IDs to hide from the category shelf."""
  categoryIDsToHide: [ID!]

  """A list of category IDs to unhide from the category shelf."""
  categoryIDsToUnhide: [ID!]

  """The ID of the channel whose category shelf is being updated."""
  channelID: ID!

  """The hero preset."""
  heroPreset: HeroPreset

  """The type of streamer shelf to display."""
  streamerShelfType: StreamerShelfType
}

"""The result of an update to the category shelf."""
type UpdateChannelHomePreferencesPayload {
  """The channel with the modified category shelf."""
  channel: Channel

  """The possible error returned."""
  error: UpdateChannelCategoryShelfError
}

"""An error returned from the updateChannelPredictionSettings mutation."""
type UpdateChannelPredictionSettingsError {
  """Code describing the error."""
  code: UpdateChannelPredictionSettingsErrorCode!
}

"""
Possible error codes from the updateChannelPredictionSettings mutation.
"""
enum UpdateChannelPredictionSettingsErrorCode {
  """
  The authorized user is not allowed to update prediction settings for this channel.
  """
  FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""
Update a channel's Prediction Settings.
All fields other than channelID are nullable; only specify fields that you wish to update.
"""
input UpdateChannelPredictionSettingsInput {
  """
  Whether channel moderators are allowed to create and resolve Prediction Events.
  """
  canModeratorsManagePredictions: Boolean

  """The ID of the channel to update the settings of."""
  channelID: ID!
}

"""Payload for updating a channel's Prediction Settings."""
type UpdateChannelPredictionSettingsPayload {
  """If present, there was an error with the request."""
  error: UpdateChannelPredictionSettingsError

  """The updated settings."""
  settings: ChannelPredictionSettings
}

input UpdateChatColorInput {
  """
  Named color for normal users (e.g. "Blue"  or "Coral", see https://help.twitch.tv/customer/portal/articles/659095-twitch-chat-and-moderation-commands)
  or a hex color for Turbo users (e.g. "#001122").
  """
  color: String!
}

type UpdateChatColorPayload {
  """The user whose chat color was set."""
  user: User
}

"""
Possible chat settings modifiable for the channel specified via ChannelID.

NOTE: Subscribers-only chat mode settings are in the UpdateSubscriptionProduct
mutation.
"""
input UpdateChatSettingsInput {
  """
  autoModLevel is an integer from 0-4 representing the level of automoderation of chat
  0 is off, 4 is the highest level of moderation.
  
  Deprecated: No longer used.
  """
  autoModLevel: Int

  """ID of the channel for which chat settings are being updated."""
  channelID: String!

  """chatDelayInMs is the delay before non-mods see a message."""
  chatDelayInMs: Int

  """
  followersOnlyDurationMinutes is the number of minutes a user must have
  followed the broadcaster before being able to chat.
  """
  followersOnlyDurationMinutes: Int

  """hideLinks indicates if links should be deleted from non-mod messages."""
  hideLinks: Boolean

  """
  isBroadcasterLanguageModeEnabled indicates if the broadcaster requires chat messages to
  match their language.
  
  Deprecated: No longer used.
  """
  isBroadcasterLanguageModeEnabled: Boolean

  """
  Indicates whether chat is currently enforcing that messages may only contain
  emotes.
  """
  isEmoteOnlyModeEnabled: Boolean

  """
  If isOptedOutOfGlobalBannedWordsList is true, the legacy twitch banned words list will
  be inserted into automod if the channel has automod enabled.
  
  Deprecated: No longer used.
  """
  isOptedOutOfGlobalBannedWordsList: Boolean

  """
  Indicates whether chat is currently enforcing that messages must be
  reasonably unique from recent messages. Previously known as "r9k mode".
  """
  isUniqueChatModeEnabled: Boolean

  """requireVerifiedAccount indicates if users must be verified to chat."""
  requireVerifiedAccount: Boolean

  """A list of chat rules to display to users when joining a chat channel."""
  rules: [String!]

  """
  The number of seconds a user must wait in between sending chat messages
  If value is null, slow mode is not enabled.
  """
  slowModeDurationSeconds: Int
}

"""Result of mutation is the updated ChatSettings object."""
type UpdateChatSettingsPayload {
  """The new chatSettings after applying the mutation."""
  chatSettings: ChatSettings
}

"""Errors for updating a cheermote tier."""
type UpdateCheermoteTierError {
  """The associated error code."""
  code: UpdateCheermoteTierErrorCode!
}

"""Possible error codes returned for updating a cheermote tier."""
enum UpdateCheermoteTierErrorCode {
  """Only the cheermote owner is allowed to upload cheermotes."""
  INVALID_OWNER

  """The uploaded image assets could not be parsed."""
  INVALID_IMAGE_UPLOAD

  """The uploaded image assets could not be found."""
  EMOTE_IMAGE_NOT_FOUND

  """There were not enough image assets supplied for the cheermote."""
  NOT_ENOUGH_EMOTE_IMAGE_ASSETS

  """There were more image assets supplied than required for the cheermote."""
  TOO_MANY_EMOTE_IMAGE_ASSETS

  """
  A static image asset was not supplied, but is required for the cheermote.
  """
  EMOTE_MISSING_STATIC_ASSET

  """
  An animated image asset was not supplied, but is required for the cheermote.
  """
  EMOTE_MISSING_ANIMATED_ASSET

  """Other errors returned from the service."""
  UNKNOWN_ERROR
}

"""
The data needed to update or create a broadcaster's custom cheermotes for a given tier.
"""
input UpdateCheermoteTierInput {
  """
  A list containing the image IDs for all assets needed for the cheermote tier.
  """
  imageAssets: [EmoteImageAssetInput!]!

  """The cheermote tier that should be updated."""
  tierThreshold: CheermoteTierThreshold!

  """The user whose cheermotes are being updated."""
  userID: ID!
}

"""Results of the cheermote tier update."""
type UpdateCheermoteTierPayload {
  """Service error, if any."""
  error: UpdateCheermoteTierError
}

"""Partner settings related to chat badges with bits."""
input UpdateCheerPartnerSettingsBadgesInput {
  """A list of tiers to modify."""
  tiers: [BitsBadgeTierInput!]
}

"""Partner settings related to chat messages with bits."""
input UpdateCheerPartnerSettingsChatMessageInput {
  """
  The setting that controls if the user has project v enabled on their channel.
  """
  isOptedOutOfProjectV: Boolean

  """
  The minimnm setting that controls the minimum bits that must be part of a cheer emote.
  """
  minBitsPerEmote: Int

  """
  The minimum setting that controls the minimum amount a user must cheer in the channel.
  """
  minBitsToCheer: Int
}

"""Settings related to bits cheer bomb events."""
input UpdateCheerPartnerSettingsCheerBombInput {
  """Flag that is true if the user has opted out of the cheer bomb event."""
  isOptedOut: Boolean
}

"""Partner settings related to the custom cheermote prefix."""
input UpdateCheerPartnerSettingsCustomPrefixInput {
  """Flag that is set if the user has the custom cheermote prefix enabled."""
  isEnabled: Boolean
}

"""Mutation input for updating Bits partner channel settings."""
input UpdateCheerPartnerSettingsInput {
  """Partner settings related to chat badges with bits."""
  badges: UpdateCheerPartnerSettingsBadgesInput

  """Partner settings related to chat messages with bits."""
  chatMessage: UpdateCheerPartnerSettingsChatMessageInput

  """Partner settings related to cheer bomb events."""
  cheerBombEvent: UpdateCheerPartnerSettingsCheerBombInput

  """Partner settings related to the custom cheermote prefix."""
  customPrefix: UpdateCheerPartnerSettingsCustomPrefixInput

  """Whether to onboard or offboard the user with bits."""
  isOnboarded: Boolean

  """Partner settings related to the bits leaderboard."""
  leaderboard: UpdateCheerPartnerSettingsLeaderboardInput

  """Partner settings related to the recent cheer message."""
  recentCheer: UpdateCheerPartnerSettingsRecentCheerInput

  """Partner settings related to sponsored cheermote campaigns."""
  sponsoredCheermote: UpdateCheerPartnerSettingsSponsoredCheermoteInput

  """The user ID to update channel settings."""
  userID: ID!
}

"""Partner settings related to the bits leaderboard."""
input UpdateCheerPartnerSettingsLeaderboardInput {
  """Flag that is true if the user has bits leaderboards turned on."""
  isEnabled: Boolean

  """The time period the user wants the leaderboard to be displayed as."""
  timePeriod: String
}

"""Result of mutation is the updated UserSettings object."""
type UpdateCheerPartnerSettingsPayload {
  """The updated user settings object."""
  cheer: CheerPartnerSettings!
}

"""Partner settings related to the recent cheer message."""
input UpdateCheerPartnerSettingsRecentCheerInput {
  """Flag that when true pins the recent cheer to their channel."""
  canPin: Boolean

  """
  The minimum bits a user must cheer to show their cheer on the chat header.
  """
  minimumBits: Int

  """The amount of time a recent cheer is shown before being dismissed."""
  timeoutMilliseconds: Int
}

"""Settings related to sponsored cheermote campaigns."""
input UpdateCheerPartnerSettingsSponsoredCheermoteInput {
  """The campaign ID we are modifying for the user."""
  id: ID!

  """
  Flag that is true if the user has opted in of the sponsored cheermote campaign.
  """
  isOptedIn: Boolean!
}

"""UpdateClipError is an error associated with the updateClip mutation."""
type UpdateClipError {
  """The error when the clip fails to update a clip."""
  message: String
}

"""UpdateClipInput updates the title of the clip with the provided slug."""
input UpdateClipInput {
  """The slug of the clip to update."""
  slug: ID!

  """The new title of the clip."""
  title: String
}

"""UpdateClipPayload returns the updated clip."""
type UpdateClipPayload {
  """The clip with its updated properties."""
  clip: Clip!

  """The error when the clip fails to update a clip."""
  error: UpdateClipError
}

"""
UpdateClipViewCountInput increments the viewcount of the provided slug.
"""
input UpdateClipViewCountInput {
  """The slug of the clip to increment viewcount on."""
  slug: ID!
}

"""UpdateClipViewCount returns the clip that was updated."""
type UpdateClipViewCountPayload {
  """
  The clip that was updated.
  The views field is the only field that is updated, and the change is not reflected immediately.
  """
  clip: Clip
}

"""
UpdateCollectionInput accepts a collection ID and parameters to update a collection.
"""
input UpdateCollectionInput {
  """The id of the collection to be updated."""
  collectionID: ID!

  """The updated description of the collection."""
  description: String

  """The itemID of the item whose thumbnail will be collection's thumbnail."""
  thumbnailInput: UpdateCollectionThumbnailInput

  """The updated title of the collection."""
  title: String

  """The updated type of the collection."""
  type: CollectionType
}

"""UpdateCollectionPayload resolves the updated collection."""
type UpdateCollectionPayload {
  """The collection that was just updated."""
  collection: Collection!
}

"""
UpdateCollectionThumbnailInput accepts a item ID and item Type for the new collection's thumbnail.
"""
input UpdateCollectionThumbnailInput {
  """The id of the item whose thumbnail will be collection's thumbnail."""
  id: ID!

  """The type of the item whose thumbnail will be collection's thumbnail."""
  type: String!
}

"""
An error from updating an automatic Community Points reward in a channel.
"""
type UpdateCommunityPointsAutomaticRewardError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsAutomaticRewardErrorCode

  """On COST_TOO_LOW, the minimum cost that can be set."""
  minimumCost: Int
}

"""
The possible reasons updating an automatic Community Points reward in a channel could fail.
"""
enum UpdateCommunityPointsAutomaticRewardErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """The current user is not allowed to update a reward in this channel."""
  FORBIDDEN

  """The cost is below the minimum."""
  COST_TOO_LOW

  """The cost is invalid. Must be a positive integer."""
  COST_INVALID

  """
  The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
  """
  BACKGROUND_COLOR_INVALID
}

"""
Input for updating an automatic Community Points reward in a channel.
Only the channelID and rewardType are required. All other fields are optional.
Only set fields that are intended to be updated.
"""
input UpdateCommunityPointsAutomaticRewardInput {
  """
  The optional custom background color for this reward.
  Should be a hex color string, for example "FF0000".
  """
  backgroundColor: String

  """The channel ID that the reward is being updated in."""
  channelID: ID!

  """The point cost of this reward."""
  cost: Int

  """Whether the reward is enabled."""
  isEnabled: Boolean

  """The ID of the reward being updated."""
  rewardType: CommunityPointsAutomaticRewardType!

  """A flag to reset this automatic reward's background color to default."""
  shouldResetBackgroundColor: Boolean

  """A flag to reset this automatic reward's cost to default."""
  shouldResetCost: Boolean

  """A flag to reset this automatic reward's image to default."""
  shouldResetImage: Boolean
}

"""
The response from updating an automatic Community Points reward in a channel.
"""
type UpdateCommunityPointsAutomaticRewardPayload {
  """
  An error that occurred while updating an automatic Community Points reward in a channel.
  """
  error: UpdateCommunityPointsAutomaticRewardError

  """The newly updated reward."""
  reward: CommunityPointsAutomaticReward
}

"""An error from updating a channel's Community Points channel settings."""
type UpdateCommunityPointsChannelSettingsError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsChannelSettingsErrorCode
}

"""
The possible reasons updating a channel's Community Points channel settings could fail.
"""
enum UpdateCommunityPointsChannelSettingsErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """The current user is not allowed to update this channel's settings."""
  FORBIDDEN

  """The custom name failed AutoMod."""
  NAME_AUTOMOD_FAILED
}

"""
Input for updating Community Points channel settings..
Only the channelID is required. All other fields are optional.
Only set fields that are intended to be updated.
"""
input UpdateCommunityPointsChannelSettingsInput {
  """The channel ID to update the settings of."""
  channelID: ID!

  """Whether the channel has community points turned on."""
  isEnabled: Boolean

  """The channel's custom community points name."""
  name: String

  """A flag to reset this channel's community points image to default."""
  shouldResetImage: Boolean

  """A flag to reset this channel's community points name to default."""
  shouldResetName: Boolean
}

"""
The response from updating a channel's Community Points channel settings.
"""
type UpdateCommunityPointsChannelSettingsPayload {
  """The channel with the newly updated settings."""
  channel: Channel

  """
  An error that occurred while updating a channel's Community Points channel settings.
  """
  error: UpdateCommunityPointsChannelSettingsError
}

"""Update community goal error."""
type UpdateCommunityPointsCommunityGoalError {
  """The error code."""
  code: UpdateCommunityPointsCommunityGoalErrorCode!
}

"""Update community goal error code."""
enum UpdateCommunityPointsCommunityGoalErrorCode {
  """Goal already exists."""
  DUPLICATE_GOAL

  """Goal title failed automod."""
  TITLE_AUTOMOD_FAILED

  """Goal title is invalid."""
  TITLE_INVALID

  """Goal description failed automod."""
  DESCRIPTION_AUTOMOD_FAILED

  """Goal description is invalid."""
  DESCRIPTION_INVALID

  """Goal amount is invalid."""
  GOAL_AMOUNT_INVALID

  """Goal duration is invalid."""
  DURATION_INVALID

  """Goal background color is invalid."""
  BACKGROUND_COLOR_INVALID

  """Goal cannot be updated since it has already been started."""
  GOAL_STARTED

  """Goal status change invalid."""
  INVALID_STATUS_CHANGE

  """Goal was not found."""
  NOT_FOUND

  """The current user is not allowed to update goals for this channel."""
  FORBIDDEN

  """An unknown error occurred."""
  UNKNOWN
}

"""Update community goal input."""
input UpdateCommunityPointsCommunityGoalInput {
  """The amount of community points that this goal needs to succeed."""
  amountNeeded: Int

  """The background color of this goal."""
  backgroundColor: String

  """The channel."""
  channelID: ID!

  """The description of this goal."""
  description: String

  """
  The *initial* duration the streamer set for the goal.
  Only really used during the UNSTARTED state; once the goal is started
  the endedAt timestamp is populated (and updated for extended deadlines).
  """
  durationDays: Int

  """The time the goal is scheduled to end. Used to extend a goal."""
  endsAt: Time

  """The id of the goal."""
  goalID: ID!

  """Reset background color to default if true."""
  resetBackgroundColor: Boolean

  """Reset image to default if true."""
  resetImage: Boolean

  """Reset max contribution per stream to default if true."""
  resetMaxContributionPerStream: Boolean

  """The current status of this goal."""
  status: CommunityPointsCommunityGoalStatus

  """The title of this goal."""
  title: String
}

"""Update community goal payload."""
type UpdateCommunityPointsCommunityGoalPayload {
  """The error, if any."""
  error: UpdateCommunityPointsCommunityGoalError

  """The community goal."""
  goal: CommunityPointsCommunityGoal
}

"""An error from updating a custom Community Points reward in a channel."""
type UpdateCommunityPointsCustomRewardError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsCustomRewardErrorCode!
}

"""
The possible reasons updating a custom Community Points reward in a channel could fail.
"""
enum UpdateCommunityPointsCustomRewardErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """The current user is not allowed to update a reward in this channel."""
  FORBIDDEN

  """The reward was not found."""
  NOT_FOUND

  """The title failed AutoMod."""
  TITLE_AUTOMOD_FAILED

  """The prompt failed AutoMod."""
  PROMPT_AUTOMOD_FAILED

  """The cost is invalid. Costs must be greater than 0."""
  COST_INVALID

  """The maxPerStream is invalid. maxPerStream must be greater than 0."""
  MAX_PER_STREAM_INVALID

  """
  The title is invalid. Titles must not be empty and must be at most 45 characters long.
  """
  TITLE_INVALID

  """
  The background color is invalid. Backgrounds must be a valid hex color, for example "FF0000".
  """
  BACKGROUND_COLOR_INVALID

  """
  A reward with the provided title already exists. Custom reward titles must be unique.
  """
  DUPLICATE_REWARD

  """
  The maxPerUserPerStream is invalid. maxPerUserPerStream must be greater than 0.
  """
  MAX_PER_USER_PER_STREAM_INVALID

  """The globalCooldown is invalid. globalCooldown must be greater tham 0."""
  GLOBAL_COOLDOWN_INVALID
}

"""
Input for updating a custom Community Points reward in a channel.
Only the channelID and rewardID are required. All other fields are optional.
Only set fields that are intended to be updated.
"""
input UpdateCommunityPointsCustomRewardInput {
  """
  The optional custom background color for this reward.
  Should be a hex color string, for example "FF0000".
  """
  backgroundColor: String

  """The channel ID that the reward is being updated in."""
  channelID: ID!

  """The point cost of this reward."""
  cost: Int

  """
  The length of the global cooldown applied to rewards redeemed of this type.
  """
  globalCooldownSetting: CommunityPointsCustomRewardGlobalCooldownSettingInput

  """Whether this reward has real world value."""
  hasRealWorldValue: Boolean

  """Whether the reward is enabled."""
  isEnabled: Boolean

  """Whether the reward is temporarily paused."""
  isPaused: Boolean

  """
  Whether only subscribers are allowed to redeem this reward in this channel.
  """
  isSubOnly: Boolean

  """Whether this reward requires users to enter text input."""
  isUserInputRequired: Boolean

  """The most rewards of this type that can be redeemed per stream."""
  maxPerStreamSetting: CommunityPointsCustomRewardMaxPerStreamSettingInput

  """
  The most rewards of this type that can be redeemed per user per stream.
  """
  maxPerUserPerStreamSetting: CommunityPointsCustomRewardMaxPerUserPerStreamSettingInput

  """The optional user-facing prompt for this reward."""
  prompt: String

  """The ID of the reward being updated."""
  rewardID: ID!

  """
  Whether redemptions for this reward should skip the broadcaster's request queue and get
  automatically fulfilled.
  """
  shouldRedemptionsSkipRequestQueue: Boolean

  """A flag to reset this custom reward's image to the default."""
  shouldResetImage: Boolean

  """The short title displayed for this reward."""
  title: String
}

"""
The response from updating a custom Community Points reward in a channel.
"""
type UpdateCommunityPointsCustomRewardPayload {
  """
  An error that occurred while updating a custom Community Points reward in a channel.
  """
  error: UpdateCommunityPointsCustomRewardError

  """The newly updated reward."""
  reward: CommunityPointsCustomReward
}

"""An error from acting on a Community Points redemption."""
type UpdateCommunityPointsCustomRewardRedemptionStatusError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode
}

"""
The possible reasons acting on a Community Points redemption could fail.
"""
enum UpdateCommunityPointsCustomRewardRedemptionStatusErrorCode {
  """The redemption was not found."""
  NOT_FOUND

  """
  The current user is not allowed to update the status of this redemption.
  """
  FORBIDDEN
}

"""Input for acting on all Community Points redemptions for a channel."""
input UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelInput {
  """The channel ID the redemptions were made in."""
  channelID: ID!

  """The new status to set the redemptions to."""
  newStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The old status redemptions are currently set to."""
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!
}

"""
The response from acting on all Community Points redemptions for a channel.
Most of the work is done as an async task and redemption status changes are pushed over pubsub.
"""
type UpdateCommunityPointsCustomRewardRedemptionStatusesByChannelPayload {
  """An error that occurred while updating the redemption statuses."""
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

"""
Input for acting on the Community Points redemptions from the provided list.
"""
input UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsInput {
  """The channel ID the redemptions were made in."""
  channelID: ID!

  """The new status to set the redemptions to."""
  newStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The old status redemptions are currently set to."""
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The redemption IDs to update."""
  redemptionIDs: [ID!]!
}

"""
The response from acting on the Community Points redemptions from the provided list.
Most of the work is done as an async task and redemption status changes are pushed over pubsub.
"""
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRedemptionsPayload {
  """An error that occurred while updating the redemption statuses."""
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

"""Input for acting on all Community Points redemptions for a reward."""
input UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardInput {
  """The channel ID the redemptions were made in."""
  channelID: ID!

  """The new status to set the redemptions to."""
  newStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The old status redemptions are currently set to."""
  oldStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The reward ID to update all redemptions with oldStatus for."""
  rewardID: ID!
}

"""
The response from acting on all Community Points redemptions for a reward.
Most of the work is done as an async task and redemption status changes are pushed over pubsub.
"""
type UpdateCommunityPointsCustomRewardRedemptionStatusesByRewardPayload {
  """An error that occurred while updating the redemption statuses."""
  error: UpdateCommunityPointsCustomRewardRedemptionStatusesError
}

"""An error from acting on a Community Points redemption."""
type UpdateCommunityPointsCustomRewardRedemptionStatusesError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode
}

"""
The possible reasons acting on a Community Points redemption could fail.
"""
enum UpdateCommunityPointsCustomRewardRedemptionStatusesErrorCode {
  """An unexpected error occured."""
  UNKNOWN

  """
  The current user is not allowed to update the statuses of these redemptions.
  """
  FORBIDDEN

  """
  There is already a bulk update in progress for this reward / all rewards. Only one can be	processed at a time.
  """
  IN_PROGRESS
}

"""Input for acting on a Community Points redemption."""
input UpdateCommunityPointsCustomRewardRedemptionStatusInput {
  """The channel ID the redemption was made in."""
  channelID: ID!

  """The new status to set the redemption to."""
  newStatus: CommunityPointsCustomRewardRedemptionStatus!

  """The redemption ID."""
  redemptionID: ID!
}

"""The response from acting on a Community Points redemption."""
type UpdateCommunityPointsCustomRewardRedemptionStatusPayload {
  """An error that occurred while updating the redemption status."""
  error: UpdateCommunityPointsCustomRewardRedemptionStatusError

  """The updated redemption."""
  redemption: CommunityPointsCustomRewardRedemption
}

"""
An error returned when updating a user's enrollment in Community Points early access.
"""
type UpdateCommunityPointsEarlyAccessError {
  """The error code identifying this error."""
  code: UpdateCommunityPointsEarlyAccessErrorCode!
}

"""
An error returned when updating a user's enrollment in Community Points early access.
"""
enum UpdateCommunityPointsEarlyAccessErrorCode {
  """
  The user is not allowed to opt in to the Community Points early access program.
  """
  FORBIDDEN

  """There was some other error updating the user's enrollment."""
  UNKNOWN
}

"""
Requests to change a user's enrollment status in the Community Points early access program.
"""
input UpdateCommunityPointsEarlyAccessSettingsInput {
  """
  Sets whether the user is signing up for or removing themself from the early access program.
  """
  isSignedUp: Boolean!
}

"""Returns updated early access status for Community Points."""
type UpdateCommunityPointsEarlyAccessSettingsPayload {
  """The channel whose Early Access preference was updated."""
  channel: Channel

  """
  Optionally, an error that occurred while attempting to update the user's enrollment status.
  """
  error: UpdateCommunityPointsEarlyAccessError
}

"""
An error from updating the last viewed community points content timestamps on a channel.
"""
type UpdateCommunityPointsLastViewedContentError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsLastViewedContentErrorCode
}

"""
The possible reasons updating the last viewed community points content timestamps on a channel could fail.
"""
enum UpdateCommunityPointsLastViewedContentErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """
  The current user is not allowed to update last viewed timestamps for this channel.
  """
  FORBIDDEN
}

"""
Input for updating the last viewed community points content timestamps on a channel.
The global content that was viewed on the channel will also have the timestamps updated.
"""
input UpdateCommunityPointsLastViewedContentInput {
  """The channelID where the content was viewed."""
  channelID: ID!

  """The content types that were viewed."""
  viewedContent: [CommunityPointsContentType!]!
}

"""
The response from updating the last viewed community points content timestamps on a channel.
"""
type UpdateCommunityPointsLastViewedContentPayload {
  """
  An error that occurred while updating the last viewed content timestamps.
  """
  error: UpdateCommunityPointsLastViewedContentError

  """The updated last viewed timestamps for a channels content."""
  lastViewedChannelContent: [CommunityPointsLastViewedContentByType!]

  """
  The updated last viewed timestamps for global content across all of twitch.
  """
  lastViewedGlobalContent: [CommunityPointsLastViewedContentByTypeAndID!]
}

"""
An error from updating a Community Points Smart Costs Acknowledgements in a channel.
"""
type UpdateCommunityPointsSmartCostsAcknowledgementsError {
  """An identifier for the error that occurred."""
  code: UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode
}

"""
The possible reasons updating a Community Points Smart Costs Acknowledgement in a channel could fail.
"""
enum UpdateCommunityPointsSmartCostsAcknowledgementsErrorCode {
  """An unexpected error occurred."""
  UNKNOWN

  """
  The current user is not allowed to update a smart costs acknowledgement in this channel.
  """
  FORBIDDEN

  """The cost is invalid. Must be a positive integer."""
  LAST_ACKNOWLEDGED_COST_INVALID
}

"""
Input required for updating community points smart costs acknowledgements.
"""
input UpdateCommunityPointsSmartCostsAcknowledgementsInput {
  """List of acknowledgements to update."""
  acknowledgements: [SmartCostsAcknowledgementInput!]!

  """The channel ID that the reward is being updated in."""
  channelID: ID!
}

"""
Payload returned after updating Community Points Smart Costs Acknowledgements.
"""
type UpdateCommunityPointsSmartCostsAcknowledgementsPayload {
  """
  List of acknowledgements for community points smart costs that were updated.
  """
  acknowledgements: [SmartCostsAcknowledgement!]

  """
  An error that occurred while updating a Community Points Smart Costs Acknowledgements in a channel.
  """
  error: UpdateCommunityPointsSmartCostsAcknowledgementsError
}

"""The competition contact info for updates."""
input UpdateCompetitionContactInfoInput {
  """Link to Discord server for competition contact purposes."""
  discordURL: String

  """Email address point of contact for the competition."""
  email: String
}

"""Update a Competition."""
input UpdateCompetitionInput {
  """Banner image for the competition event page."""
  bannerImageURL: String

  """
  This is the amount of time (in minutes) available for participants to check-in once competition startAt has passed.
  """
  checkInDurationMinutes: Int

  """Long form description of the competition."""
  description: String

  """The time the competition is scheduled to end."""
  endAt: Time

  """The predefined structure of phases and lobbies."""
  formatType: FormatType

  """The game being played in the competition>."""
  gameID: ID

  """ID of the Competition we want to update."""
  id: ID!

  """Primary artwork for the competition."""
  imageURL: String

  """Specific format restrictions for a competition."""
  leaderboardDetails: UpdateCompetitionLeaderboardDetailsInput

  """The name of the competition."""
  name: String

  """
  The participant-facing points of contact for the competition that only registered participants can see.
  """
  participantOnlyContactInfo: UpdateCompetitionContactInfoInput

  """
  Long form text block description that explains the prizing for the competition
  and will be converted to Markdown client-side.
  """
  prizeDescription: String

  """The public points of contact for the competition that anyone can see."""
  publicContactInfo: UpdateCompetitionContactInfoInput

  """The time the competition is scheduled to end registration."""
  registrationEndAt: Time

  """The maximum number of players in a REGISTERED state."""
  registrationLimit: Int

  """
  Long form text block description that explains the rules for the competition
  and will be converted to Markdown client-side.
  """
  rulesDescription: String

  """The time the competition is scheduled to start."""
  startAt: Time

  """The state of the tournament."""
  state: CompetitionState

  """The size of a team when ParticipantType is Team."""
  teamSize: Int

  """Link URL to any additional terms and conditions."""
  termsURL: String
}

"""Editable fields for Leaderboard competition details."""
input UpdateCompetitionLeaderboardDetailsInput {
  """The max participant count for a lobby in phase."""
  lobbyMaxSize: Int

  """The number of phases a competition should have."""
  phaseCount: Int

  """The way points are assigned to a participant in case of a tie."""
  tiebreakerLabel: TiebreakerLabel
}

"""Data that was mutated after the competition was updated."""
type UpdateCompetitionPayload {
  """The competition which was updated."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Update the state of a player in a Competition."""
input UpdateCompetitionPlayerInput {
  """Unique Competition ID."""
  competitionID: ID!

  """The discord username for the player."""
  discordUsername: String

  """The in game username for the player."""
  inGameUsername: String

  """Indicates whether the player is disqualified."""
  isDisqualified: Boolean

  """The state a player has in the competition we want to change."""
  state: CompetitionPlayerState

  """Twitch user id of the player."""
  userID: ID!
}

"""Data that was mutated after the player was updated."""
type UpdateCompetitionPlayerPayload {
  """
  The new state of competition after updating a competition player in the competition.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Update a team in a Competition."""
input UpdateCompetitionTeamInput {
  """Twitch user id of the participant to make into the TeamCaptain."""
  captainID: ID

  """Unique Competition ID."""
  competitionID: ID!

  """Indicates whether the team is disqualified."""
  isDisqualified: Boolean

  """The user ids of the team members."""
  members: [ID!]

  """Unique Team ID for the specified Competition."""
  teamID: ID!

  """The new name of the team."""
  teamName: String
}

"""Data that was mutated after the CompetitionTeam was updated."""
type UpdateCompetitionTeamPayload {
  """The competition that was updated."""
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Error associated with mutation UpdateConsent."""
type UpdateConsentError {
  """Error code."""
  code: UpdateConsentErrorCode
}

"""Client Error Code."""
enum UpdateConsentErrorCode {
  """Invalid vendor name or law name or consent status."""
  INVALID_VENDOR_LAW_CONSENT_STATUS
}

"""
UpdateConsentInput updates or creates a consent status for a privacy law.
"""
input UpdateConsentInput {
  """Consent Session ID."""
  consentSessionID: ID!

  """Privacy rule set of applicable law, e.g. CCPA or GDPR."""
  privacyLawName: PrivacyLawName!

  """Consent status for each vendor."""
  vendorStatus: [VendorConsentStatusInput!]!
}

"""UpdateConsentPayload returns the created or updated consent status."""
type UpdateConsentPayload {
  """The full consent status given by the user after the create request."""
  consent: Consent

  """The possible error returned from service."""
  error: UpdateConsentError
}

"""Update tags associated with CLIP, STREAM, or VOD with contentID."""
input UpdateContentTagsInput {
  """List of tag IDs to be added from the content."""
  addedTagIDs: [ID!]

  """ID of the channel owning the content."""
  authorID: ID!

  """
  ID of content: Channel ID for Streams, Slugs for Clips, and VOD ids for VODs.
  """
  contentID: ID!

  """
  Type of content being returned. Can only be of values CLIP, STREAM, or VOD.
  """
  contentType: ContentType!

  """List of tag IDs to be removed from the content."""
  removedTagIDs: [ID!]
}

"""Result of mutation is the contentID."""
type UpdateContentTagsPayload {
  """Content which tags have been updated."""
  content: TaggedContent
}

"""
Error codes for issues that may occur when trying to update an
existing Mosaic layout.
"""
enum UpdateDashboardViewMosaicLayoutErrorCode {
  """An unhandled error."""
  UNKNOWN

  """A layout matching the provided ID was not found."""
  NOT_FOUND

  """The name argument is invalid."""
  INVALID_ARGUMENT_NAME

  """The layout argument is invalid."""
  INVALID_ARGUMENT_LAYOUT

  """The version argument is invalid."""
  INVALID_ARGUMENT_VERSION

  """The layoutID argument is required."""
  INVALID_ARGUMENT_LAYOUTID

  """The userID argument is required."""
  INVALID_ARGUMENT_USERID

  """
  One or more unspecified aguments are invalid. These are not
  user-actionable, but might indicate a logic error.
  """
  INVALID_ARGUMENT
}

"""
Input for updating properties of an existing Mosaic layout.
Must specify the id of the layout, which is validated based
on the current userID. Must also specify the type of the layout.
Other fields are optional; only specified fields are updated,
and undefined ones are left unchanged.
"""
input UpdateDashboardViewMosaicLayoutInput {
  """
  The Mosaic data blob (in string form) representing a Mosaic layout.
  If left undefined, the data will not be changed.
  """
  data: MosaicData

  """
  The id of the specific mosaic layout to be updated. This identifies
  a combination of type and channel for this user, and has an additional
  unique component to distinguish it from other layouts for this type and channel.
  """
  id: ID!

  """
  The display name of the layout. This allows the display name to be changed.
  If left undefined, the display name will not be changed.
  """
  name: String

  """
  The version tag for a Mosaic layout, which can be optionally updated.
  If left undefined, the value will not be changed.
  """
  version: String
}

"""Result of the updateDashboardViewMosaicLayout mutation."""
type UpdateDashboardViewMosaicLayoutPayload {
  """Represents an error when attempting to update a layout, if applicable."""
  errorCode: UpdateDashboardViewMosaicLayoutErrorCode

  """The the layout that was updated."""
  layout: ChannelDashboardLayout
}

"""UpdateDropBenefitInput has fields required to update a drop benefit."""
input UpdateDropBenefitInput {
  """The redirect URL where a user can link their account."""
  accountLinkURL: String!

  """The ID of this benefit object."""
  benefitID: ID!

  """The global limit of how often this benefit can be entitled to a user."""
  entitlementLimit: Int!

  """The game that awarded the Drop."""
  gameID: ID!

  """
  Specifies if this reward is considered for a game that is available on iOS.
  """
  isIosAvailable: Boolean

  """The display name of this benefit object."""
  name: String!

  """The RBAC organization ID of the owner."""
  ownerID: ID!
}

"""
UpdateDropBenefitOnDropInput has fields required to update a drop's benefit.
"""
input UpdateDropBenefitOnDropInput {
  """The benefit to add to the drop."""
  benefitID: ID!

  """How many times the drop can award the benefit."""
  dropEntitlementLimit: Int!

  """The drop to add the benefit to."""
  dropID: ID!
}

"""UpdateDropBenefitOnDropPayload returns the result of the update."""
type UpdateDropBenefitOnDropPayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""UpdateDropBenefitPayload returns the result of the update."""
type UpdateDropBenefitPayload {
  """Returns the updated Benefit."""
  dropBenefit: DropBenefit

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""
UpdateDropPreconditionsInput has fields required to update multiple drops and their precondition drop.
"""
input UpdateDropPreconditionsInput {
  """The campaign we want to update drops for."""
  campaignID: ID!

  """A list of drops and their drop precondition."""
  dropPreconditions: [DropPrecondition]!
}

"""UpdateDropPreconditionsPayload returns the result of the update."""
type UpdateDropPreconditionsPayload {
  """Returns the updated Campaign."""
  dropCampaign: DropCampaign

  """A mapped error returned by the drops management service."""
  error: DropsError
}

"""The required input for a updateDropsOptOutStatus mutation."""
input UpdateDropsOptOutStatusInput {
  """Channel's drop opt-out Status."""
  isOptedOut: Boolean!

  """The Id of the user whose broadcast setting is being updated."""
  userID: ID!
}

"""The result of a updateDropsOptOutStatus mutation."""
type UpdateDropsOptOutStatusPayload {
  """Status is the updated status."""
  isOptedOut: Boolean

  """userID is the user who wishes to opt out of drops."""
  userID: ID
}

"""Errors for updating emote orders."""
type UpdateEmoteOrdersError {
  """The associated error code."""
  code: UpdateEmoteOrdersErrorCode!
}

"""
The expected errors that can be returned from the UpdateEmoteOrders mutation.
"""
enum UpdateEmoteOrdersErrorCode {
  """
  The user is not permitted to update the orders of the requested emotes or group.
  """
  UNAUTHORIZED

  """No emote was found with the requested emote ID."""
  BAD_EMOTE_REQUEST

  """No group was found with the requested group ID."""
  BAD_GROUP_REQUEST

  """
  The orders provided result in an invalid set of orders in a particular group.
  """
  BAD_NON_UNIQUE_ORDERS_REQUEST

  """An unexpected error occurred."""
  UNKNOWN_ERROR
}

"""The required input for an updateEmoteOrders mutation."""
input UpdateEmoteOrdersInput {
  """
  The list of emotes with their newly requested orders in a particular group.
  """
  orders: [EmoteOrder!]!
}

"""The result of an updateEmoteOrders mutation."""
type UpdateEmoteOrdersPayload {
  """Emotes are the newly reordered emotes."""
  emotes: [Emote!]

  """Service error, if any."""
  error: UpdateEmoteOrdersError
}

"""
UpdateExtensionDiscoveryDataError is an error associated with the updateExtensionDiscoveryData mutation.
"""
enum UpdateExtensionDiscoveryDataError {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_VERSION

  """Extension names must be shorter than 40 characters."""
  INVALID_NAME_LENGTH

  """Extension description must be shorter than 1024 characters."""
  INVALID_DESCRIPTION_LENGTH

  """Extension summary must be shorter than 140 characters."""
  INVALID_SUMMARY_LENGTH

  """
  Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_AUTHOR_EMAIL

  """
  Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_SUPPORT_EMAIL

  """Extension author name length must be > 40."""
  INVALID_AUTHOR_NAME_LENGTH

  """
  Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TESTING_BASE_URI

  """
  Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TERMS_URI

  """
  Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_PRIVACY_URI
}

"""
UpdateExtensionDiscoveryDataInput updates the discovery data of a given extension version.
"""
input UpdateExtensionDiscoveryDataInput {
  """Extension metadata used for discovery."""
  discoveryManifest: ExtensionDiscoveryManifestInput!

  """The extension ID of the manifest to update."""
  id: ID!

  """The extension version to update."""
  version: String!
}

"""
UpdateExtensionDiscoveryDataPayload returns the update Extension discovery metadata.
"""
type UpdateExtensionDiscoveryDataPayload {
  """The error when the mutation fails to update an extension."""
  error: UpdateExtensionDiscoveryDataError

  """The updated extension discovery data."""
  manifest: ExtensionVersionDiscoveryManifest
}

"""
UpdateExtensionManifestError is an error associated with the updateExtensionManifest mutation.
"""
enum UpdateExtensionManifestError {
  """User is unable to make modifications to the extension."""
  UNAUTHORIZED

  """Version specified is invalid."""
  INVALID_VERSION

  """At least one anchor must be specified."""
  ANCHOR_REQUIRED

  """HasZoom was specified but ZoomPixels is missing."""
  INVALID_ZOOM

  """The number of whitelisted broadcasters exceeds the limit."""
  MAX_BROADCASTERS

  """The number of whitelisted testing users exceeds the limit."""
  MAX_TESTERS

  """The number of whitelisted config URLs exceeds the limit."""
  MAX_WHITELISTED_CONFIG_URLS

  """The number of whitelisted panel URLs exceeds the limit."""
  MAX_WHITELISTED_PANEL_URLS

  """Extension names must be shorter than 40 characters."""
  INVALID_NAME_LENGTH

  """Extension description must be shorter than 1024 characters."""
  INVALID_DESCRIPTION_LENGTH

  """Extension summary must be shorter than 140 characters."""
  INVALID_SUMMARY_LENGTH

  """
  Extension author email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_AUTHOR_EMAIL

  """
  Extension support email must not be nil. Lenght must be < 254, Parses a single RFC 5322 address.
  """
  INVALID_SUPPORT_EMAIL

  """Extension author name length must be > 40."""
  INVALID_AUTHOR_NAME_LENGTH

  """
  Extension testing base uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TESTING_BASE_URI

  """
  Extension terms uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_TERMS_URI

  """
  Extension privacy uri must not be nil and empty scheme. Scheme should be http or https. User should not be nil.
  """
  INVALID_PRIVACY_URI

  """
  Extension component viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_COMPONENT_VIEWER_PATH

  """
  Extension panel viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_PANEL_VIEWER_PATH

  """
  Extension video overlay viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_VIDEO_OVERLAY_VIEWER_PATH

  """
  Extension config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_CONFIG_VIEWER_PATH

  """
  Extension live config viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_LIVE_CONFIG_VIEWER_PATH

  """
  Extension mobile viewer path must not be nil. Format should be BaseUri/Extension_Path.
  """
  INVALID_MOBILE_VIEWER_PATH

  """Extension component aspect width must be < 50 or > 1."""
  INVALID_COMPONENT_ASPECT_WIDTH

  """Extension component aspect height must be < 50 or > 1."""
  INVALID_COMPONENT_ASPECT_HEIGHT

  """Extension panel hiehgt must be < 500 or > 100."""
  INVALID_PANEL_HEIGHT

  """
  Extension Bits Support Level must ba valid member of the BitsSupportLevelEnum.
  """
  INVALID_BITS_SUPPORT_LEVEL
}

"""UpdateExtensionManifestInput updates the manifest."""
input UpdateExtensionManifestInput {
  """ExtensionAssetManifest is data related to the assets of an extension."""
  assetManifest: ExtensionAssetManifestInput!

  """
  Data about what an Extension can do, in general, and at the time of interaction.
  """
  capabilities: ExtensionCapabilitiesInput!

  """ExtensionDeveloperManifest is the developer specific extension data."""
  developerManifest: ExtensionDeveloperManifestInput!

  """Extension metadata used for discovery."""
  discoveryManifest: ExtensionDiscoveryManifestInput!

  """The extension ID of the manifest to update."""
  id: ID!

  """The extension version to update."""
  version: String!

  """Extension views."""
  views: ExtensionViewsInput!
}

"""UpdateExtensionManifestPayload returns the update Extension manifest."""
type UpdateExtensionManifestPayload {
  """The error when the mutation fails to update an extension."""
  error: UpdateExtensionManifestError

  """The updated extension manifest."""
  manifest: ExtensionManifest
}

"""UpdateHypeTrainConfigInput takes series of optional config settings."""
input UpdateHypeTrainConfigInput {
  """Custom emote to be rendered in Hype Train messaging."""
  calloutEmoteID: ID

  """Length of the cooldown period after a hype train ends."""
  cooldownPeriodMinutes: Int

  """The difficulty of hype train levels."""
  difficulty: HypeTrainDifficulty

  """Whether hype train should be enabled."""
  isEnabled: Boolean

  """Hype Train kickoff settings."""
  kickoff: HypeTrainKickoffInput

  """
  A boolean flag that indicates if the hype train settings should be personalized by Twitch.
  """
  shouldUsePersonalizedSettings: Boolean

  """Use creator color as base color of the Hype Train progress bar."""
  willUseCreatorColor: Boolean
}

"""
UpdateHypeTrainConfigPayload is the response that contains the updated config.
"""
type UpdateHypeTrainConfigPayload {
  """The updated hype train config for the channel."""
  config: HypeTrainConfig
}

"""
Updates the user's activity sharing setting. This must only be sent in response to a direct action by the user
intended to change the setting.
"""
input UpdateIsSharingActivityInput {
  """
  Determines whether or not to show the user's activity in their shared status. When false, the user will always
  appear as if they are performing no activity.
  """
  isSharingActivity: Boolean!
}

type UpdateIsSharingActivityPayload {
  """The modified user."""
  user: User
}

"""Mutation input for updating partner leaderboard settings."""
input UpdateLeaderboardSettingsInput {
  """The default leaderboard the user wants to show."""
  defaultLeaderboard: LeaderboardType

  """Setting for enabling bits cheering leaderboards."""
  isCheerEnabled: Boolean

  """Setting for enabling sub gifting leaderboards."""
  isSubGiftEnabled: Boolean

  """The time period the user wants the leaderboard to be displayed as."""
  timePeriod: LeaderboardTimePeriodType

  """The user ID to update leaderboard settings."""
  userID: ID!
}

"""Result of mutation is the updated user object."""
type UpdateLeaderboardSettingsPayload {
  """The user whose settings were updated."""
  user: User
}

"""The required input for a updateLiveUpNotification mutation."""
input UpdateLiveUpNotificationInput {
  """
  The text that will be in the notification that sends when the user starts broadcasting.
  If updated to "", the default value of "<user> went live!" will be used/returned.
  """
  liveUpNotification: String!

  """The ID of the user whose live up notification is being updated."""
  userID: ID!
}

"""Returned after live up notification state is mutated."""
type UpdateLiveUpNotificationPayload {
  """The modified broadcast settings."""
  broadcastSettings: BroadcastSettings

  """If any validation errors occur, this will not be nil."""
  error: UpdateLiveUpNotificationValidationError
}

"""
Resolver for validation errors that occur on update live up notification.
"""
type UpdateLiveUpNotificationValidationError {
  """Error code that describes the validation error."""
  code: UpdateLiveUpNotificationValidationErrorCode!
}

"""Validation error status codes."""
enum UpdateLiveUpNotificationValidationErrorCode {
  """The notification text sent did not pass auto mod."""
  FAILED_AUTOMOD

  """The notification text sent is too long."""
  TOO_LONG

  """The target user is not found."""
  USER_NOT_FOUND
}

"""
Inputs for updating the score for the lobby participant, who is a competition player or competition team, in a competition.
"""
input UpdateLobbyParticipantScoreInput {
  """ID of the competition."""
  competitionID: ID!

  """ID of the competition lobby."""
  lobbyID: ID!

  """ID of the competition player or competition team."""
  participantID: ID!

  """ID of the competition phase."""
  phaseID: ID!

  """The assigned score value."""
  score: Int!
}

"""
UpdateLobbyParticipantScorePayload is the success response updating the score
for the lobby participant, who is a competition player or competition team, in a competition.
"""
type UpdateLobbyParticipantScorePayload {
  """
  The new state of competition after scoring a competition player or competition team for that lobby.
  """
  competition: Competition

  """Used for competition mutation errors."""
  error: CompetitionError
}

"""Exchanges one of two auth inputs for an AccessToken and RefreshToken."""
input UpdateLWATokenInput {
  """Either an AuthorizationCode or a RefreshToken."""
  grant: String!

  """The type of grant provided."""
  grantType: GrantType!
}

"""Returns updated tokens, or an error if a new LWA flow is required."""
type UpdateLWATokenPayload {
  """An error in this flow means the client should redo the LWA flow."""
  error: WatchPartyError

  """Contains all token information."""
  token: LWAToken
}

"""Contains a list of multi-view content attributes to be updated."""
input UpdateMultiviewContentAttributesInput {
  """List of multi-view content attributes to be updated."""
  params: [MultiviewContentAttributeParams!]!
}

"""Contains the server response payload."""
type UpdateMultiviewContentAttributesPayload {
  """Unprocssed content attribute updates."""
  failedUpdates: [MultiviewContentAttribute!]!

  """Processed content attribute updates."""
  succeededUpdates: [MultiviewContentAttribute!]!
}

"""Used for mutating onboarding status."""
input UpdateOnboardingSkippedChannelsInput {
  """List of channels the user skips during the onboarding process."""
  channelIDs: [ID!]!

  """ID for the user to update."""
  userID: ID!
}

"""Returned after onboarding state is mutated."""
type UpdateOnboardingSkippedChannelsPayload {
  """Current state of the given user."""
  user: User
}

"""
Error that may be returned by the UpdateOrganizationMemberRole mutation.
"""
type UpdateOrganizationMemberRoleError {
  """Type of mutation error."""
  code: UpdateOrganizationMemberRoleErrorCode!
}

"""
UpdateOrganizationMemberRoleErrorCode is the client error type that occurred
during the UpdateOrganizationMemberRole mutation.
"""
enum UpdateOrganizationMemberRoleErrorCode {
  """
  The user is not a member of the organization, or the organization does not exist.
  """
  MEMBER_NOT_FOUND

  """
  The user doesn't meet the requirements to have this role. For example, when trying to assign the
  "BILLING_MANAGER" role, but the user doesn't have 2FA enabled or completed Extension Monetization Onboarding.
  """
  MEMBER_INELIGIBLE

  """
  Current user not allowed to update the role.
  For example, developers can not assign roles, and no one can assign the owner role to another user.
  """
  PERMISSION_DENIED

  """
  One of the input parameters is malformed. This should not happen when properly using the UI.
  """
  INVALID_ARGUMENT
}

"""Inputs to the UpdateOrganizationMemberRole mutation."""
input UpdateOrganizationMemberRoleInput {
  """ID of the organization where the user is a member."""
  organizationID: ID!

  """New role of the user in the organization."""
  role: OrganizationMemberRole!

  """User's Twitch ID."""
  userID: ID!
}

"""Outputs from the UpdateOrganizationMemberRole mutation."""
type UpdateOrganizationMemberRolePayload {
  """Logical error that could be returned by the mutation."""
  error: UpdateOrganizationMemberRoleError

  """Updated member with the new role."""
  organizationMember: OrganizationMember
}

"""
UpdateOwnerChanletAttributesInput updates the owner chanlet attributes.
"""
input UpdateOwnerChanletAttributesInput {
  """The ID of the owner chanlet (channel that owns chanlets)."""
  channelID: ID!

  """Whether the chanlets should return for the viewers."""
  isChanletFeatureEnabled: Boolean!
}

"""
UpdateOwnerChanletAttributesPayload returns the new chanlet that was created.
"""
type UpdateOwnerChanletAttributesPayload {
  """
  Resulted OwnerChanletAttributes from the update. This is expected to match the input.
  """
  ownerChanletAttributes: OwnerChanletAttributes
}

input UpdatePanelInput {
  description: String
  id: ID!
  imageURL: String
  linkURL: String
  slotID: String
  title: String
}

type UpdatePanelPayload {
  panel: Panel!
}

"""Error returned during a invalid user request."""
type UpdatePhoneNumberConfirmationError {
  """Error code returned by the backend."""
  code: UpdatePhoneNumberConfirmationErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to change a users phone number.
"""
enum UpdatePhoneNumberConfirmationErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """Phone number was not valid."""
  INVALID_PHONE_NUMBER

  """The phone number has requested checks on too many verification codes."""
  REQUEST_THROTTLED

  """The phone number provided is used for too many Twitch accounts."""
  LIMIT_REACHED

  """The one time password provided is invalid."""
  INVALID_OTP

  """
  The one time password provided is missing. A SMS to the phone number will be triggered when this error occurs.
  """
  MISSING_OTP

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a updatePhoneNumberConfirmation mutation."""
input UpdatePhoneNumberConfirmationInput {
  """
  The one time password required to complete phone number registration. This can
  only be generated from the UpdatePhoneNumber mutation.
  """
  oneTimePassword: String!

  """The phone number being added to a twitch user profile."""
  phoneNumber: String!

  """
  The ID of the user that is requesting to add or modify their phone number.
  """
  userID: ID!
}

"""The result of a updatePhoneNumberConfirmationPayload mutation."""
type UpdatePhoneNumberConfirmationPayload {
  """error code and localized error."""
  error: UpdatePhoneNumberConfirmationError
}

"""Error returned during a invalid user request."""
type UpdatePhoneNumberError {
  """Error code returned by the backend."""
  code: UpdatePhoneNumberErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to change a users phone number.
"""
enum UpdatePhoneNumberErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """Phone number was not valid."""
  INVALID_PHONE_NUMBER

  """The phone number has requested too many verification codes."""
  REQUEST_THROTTLED

  """The phone number provided is used for too many Twitch accounts."""
  LIMIT_REACHED

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a updatePhoneNumber mutation."""
input UpdatePhoneNumberInput {
  """The phone number being added to a twitch user profile."""
  phoneNumber: String!

  """
  The ID of the user that is requesting to add or modify their phone number.
  """
  userID: ID!
}

"""The result of a updatePhoneNumberPayload mutation."""
type UpdatePhoneNumberPayload {
  """error code and localized error."""
  error: UpdatePhoneNumberError
}

"""Error code for an error that occurs while updating prime offer status."""
type UpdatePrimeOfferStatusError {
  """Error code for error that occurred while updating prime offer status."""
  code: UpdatePrimeOfferStatusErrorCode!
}

"""Error types recognized."""
enum UpdatePrimeOfferStatusErrorCode {
  """Status when the offers fail to be updated."""
  OFFERS_FAILED_TO_UPDATE

  """Unknown error being returned from service."""
  UNKNOWN
}

"""The offer id you wish to update as well as the status for the update."""
input UpdatePrimeOfferStatusInput {
  """The list of offers and statuses to update."""
  statusChanges: [OfferAndStatus!]!

  """The user to update the offer statuses for."""
  userID: ID!
}

"""The returned value for an update prime offer status query."""
type UpdatePrimeOfferStatusPayload {
  """The possible error returned from the service."""
  error: UpdatePrimeOfferStatusError

  """The connection for the status of the offer for the user."""
  self: [PrimeOfferSelfConnection!]!
}

"""
UpdatePrimeSettingsInput contains boolean for setting the users preference on chat notifications,
and the users preference on the emoticon set name to be selected.
"""
input UpdatePrimeSettingsInput {
  """The Prime Emoticons Set Name for Prime Emoticons Smilies."""
  primeEmoticonsSetName: PrimeEmoticonsSetName

  """True or False for whether the user wants notifications enabled."""
  shouldEnableSubCreditChatNotification: Boolean

  """The ID of the user who's settings are being updated."""
  userID: ID!
}

"""Data that was mutated."""
type UpdatePrimeSettingsPayload {
  """The mutated PrimeSettings."""
  primeSettings: PrimeSettings
}

"""UpdateRaidSettingsInput update a user's raid settings."""
input UpdateRaidSettingsInput {
  """Determines what other channels can raid this channel."""
  incomingRaidsPolicy: IncomingRaidsPolicy

  """UserID to update settings for."""
  userID: ID!
}

"""
UpdateRaidSettingsPayload returns the user whose settings had been updated.
"""
type UpdateRaidSettingsPayload {
  """User whose raid settings has been updated."""
  user: User
}

type UpdateRoomError {
  code: UpdateRoomErrorCode!

  """
  On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Maximum number of characters.
  """
  maxLength: Int

  """
  On NAME_LENGTH_INVALID, TOPIC_LENGTH_INVALID: Minimum number of characters.
  """
  minLength: Int
}

enum UpdateRoomErrorCode {
  """User does not have permission to update room."""
  FORBIDDEN

  """Could not find a room with the given room ID."""
  ROOM_NOT_FOUND

  """Name too short or too long."""
  NAME_LENGTH_INVALID

  """Name contains invalid characters (e.g. spaces)."""
  NAME_CONTAINS_INVALID_CHARACTERS

  """Name failed automod check."""
  NAME_INAPPROPRIATE

  """Name was not unique to channel."""
  NAME_NOT_UNIQUE

  """Topic too short or too long."""
  TOPIC_LENGTH_INVALID

  """Topic failed automod check."""
  TOPIC_INAPPROPRIATE

  """
  Invalid roles specified (e.g. a more permissive role for send than read).
  """
  ROLES_INVALID
}

input UpdateRoomInput {
  """Deprecated. Use minimumReadMessagesRole instead."""
  isPreviewable: Boolean

  """
  Deprecated. Use minimumReadMessagesRole and minimumSendMessagesRole instead.
  """
  minimumAllowedRole: RoomRole

  """Minimum role required to read messages in the room."""
  minimumReadMessagesRole: RoomRole

  """Minimum role required to send messages in the room."""
  minimumSendMessagesRole: RoomRole
  name: String
  roomID: ID!
  topic: String
}

type UpdateRoomModesError {
  code: UpdateRoomModesErrorCode!

  """
  On SLOW_MODE_DURATION_INVALID: Maximum number of seconds slow mode can be set to.
  """
  maximumSlowModeDurationSeconds: Int

  """
  On SLOW_MODE_DURATION_INVALID: Minimum number of seconds slow mode can be set to.
  """
  minimumSlowModeDurationSeconds: Int
}

enum UpdateRoomModesErrorCode {
  """
  RoomID referred to an invalid or the user does not have permissions to see the room.
  """
  ROOM_NOT_FOUND

  """User did not have permission to update room modes."""
  FORBIDDEN

  """Slow mode duration was too short, too long, or not a number."""
  SLOW_MODE_DURATION_INVALID
}

input UpdateRoomModesInput {
  """Turns emotes only mode on or off."""
  enableEmotesOnlyMode: Boolean

  """Turns r9k mode on or off."""
  enableR9KMode: Boolean

  """Turns slow mode on or off."""
  enableSlowMode: Boolean
  roomID: ID!

  """
  If slow mode enabled, the number of seconds users must wait between messages.
  """
  slowModeDurationSeconds: Int
}

type UpdateRoomModesPayload {
  error: UpdateRoomModesError
  room: Room
}

type UpdateRoomPayload {
  error: UpdateRoomError
  room: Room
}

input UpdateRoomViewInput {
  isArchived: Boolean
  isMuted: Boolean
  lastReadAt: Time
  roomID: ID!
}

type UpdateRoomViewPayload {
  roomView: RoomView
}

"""
UpdateScheduleSegmentError is a wrapper for error associated with the UpdateScheduleSegment mutation.
"""
type UpdateScheduleSegmentError {
  """Error code."""
  code: UpdateScheduleSegmentErrorCode!

  """
  If the error is related to overlapping segments, provide the existing segment causing a conflict.
  """
  conflictingSegment: ScheduleSegment

  """
  If the error is related to an input out of service-defined bounds, provide the maximum allowed value.
  """
  maximum: Int

  """
  If the error is related to an input out of service-defined bounds, provide the miniimum allowed value.
  """
  minimum: Int
}

"""The possible error returned."""
enum UpdateScheduleSegmentErrorCode {
  """Not authorized to update this segment."""
  PERMISSION_DENIED

  """
  The number of categories is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_CATEGORY_COUNT

  """The specified segment could not be found."""
  NOT_FOUND

  """No update was made because no updated attributes were provided."""
  NO_UPDATED_ATTRIBUTES_PROVIDED

  """No update was made because the update would cause a segment overlap."""
  OVERLAPPING_SEGMENTS

  """
  The title length is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_TITLE

  """The title failed the moderation check."""
  TITLE_FAILED_MODERATION

  """The timezone is not valid."""
  INVALID_TIMEZONE

  """The categories are not valid."""
  INVALID_CATEGORIES

  """The segment start day is invalid."""
  INVALID_START_DAY

  """The segment start hour is invalid."""
  INVALID_START_HOUR

  """The segment start minute is invalid."""
  INVALID_START_MINUTE

  """
  The duration is invalid. Refer to the error for min and max acceptable values.
  """
  INVALID_DURATION

  """The segment is invalid."""
  INVALID_SEGMENT

  """The input is not valid."""
  INVALID_ARGUMENT

  """The segment first occurrence date is set in the past."""
  FIRST_OCCURRENCE_DATE_IN_PAST

  """
  Cannot set the first occurrence date on an infinitely recurring segment.
  """
  FIRST_OCCURRENCE_DATE_ON_RECURRING_SEGMENT

  """The segment has already started and can't be edited."""
  ALREADY_STARTED
}

"""The input to update a schedule segment."""
input UpdateScheduleSegmentInput {
  """The categories of the segment."""
  categories: [ID!]

  """The duration of the segment in minutes."""
  durationMinutes: Int

  """The start date and time of the first occurrence of the segment."""
  firstOccurrenceDate: Time

  """Whether the segment is cancelled."""
  isCancelled: Boolean

  """The schedule id."""
  scheduleID: ID!

  """The segment id to update."""
  segmentID: ID!

  """The start time of the segment."""
  start: SegmentStartTimeInput

  """The geographic timezone of the segment."""
  timezone: String

  """The title of the segment."""
  title: String
}

"""The returned payload when updating a schedule segment."""
type UpdateScheduleSegmentPayload {
  """The possible error returned."""
  error: UpdateScheduleSegmentError

  """The updated schedule with the updated segment."""
  schedule: Schedule
}

"""Updates the list of streamer onboarding content that a user has seen."""
input UpdateSeenCreatorOnboardingContentInput {
  """A list of content IDs that should be marked as seen."""
  onboardingContentIDs: [ID!]!

  """UserID for the user to update seen content."""
  userID: ID!
}

"""The result of an UpdateSeenCreatorOnboardingContent mutation."""
type UpdateSeenCreatorOnboardingContentPayload {
  """The user who viewed onboarding content."""
  user: User
}

"""UpdateSocialMediaError is a user error while creating a social media."""
enum UpdateSocialMediaError {
  """The title failed moderation."""
  FAILED_TITLE_MODERATION

  """The provided title was too long."""
  TITLE_TOO_LONG

  """The provided url is invalid."""
  INVALID_URL

  """The social medias does not exist."""
  NOT_FOUND
}

"""
UpdateSocialMediaInput updates existing a social media item under the given channelID.
"""
input UpdateSocialMediaInput {
  """The unique channel identifier."""
  channelID: ID!

  """The unique indentifier of the social media item."""
  id: ID!

  """The visible text of the social media item."""
  title: String

  """The web address of the social media item."""
  url: String
}

"""UpdateSocialMediaPayload returns the updated social media."""
type UpdateSocialMediaPayload {
  """The social media channel that was updated."""
  channel: Channel

  """The potential error when updating a social media."""
  error: UpdateSocialMediaError
}

"""
UpdateSquadInvitePolicyError is the error associated with an updateSquadInvitePolicy.
"""
type UpdateSquadInvitePolicyError {
  """The associated error code."""
  code: UpdateSquadInvitePolicyErrorCode!
}

"""
UpdateSquadInvitePolicyErrorCode are the possible errors that this mutation returns.
"""
enum UpdateSquadInvitePolicyErrorCode {
  """The caller is not authorized to update the user's squad invite policy."""
  UNAUTHORIZED
}

"""The required input for an updateSquadInvitePolicy mutation."""
input UpdateSquadInvitePolicyInput {
  """
  The new invite policy that will replace what is currently set for the user.
  """
  incomingInvitePolicy: SquadStreamIncomingInvitePolicy!

  """
  The ID corresponding to the user whose invite policy should be updated.
  """
  userID: ID!
}

"""Returns after the invite policy is mutated."""
type UpdateSquadInvitePolicyPayload {
  """The possible error returned from the service."""
  error: UpdateSquadInvitePolicyError

  """The modified user."""
  user: User
}

"""
UpdateSquadStreamError is the error associated with a updateSquadStream.
"""
type UpdateSquadStreamError {
  """The associated error code."""
  code: UpdateSquadStreamErrorCode!
}

"""
UpdateSquadStreamErrorCode are the possible errors that this mutation returns.
"""
enum UpdateSquadStreamErrorCode {
  """The squad is not found."""
  SQUAD_NOT_FOUND

  """The squad cannot be updated (e.g. squad is not in pending status)."""
  SQUAD_CANNOT_BE_UPDATED

  """The squad has too few members to be updated to live."""
  SQUAD_TOO_FEW_MEMBERS

  """The user is not authorized to update the squad."""
  UNAUTHORIZED
}

"""Inputs to the updateSquadStream mutation."""
input UpdateSquadStreamInput {
  """The ID of the squad stream to be updated."""
  squadStreamID: ID!

  """If specified, the new status of the squad stream."""
  status: SquadStreamStatus
}

"""Outputs from the updateSquadStream mutation."""
type UpdateSquadStreamPayload {
  """The possible error returned from the service."""
  error: UpdateSquadStreamError

  """The updated squad stream."""
  squadStream: SquadStream
}

"""Inputs to updating a stucco."""
input UpdateStuccoInput {
  """ID of the channel this stucco belongs to."""
  channelID: ID!

  """
  Description representing the stucco, should be the words contained in the stucco, used by screen readers.
  """
  description: String!

  """Base64 encoded binary data of the 92x28px stucco ("1x") image asset."""
  imageData1x: String!

  """Base64 encoded binary data of the 182x56px stucco ("2x") image asset."""
  imageData2x: String!

  """Base64 encoded binary data of the 368x112px stucco ("4x") image asset."""
  imageData4x: String!

  """Unique ID of the stucco to update."""
  stuccoID: ID!

  """
  Text code representing the stucco without any prefixes (prefixes are added in the backend).
  """
  suffix: String!
}

"""
Inputs for updating a stucco pack (exchanging stuccos contained in the pack).
"""
input UpdateStuccoPackInput {
  """Id of the channel this pack is part of."""
  channelID: ID!

  """Id of the stucco pack to update."""
  stuccoPackID: ID!

  """Updated list of stuccos for this pack."""
  stuccos: [UpdateStuccoPackItemInput!]
}

"""
Single item in a stuccopack, as part of the update stucco pack call, representing one stucco to be used in a certain slot.
"""
input UpdateStuccoPackItemInput {
  """Slot index in the pack (used for ordering)."""
  slotIndex: Int!

  """Id of the stucco."""
  stuccoID: ID!
}

"""Outputs from the update stucco pack mutation."""
type UpdateStuccoPackPayload {
  """The updated stucco pack."""
  stuccoPack: StuccoPack
}

"""The output for the update stucco mutation."""
type UpdateStuccoPayload {
  """The updated stucco."""
  stucco: Stucco
}

"""Inputs to the updateSubscriptionProduct mutation."""
input UpdateSubscriptionProductInput {
  """Name of the product."""
  displayName: String

  """Toggle to enable add free viewing."""
  hasAdFree: Boolean

  """Toggle to enable fast chat (or disable slow mode)."""
  hasFastChat: Boolean

  """Toggle to enable sub only chat."""
  hasSubOnlyChat: Boolean

  """Toggle to enable sub only video."""
  hasSubOnlyVideoArchive: Boolean

  """The id of the subscription product."""
  id: ID!

  """User the update belongs to."""
  targetUserID: ID!
}

"""Output from the updateSubscriptionProduct mutation."""
type UpdateSubscriptionProductPayload {
  """Subscription product output."""
  product: SubscriptionProduct

  """User/channel to update the subscription product."""
  targetUser: User
}

"""The possible error returned."""
type UpdateUserColorsError {
  """The error code."""
  code: UpdateUserColorsErrorCode!
}

"""The possible types of error codes returned."""
enum UpdateUserColorsErrorCode {
  """Hex string is invalid."""
  INVALID_HEX_COLOR
}

"""The required input for a UpdateUserColorsInput mutation."""
input UpdateUserColorsInput {
  """The user's primary color hex string (e.g. "FFFFFF")."""
  primaryColorHex: String!

  """The ID of the user whose creator colors are being updated."""
  userID: ID!
}

"""The result of a UpdateUserColorsInput mutation."""
type UpdateUserColorsPayload {
  """The possible error returned."""
  error: UpdateUserColorsError

  """The modified user."""
  user: User
}

"""The required input for a updateUserCreateDateHidden mutation."""
input UpdateUserCreateDateHiddenInput {
  """The hide create date boolean to set onto the user."""
  isCreateDateHidden: Boolean!

  """The ID of the user whose privacy setting is being updated."""
  userID: ID!
}

"""The result of a updateUserCreateDateHidden mutation."""
type UpdateUserCreateDateHiddenPayload {
  """The modified user."""
  user: User
}

"""The required input for a updateUserDirectoryHidden mutation."""
input UpdateUserDirectoryHiddenInput {
  """The directory hidden boolean to set onto the user."""
  IsDirectoryHidden: Boolean!
}

"""The result of a updateUserDirectoryHidden mutation."""
type UpdateUserDirectoryHiddenPayload {
  """The modified user."""
  user: User
}

"""The required input for a updateUserEmailReuseable mutation."""
input UpdateUserEmailReusableInput {
  """The email reusable boolean to set onto the user."""
  IsEmailReusable: Boolean!

  """The ID of the user whose broadcast setting is being updated."""
  userID: ID!
}

"""The result of a updateUserEmailReuseable mutation."""
type UpdateUserEmailReusablePayload {
  """The modified user."""
  user: User
}

"""The possible error returned."""
type UpdateUserError {
  """The error code."""
  code: UpdateUserErrorCode!
}

"""The possible error codes returned from updating a user."""
enum UpdateUserErrorCode {
  """User is not authorized to update this user."""
  AUTH_FAILURE

  """Too many attempts to update user."""
  REQUESTS_THROTTLED

  """User cannot be found."""
  USER_NOT_FOUND

  """Sudo token expired, prompt the user to log in again."""
  REAUTH_NEEDED

  """Display name not available."""
  DISPLAY_NAME_NOT_AVAILABLE

  """Display name is too short."""
  DISPLAY_NAME_TOO_SHORT

  """Display name is too long."""
  DISPLAY_NAME_TOO_LONG

  """Display name contains invalid characters."""
  INVALID_CHARS_IN_DISPLAY_NAME

  """User is not allowed to change their display name again."""
  DISPLAY_NAME_CHANGE_AGAIN

  """User can only change the capitalization of their display name."""
  DISPLAY_NAME_ONLY_CAP

  """Unexpected error during displayname override."""
  DISPLAY_NAME_UNEXPECTED_ERR

  """The login you selected is not available."""
  LOGIN_NOT_AVAILABLE

  """The login you selected is not yet available for re-use."""
  LOGIN_BLOCKED

  """Login change rate limited."""
  NOT_ALLOWED_TO_CHANGE_LOGIN

  """The login you selected is too short."""
  LOGIN_TOO_SHORT

  """The login you selected is too long."""
  LOGIN_TOO_LONG

  """The login you selected contains invalid characters."""
  INVALID_CHARS_IN_LOGIN

  """Login contains banned words."""
  LOGIN_USE_BANNED_WORDS

  """Login contains variations on banned words."""
  LOGIN_USE_VARIATION_ON_BANNED_WORDS

  """User exists but was excluded by filter criteria."""
  FILTERED_USER_REQUESTED

  """The IP is blocked."""
  IP_BLOCKED

  """Too many users associated with the email."""
  TOO_MANY_USERS_FOR_EMAIL

  """Email disabled for reuse."""
  EMAIL_DISABLED_FOR_REUSE

  """Email address is not valid."""
  INVALID_EMAIL

  """Admins must use their work email."""
  WORK_EMAIL_REQUIRED

  """Email address uses an invalid domain."""
  INVALID_EMAIL_DOMAIN

  """Email change cooldown."""
  NOT_ALLOWED_TO_CHANGE_EMAIL

  """Phone number is invalid."""
  PHONE_NUMBER_INVALID

  """Phone number cannot contain letters."""
  PHONE_NUMBER_HAS_LETTERS

  """Description contains banned words."""
  DESCRIPTION_FAILED_MODERATION

  """Description field is too long."""
  DESCRIPTION_TOO_LONG

  """No properties found for this user identifier."""
  NO_PROPERTIES

  """Reservation does not exist in db."""
  RESERVATION_NOT_EXITS

  """The specified locale is invalid."""
  LANGUAGE_NOT_VALID

  """Age cannot be under 13 years."""
  INVALID_BIRTHDAY

  """Last Login doesn't follow format "%Y-%m-%d %H:%M:%S"."""
  INVALID_LAST_LOGIN

  """
  Phone number or email update cannot be combined with delete pohone number.
  """
  INVALID_PARAMETER_COMBINATION

  """Phone number can only be removed for an account with a verifed email."""
  NOT_ALLOWED_TO_DELETE_PHONE_NUMBER

  """Phone number already exists."""
  PHONE_NUMBER_ALREADY_EXISTS

  """Hex color is not valid."""
  INVALID_HEX_COLOR

  """Unknown error."""
  UNKNOWN
}

"""The required input for a UpdateUser mutation."""
input UpdateUserInput {
  """If true the phone number associated with this user will be deleted."""
  deletePhoneNumber: Boolean

  """The user's personal description."""
  description: String

  """The user's display name."""
  displayName: String

  """The user's personal email."""
  email: String

  """
  Whether or not to send a mobile verification code if email verification is required.
  """
  includeVerificationCode: Boolean

  """User id of the user being updated."""
  userID: ID!
}

"""The required input for a updateUserIsEmailRevertSuccess mutation."""
input UpdateUserIsEmailRevertSuccessInput {
  """The show email revert success msg boolean to set onto the user."""
  isEmailRevertSuccess: Boolean!

  """The ID of the user whose email revert success flag is being updated."""
  userID: ID!
}

"""The result of a updateUserIsEmailRevertSuccess mutation."""
type UpdateUserIsEmailRevertSuccessPayload {
  """The modified user."""
  user: User
}

"""The result of an updateUser mutation."""
type UpdateUserPayload {
  """The possible error returned."""
  error: UpdateUserError

  """The modified user."""
  user: User
}

"""An error returned from the updateUserPredictionSettings mutation."""
type UpdateUserPredictionSettingsError {
  """Code describing the error."""
  code: UpdateUserPredictionSettingsErrorCode!
}

"""Possible error codes from the updateUserPredictionSettings mutation."""
enum UpdateUserPredictionSettingsErrorCode {
  """An unknown error occurred."""
  UNKNOWN
}

"""
Update the current authorized user's Prediction Settings.
All fields are nullable; only specify fields that you wish to update.
"""
input UpdateUserPredictionSettingsInput {
  """Whether the user has accepted the latest Predictions Terms of Service."""
  hasAcceptedTOS: Boolean

  """
  Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events.
  """
  isTemporaryChatBadgeEnabled: Boolean
}

"""Payload for updating a user's Prediction Settings."""
type UpdateUserPredictionSettingsPayload {
  """If present, there was an error with the request."""
  error: UpdateUserPredictionSettingsError

  """The updated settings."""
  settings: UserPredictionSettings
}

"""
UpdateUserSubscriptionSettingsInput updates the users subscription settings.
"""
input UpdateUserSubscriptionSettingsInput {
  """Whether the user only wants to receive gifts to channels they follow."""
  giftsInFollowedChannelsOnly: Boolean

  """Whether the user wants to hide Badge Modifiers."""
  isBadgeModifierHidden: Boolean

  """If the user wants to hide their Founder Badges."""
  isFounderBadgesHidden: Boolean

  """Whether the user wants to show how many gifts they've purchased."""
  isGiftCountHidden: Boolean

  """
  Whether the user wants to show their subscription tenure and status in the chat viewer card.
  """
  isSubscriptionStatusHidden: Boolean
}

"""
UpdateUserSubscriptionGiftSettingsPayload returns the user's current gift settings.
"""
type UpdateUserSubscriptionSettingsPayload {
  subscriptionSettings: UserSubscriptionSettings
}

"""Inputs to the updateUserTeamMembership mutation."""
input UpdateUserTeamMembershipInput {
  """
  Whether or not the team should be the user's primary team.
  Note only True values are effective here. A user must always have one and only
  one primary team, and setting false would break that invariant.
  Setting a team as Primary will make all of a user's other team memberships non-primary.
  """
  primary: Boolean

  """Whether or not the membership should reveal its revenue."""
  revenueRevealed: Boolean!

  """Whether or not the membership should reveal its stats."""
  statsRevealed: Boolean!

  """The team which the membership belongs to."""
  teamID: ID!

  """The user whose membership is being modified."""
  userID: ID!
}

"""Output from the updateUserTeamMembership mutation."""
type UpdateUserTeamMembershipPayload {
  """The user whose membership was modified."""
  user: User
}

"""Error information in the update user video shelves response."""
type UpdateUserVideoShelvesError {
  """An http error code to identify the error response."""
  code: Int!

  """The translated error response message for this given error."""
  message: String
}

"""
Input information for updating a user's video shelves. Video shelves are
added/removed and reordered based on the provided shelfOptions.
"""
input UpdateUserVideoShelvesInput {
  """Channel for which to update shelves."""
  channelID: ID!

  """
  A list of different shelf options to populate the user's video shelves.
  """
  shelfOptions: [ShelvesAvailableOptions!]!
}

"""Response to a request to update a user's video shelves."""
type UpdateUserVideoShelvesPayload {
  """The error response for this update request."""
  error: UpdateUserVideoShelvesError

  """The list of shelves for this user."""
  shelves: [VideoShelf]
}

"""
Input information for updating a resume watching entry for a specified user and video.
"""
input UpdateUserViewedVideoInput {
  """
  Position for where in the video to update for the resume watching entry.
  """
  position: Int!

  """User for which to update the resume watching entry."""
  userID: ID!

  """Video for which to update the resume watching entry."""
  videoID: ID!

  """Type of the video for which to update the resume watching entry."""
  videoType: VideoType!
}

"""
Response to a request to update a resume watching entry for a specified user and video.
"""
type UpdateUserViewedVideoPayload {
  """The video returned from the request."""
  video: Video
}

input UpdateVideoCommentInput {
  """ID of the comment being updated."""
  commentID: ID!

  """The state of the comment."""
  state: VideoCommentState!
}

type UpdateVideoCommentPayload {
  """The comment that was updated."""
  comment: VideoComment!
}

"""Input information for updating a video."""
input UpdateVideoInput {
  """The description of the video."""
  description: String

  """The name of the game presented in the video."""
  game: String

  """The language of the video."""
  language: String

  """Determines viewability of the video; PUBLIC or PRIVATE."""
  scope: VideoPrivacyScope

  """The thumbnail URL of the video."""
  thumbnailPath: String

  """The title of the video."""
  title: String

  """ID of the video being updated."""
  videoID: ID!
}

"""Response to a request to update a video."""
type UpdateVideoPayload {
  """The video with updated fields."""
  video: Video
}

"""Error that may be returned by the UpdateVideoStreamSettings mutation."""
type UpdateVideoStreamSettingsError {
  """Type of mutation error."""
  code: UpdateVideoStreamSettingsErrorCode!
}

"""
UpdateVideoStreamSettingsErrorCode is the client error type that occurred during the UpdateVideoStreamSettings mutation.
"""
enum UpdateVideoStreamSettingsErrorCode {
  """The broadcaster is not found."""
  CHANNEL_NOT_FOUND

  """Permission denied to add an authorized user."""
  PERMISSION_DENIED

  """Invalid argument to add an authorized user."""
  INVALID_ARGUMENT
}

"""
UpdateVideoStreamSettingsInput updates the broadcaster's stream settings such as stream delay length seconds or stream key.
"""
input UpdateVideoStreamSettingsInput {
  """
  ChannelID of the broadcaster. This has to be same as authenticated user's userID.
  """
  channelID: ID!

  """
  The number of seconds delay for a stream. When this is set, a stream will be
  ingested with specified delay in seconds. Maximum is set to 900 seconds.
  """
  delaySeconds: Int

  """Whether or not a stream should be started as a low latency stream."""
  isLowLatency: Boolean

  """
  Whether or not the broadcaster prefers to archive the vod for a stream.
  """
  shouldArchiveVODs: Boolean

  """Whether or not to show the disconnect slate."""
  shouldShowDisconnectSlate: Boolean
}

"""
UpdateVideoStreamSettingsPayload returns the updated video stream settings for the broadcaster.
"""
type UpdateVideoStreamSettingsPayload {
  """The updated Channel for the broadcaster."""
  channel: Channel

  """Error code."""
  error: UpdateVideoStreamSettingsError
}

"""Error associated with mutation UpdateVideosViewability."""
type UpdateVideosViewabilityError {
  """Error code."""
  code: UpdateVideosViewabilityErrorCode!
}

"""Client error code."""
enum UpdateVideosViewabilityErrorCode {
  """Internal error."""
  INTERNAL_ERROR

  """The request body was invalid."""
  BAD_REQUEST

  """Permission Denied."""
  PERMISSION_DENIED

  """Unknown error."""
  UNKNOWN
}

"""Inputs for the updating videos by id mutation."""
input UpdateVideosViewabilityInput {
  """Determines viewability of the videos; PUBLIC or PRIVATE."""
  scope: VideoPrivacyScope

  """The IDs of the videos to be updated."""
  videoIDs: [ID!]!
}

"""The returned payload from the DeleteVideos mutation."""
type UpdateVideosViewabilityPayload {
  """The possible error returned from service."""
  error: UpdateVideosViewabilityError
}

"""
The change that will be applied to the user's visibility. See VisibilityInput for details on the effects of each
value.
"""
input UpdateVisibilityInput {
  visibility: VisibilityInput!
}

type UpdateVisibilityPayload {
  """The modified user."""
  user: User
}

"""The request to the UpdateWhisperSettings mutation."""
input UpdateWhisperSettingsInput {
  """
  Whether to disallow strangers from iniating a whisper thread to this user.
  """
  isBlockingWhispersFromStrangers: Boolean
}

"""The response from the UpdateWhisperSettings mutation."""
type UpdateWhisperSettingsPayload {
  """The user whose whisper settings were updated."""
  user: User
}

input UpdateWhisperThreadInput {
  """Whether to archive the room."""
  isArchived: Boolean

  """Whether to mute the room."""
  isMuted: Boolean

  """Whether to mark the message as spam."""
  isSpam: Boolean

  """ID of last message read by the user."""
  lastReadMessageID: ID

  """
  Whether to revoke temporary send Whisper permission from the other user.
  """
  removeWhitelist: Boolean

  """ID of thread to be marked as read."""
  threadID: ID!
}

type UpdateWhisperThreadPayload {
  """Thread that was updated."""
  thread: WhisperThread!
}

"""Generates an image URL to upload to."""
input UploadCompetitionImageInput {
  """Unique Competition ID."""
  competitionID: ID!

  """Type of image being uploaded."""
  imageType: CompetitionImageType!
}

"""Data required to upload an image to the competition."""
type UploadCompetitionImagePayload {
  """Used for upload competition image errors."""
  error: CompetitionUploadImageError

  """The metadata required to access an image for a competition."""
  image: CompetitionImageUpload
}

"""Individual upload config."""
type UploadConfig {
  """Upload id used when listening to pubsub."""
  ID: ID!

  """URL to upload images to."""
  URL: String!

  """The type of asset of the emote image that should be uploaded."""
  assetType: EmoteAssetType!

  """Images that will result out of the upload."""
  images: [UploadImage!]!

  """Size of the image that should be uploaded."""
  size: EmoteImageSize!
}

type UploadImage {
  """Image ID generated by Mako for image."""
  ID: ID!

  """Size of the image."""
  Size: EmoteImageSize!

  """The asset type of the image."""
  assetType: EmoteAssetType!
}

"""The url metadata of a twitch webpage."""
type URLMetadata {
  """The linked data (JSON format) of the page."""
  jsonld: String

  """The list of metatags of the page."""
  metatags: [SEOMetatag!]!

  """The data that power URL sharing."""
  share: URLMetadataShare!

  """The title of the page."""
  title: String!
}

"""The data that power URL sharing."""
type URLMetadataShare {
  """The text to share."""
  text: String!

  """The title to share."""
  title: String!

  """The url to share."""
  url: String!
}

"""
UseChatNotificationTokenInput is the input required for the UseChatNotificationToken mutation.
"""
input UseChatNotificationTokenInput {
  """The channel that this token will be used on."""
  channelLogin: String!

  """Whether or not to include user's streak tenure."""
  includeStreak: Boolean!

  """
  An optional message that will be displayed when this chat token is used.
  """
  message: String

  """An optional ID of token to be used."""
  tokenID: ID
}

"""
UseChatNotificationTokenPayload is the return of the UseChatNotificationToken mutation.
"""
type UseChatNotificationTokenPayload {
  """If the token was successfully used."""
  isSuccess: Boolean!
}

"""Twitch user."""
type User {
  """Information about a user's connected accounts."""
  accountConnections: AccountConnectionSet!

  """Information about a user's account health status."""
  accountHealth: UserAccountHealth

  """
  Fetch active challenges for the user based on a variety of sorting options.
  By default returns 10 challenges, sorted by start time.
  """
  activeChallenges(first: Int = 10, after: Cursor, sort: ChannelChallengeSort = START_TIME, direction: SortOrder = DESC): ChannelChallengeConnection

  """
  An action that a user or session is performing. This field is null if the user is not friends with
  the authenticated user.
  """
  activity: Activity

  """Ad Properties for the given user."""
  adProperties: AdProperties

  """The user's relationship with Amazon."""
  amazon: UserAmazonConnection @deprecated(reason: "Retail sales discontinued")

  """List of authenticated Twitch sessions."""
  authenticatedSessionList: [AuthenticatedSession!]

  """
  AutoModProperties is a mapping of automod categories to levels, i.e. a user has indicated they want level 4, or
  the highest level of moderation for profanity, but level 1 for everything
  else. (These are based on Sift levels, and will be deprecated).
  """
  autoModProperties: AutoModProperties

  """
  A user's configured auto refill information, contains all auto refill profiles.
  Will have an optional filter argument in the future.
  """
  autoRefill: AutoRefill

  """
  The list of channels that this user has configured to automatically host
  when their channel is not streaming live. Users can only view their own
  autohost channels.
  """
  autohostChannels: AutohostChannelConnection

  """
  Options and preferences for autohost behavior, including whether
  autohosting is enabled at all and how to choose which channel to host.
  Users can only view their own autohost settings.
  """
  autohostSettings: AutohostSettings

  """
  The list of channels that have added this user as a channel to automatically host when their channel is not
  streaming live. Users can only view their own autohosted by channels.
  """
  autohostedByChannels: AutohostedByChannelConnection

  """
  An action that a user or session is performing. This field is null if the user is not friends with
  the authenticated user.
  """
  availability: Availability

  """
  The badges which are available for the authenticated user to select for use on
  another user's streams and videos if no channel-specific preference is set.
  If no domain is not specified, all emote sets will be returned.
  This is only returned if the request is authenticated by the same user whose email is requested.
  """
  availableBadges(domains: [BadgeDomain!]): [Badge]

  """
  A list of this user's balances in FIAT currencies
  If this isn't the `currentUser` this will return null.
  """
  balances(walletType: WalletType): [Balance] @deprecated(reason: "Use walletBalances")

  """
  A list of this user's banned users.
  A maximum of 100 users by most recent are returned
  Only resolves for the authenticated user.
  """
  bannedUsers: [ChannelBannedUser!]

  """A URL to the user's banner image."""
  bannerImageURL: String

  """
  bitsBalance is the number of bits this user currently has available to spend.
  If this isn't the `currentUser` or the user has been banned from using bits this will return null.
  This field can only be requested if an OAuth token is supplied with the request.
  """
  bitsBalance: Int

  """
  bitsEvents returns a paginated list of this user's bits usage transactions
  If this isn't the `currentUser` this will return null.
  This field can only be requested if an OAuth token is supplied with the request.
  """
  bitsEvents(first: Int = 50, after: Cursor, criteria: BitsEventConnectionCriteriaInput!): BitsEventConnection

  """
  bitsOffers is a list of the ways this user can obtain more bits.
  If this isn't the `currentUser` or the user has been banned from using bits this will return null.
  This field can only be requested if an OAuth token is supplied with the request.
  """
  bitsOffers: [BitsOffer]

  """
  BitsPaymentMethods has a list of eligible payment methods for a user to transact with.
  """
  bitsPaymentMethods: BitsPaymentMethods

  """
  BitsProductEligibility checks for a given user if they are eligible to purchase a given product from the associated
  provider, quantity, and locale.
  bitsProduct(id: ID!, provider: BitsProductProvider!, quantity: Int!, locale: String!): BitsProductEligibility!
  bitsProducts is a list of bits products that a user is able to purchase.
  Unlike bitsOffers, this does not return any pricing information, only information
  about the purchasable. A provider must be supplied, which is the payment platform
  being currently used. An optional list of SKUs can be provided if we are looking up
  a specific set of products for a user.
  """
  bitsProducts(provider: BitsProductProvider!, skus: [String!], paymentProvider: PaymentProvider): [BitsProduct!]

  """Settings tied to a bits user."""
  bitsUserSettings: BitsUserSettings

  """
  bitsUserState dictates the state of the Bits user (new to Bits, existing Bits user, etc.)
  If this isn't the `currentUser` or the user has been banned from using bits this will return null.
  This field can only be requested if an OAuth token is supplied with the request.
  """
  bitsUserState: BitsUserState

  """
  Resolves account information that Twitch has stored for a user's blizzard account information.
  """
  blizzardAccount: BlizzardUser

  """Get the blocked terms of a user."""
  blockedTerms: [ChannelBlockedTerm!]!

  """
  blockedUsers returns a list users that are restrained from directly communicating with this user.
  """
  blockedUsers: [User]!

  """bounties is a list of bounty board bounties for this user."""
  bounties(status: String!): [Bounty!] @deprecated(reason: "Use user.bountiesPage instead")

  """
  bountiesPage is a paginated list of bounty board bounties for this user.
  """
  bountiesPage(first: Int = 10, after: Cursor, status: String!): BountyConnection

  """
  bountyBoardSettings are settings and rules around the behavior of bounty boards for this user.
  """
  bountyBoardSettings: BountyBoardSettings

  """
  Badges that are displayed in chat during this user's broacasts or videos.
  """
  broadcastBadges: [Badge]

  """A User's broadcast settings that persists between streams."""
  broadcastSettings: BroadcastSettings

  """A User's campaign for their channel."""
  campaign(campaignID: ID!): Campaign @deprecated(reason: "campaign events have been deprecated")

  """A User's campaign properties for their channel."""
  campaignProperties: CampaignProperties @deprecated(reason: "campaign events have been deprecated")

  """A container for celebration settings for the logged in user."""
  celebrationSettings: CelebrationUserSettings

  """
  The channel which belongs to the user. This is still deprecated for previous uses.
  This should only be used for the multi-view experience.
  """
  channel: Channel

  """What other similar content are my viewers watching."""
  channelAnalyticsContentOverlap: ChannelAnalyticsContentOverlap

  """
  A user's channel feed.
  No authorization required.  Returns even if channel feed is disabled in the UI.
  """
  channelFeed: Feed

  """
  Returns the list of chatrooms in the channel visible by the current user.
  """
  channelRooms: [Room]! @deprecated(reason: "The Rooms product has been sunset")

  """Hex color of the user's name in chat, e.g. "#ccaa44"."""
  chatColor: String

  """
  chatSettings are settings and rules for chatting in this user's channel.
  """
  chatSettings: ChatSettings

  """chatUISettings are settings for the user's chat UI."""
  chatUISettings: ChatUISettings

  """
  cheer is the channel-specific cheer settings and current state.
  Returns null if cheering isn't enabled for this channel.
  """
  cheer: CheerInfo

  """The list of OAuth clients authorized by the current user."""
  clientAuthorizations: [ClientAuthorization!]

  """
  A paginated list of clips featuring this user.
  When criteria is not specified, the default values are used.
  """
  clips(first: Int = 10, after: Cursor, criteria: UserClipsInput): ClipConnection

  """A paginated list of collections (playlists) created by the user."""
  collections(first: Int = 10, after: Cursor, options: CollectionsOptions): CollectionsConnection

  """
  Properties relating to the authenticated user's community points on twitch.
  """
  communityPoints: CommunityPointsUserProperties

  """
  The company that the user belongs to.
  Returns null if the user doesn't belong to a company.
  """
  company: Company @deprecated(reason: "Use organizations instead.")

  """
  The competitions that a user is involved in.
  Returns null if the user doesn't have any competitions.
  user and competition state can be null.
  """
  competitions(first: Int = 10, after: Cursor, userState: CompetitionPlayerState, competitionState: CompetitionState, userCompetitionRelationship: UserCompetitionRelationship!): CompetitionConnection

  """When the user created their account."""
  createdAt: Time!

  """
  The container for creator gifts the creator has. This will be null if the creator
  does not have this feature enabled.
  """
  creatorGifting: CreatorGifting

  """Creator metrics for the given time period."""
  creatorMetricsByInterval(startAt: Time!, endAt: Time!, timeZone: String, numberOfIntervals: Int = 1): CreatorMetricsByInterval

  """
  Get the user's referral links sorted by most recently created first. Will be a
  null CreatorReferralLinkConnection if the user is not eligible.
  """
  creatorReferralLinks(first: Int = 1, after: Cursor): CreatorReferralLinkConnection

  """Get the user's creator referral link statistics summary."""
  creatorReferralSummary(startAt: Time!, endAt: Time!): CreatorReferralSummary!

  """
  Paginated past activities for the Dashboard Activity Feed.
  Always ordered by descending timestamp.
  """
  dashboardActivityFeedActivities(first: Int = 10, after: Cursor): DashboardActivityFeedActivityConnection

  """
  Paginated past activities for the Dashboard Alert Queue.
  Always ordered by descending timestamp.
  """
  dashboardAlertQueueActivities(first: Int = 10, after: Cursor): DashboardAlertQueueActivityConnection

  """
  Preferences that control what alerts are sent to the user for the Dashboard Alert Queue.
  """
  dashboardAlertQueuePreferences: DashboardAlertQueuePreferences

  """Timestamp when a user's account was deleted/disabled."""
  deletedAt: Time

  """
  A user-provided blurb describing themselves.
  Returns null when a description has not been set.
  """
  description: String

  """The directories the user is currently set to broadcast in."""
  directories: UserDirectoryConnection

  """
  Lists the chat badges that should be displayed by the user's display name in
  features like chat and whispers. If a channelID is passed in, fetches the
  display badges that user will have in that channel's context.
  Includes the following badges:
  - global authority (staff/admin/global mod)
  - channel authority (broadcaster/mod, if channelID is set)
  - subscriber (if channelID is set)
  - channel selected (bits) or global selected (prime, turbo, ...).
  """
  displayBadges(channelID: ID, channelLogin: String): [Badge]!

  """
  A user-styled version of their login.
  For international users, this could be the user's login with localized characters.
  """
  displayName: String!

  """Number of DMCA violations user has received."""
  dmcaViolationCount: Int

  """
  A drop 2.0 campaign including personal settings (e.g. account connection status). (Viewer dashboard individual item).
  """
  dropCampaign(id: ID!): DropCampaign

  """
  A list of all available Drops 2.0 Campaigns that a user is eligible to participate in. (Viewer dashboard list).
  """
  dropCampaigns: [DropCampaign!]

  """
  Fetch User's current session, which describes the minutes-watched progress towards a drop.
  """
  dropCurrentSession: DropCurrentSession

  """A list of channels where the user is an editor."""
  editableChannels: EditableChannelConnection

  """A list of channel editors."""
  editors: EditorConnection

  """
  The user's email address.
  This is only returned if the request is authenticated by the same user who's email is requested.
  """
  email: String

  """
  The emote sets this user is entitled to use.
  If no domains are specified, all emote sets will be returned.
  If multiple domains are specified, emotes that belong to either domain are returned (OR).
  If this user is not the current user, it returns nil and a "forbidden" error.
  """
  emoteSets(domains: [EmoteSetDomain!]): [EmoteSet!]

  """The channel's emoticon prefix settings."""
  emoticonPrefix: EmoticonPrefix

  """The list channels that have been endorsed by the user."""
  endorsedChannels(first: Int = 10, recommendationsContext: RecommendationsContext!): EndorsedChannelConnection

  """
  A paginated list of user's all expired subscriptions.
  Only resolves for the current user. Returns a forbidden error if requested for another user.
  """
  expiredSubscriptions(first: Int = 10, after: Cursor): ExpiredSubscriptionConnection

  """
  Feature flags specific to this user.
  Always returns nil.
  """
  featureFlags: FeatureFlags @deprecated(reason: "this functionality has been removed")

  """
  A follow relationship between this user and the one which has the target ID or login.
  Null if no relationship exists.
  """
  follow(targetID: ID, targetLogin: String): Follow @deprecated(reason: "Use user.self.follower instead.")

  """Retrieves a list of games which the user is following."""
  followedGames(first: Int = 10, type: FollowedGamesType = ALL): FollowedGameConnection

  """
  A list of broadcasters this user follows, who are hosting other broadcasters.
  Only resolves for the authenticated user.
  """
  followedHosts(first: Int = 10): FollowedHostConnection @deprecated(reason: "This field is intended to be replaced as soon as an alternative is available.")

  """
  A list of live-streaming broadcasters this user is following.
  Only resolves for the authenticated user.
  NOTE: the sort input parameter is not supported and should not be used.
  """
  followedLiveUsers(first: Int = 10, after: Cursor, includeRestricted: [StreamRestrictionType!], sort: StreamSort = VIEWER_COUNT): FollowedLiveUserConnection @deprecated(reason: "This field is intended to be replaced as soon as an alternative is available.")

  """
  Retrieves recent/popular VODs from the streamers you follow.
  If this isn't the `currentUser` this will return null.
  """
  followedVideos(first: Int = 10, after: Cursor, languages: [String!], types: [BroadcastType!], sort: VideoSort = TIME): VideoConnection

  """A paginated list of users which follow this user."""
  followers(first: Int = 10, after: Cursor, order: SortOrder = ASC): FollowerConnection

  """A paginated list of users this user is following."""
  follows(first: Int = 10, after: Cursor, filter: FollowsFilter = ALL, order: SortOrder = ASC): FollowConnection

  """
  A list of this user's Twitch friends.
  A maximum of 500 friends are returned, although most users have less than the maximum.
  Only accessible if the user is authenticated with the `user_presence_friends_read` scope.
  """
  friends: FriendConnection

  """Notification connection information for a time range."""
  goLiveNotificationConnection(startAt: Time!, endAt: Time!, first: Int = 100, after: Cursor, sort: SortOrder = DESC): GoLiveNotificationConnection

  """Notification information for a time range."""
  goLiveNotifications(startAt: Time!, endAt: Time!, first: Int = 100, sort: SortOrder = DESC): [GoLiveNotification!]

  """Notifications timeseries analytics for a time range."""
  goLiveNotificationsTimeseries(startAt: Time!, endAt: Time!, granularity: Granularity!, numberOfIntervals: Int = 1, timeZone: String!): [GoLiveNotificationTimeseries!]

  """Always returns false, will be deleted soon."""
  hasBadgesTimedOut: Boolean! @deprecated(reason: "this functionality has been removed")

  """Whether this user has Twitch Presto."""
  hasPresto: Boolean

  """Whether this user has Twitch Prime."""
  hasPrime: Boolean!

  """Whether this user has streamed before."""
  hasStreamed: Boolean

  """Whether this user has Twitch Turbo."""
  hasTurbo: Boolean!

  """Whether this user has unread creator changelog items."""
  hasUnreadChangelogItems: Boolean

  """This user's Hero configuration."""
  hero: Hero

  """A curated list of suggested channels to host."""
  hostRecommendations: [User]

  """
  The users hosting this user.
  This field only resolves for the authenticated user, otherwise resolves to null.
  """
  hostedBy(first: Int = 10, after: Cursor): HostConnection

  """The user who this user is hosting."""
  hosting: User

  """The user's unique identifier."""
  id: ID!

  """Returns a SHA-1 hash of the id field."""
  idSHA1: ID!

  """
  A list of open friend requests sent to this user. Friend requests from non-strangers are always placed in front of
  friend requests from strangers; `sort` affects how the two components are ordered within themselves. Only accessible
  if the user is authenticated with the `user_presence_friends_read` scope.
  """
  incomingFriendRequests(first: Int = 10, after: Cursor, sort: FriendSort = DESC): IncomingFriendRequestConnection

  """
  A list of the squad stream invitations that the user has received.
  Each invitation has a network type of either in-network or out-of-network. The invitations are sorted by creation
  time, with the latest invitation first.
  This field only resolves for the authenticated user.
  """
  incomingSquadStreamInvitations: SquadStreamInvitationConnection

  """
  The list of extensions the user has installed.
  installedExtensions gives a set of Extension installations, but does not include some of the information required
  to render extensions.  For this, use extensionsForChannel instead, where you will get more accurate response, and
  which includes fetched extension configuration and extension permissions.
  """
  installedExtensions: [ExtensionInstallation!]

  """Items (crates, drops, etc.) the user owns."""
  inventory: Inventory

  """
  A list of teams that the user has been invited to.
  Only resolves for the current user.
  """
  invitedTeams: [Team]

  """
  Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
  """
  isCommerceRevShareEnabled: Boolean! @deprecated(reason: "Game sales discontinued")

  """
  Whether the user's Twitch account is connected to a Twitter account.
  Returns nil if there was an error. This field is only accessible on the current user.
  """
  isConnectedToTwitter: Boolean

  """
  Whether or not the user has enabled their email to be reused to create another twitch account.
  """
  isEmailReusable: Boolean!

  """Whether or not the user can update their email."""
  isEmailUpdateable: Boolean!

  """
  Whether or not the user has verified their email address by clicking a link sent to their email.
  """
  isEmailVerified: Boolean!

  """
  Indicates that the owner of the email on the account did not signup for this account
  This mainly implies that the account is being deleted and not eligible for self service reactivation.
  """
  isFlaggedToDelete: Boolean!

  """Whether or not the user can moderate any broadcast chat."""
  isGlobalMod: Boolean! @deprecated(reason: "Use user.roles.isGlobalMod instead.")

  """
  Whether or not the user is in good standing, granting automatic emote approval.
  Passes both the authed twitch user who is requesting and the user they are requesting.
  Applies to both affiliates and partners.
  """
  isInEmoteGoodStanding: Boolean

  """
  Whether or not the user is in good standing generally.
  Authenticated to current user. Will error if not a partner.
  """
  isInGoodStanding: Boolean!

  """
  Whether the user meets the GDPR compliance as per his/her country's minimum compliance age.
  """
  isMinimumGDPRConsentAge: Boolean!

  """Whether or not the user is moderator of a another user's channel."""
  isModerator(channelID: String!): Boolean!

  """Whether or not the user is a partnered broadcaster with Twitch."""
  isPartner: Boolean @deprecated(reason: "Use user.roles.isPartner instead.")

  """
  Whether or not the user has verified their phone number.
  This is currently always true if the user has a phone number.
  We do not not allow a user to set a phone number without verifying.
  """
  isPhoneNumberVerified: Boolean!

  """Whether or not the user is a site admininistrator."""
  isSiteAdmin: Boolean! @deprecated(reason: "Use user.roles.isSiteAdmin instead.")

  """Whether or not the user is a Twitch staff member."""
  isStaff: Boolean! @deprecated(reason: "Use user.roles.isStaff instead.")

  """The key pools associated with a user."""
  keyPools(after: String): KeyPoolConnection

  """The user's language preference."""
  language: Language @deprecated(reason: "Use user.settings.preferredLanguageTag instead.")

  """The user's last broadcast."""
  lastBroadcast: Broadcast

  """
  When the user last updated their login name.
  This special field only resolves for the authenticated user.
  """
  lastLoginChangeAt: Time

  """
  The last time the user's availability or activity changed.
  This special field only resolves for the authenticated user; use friends.edges.lastStatusChangeAt to retrieve this
  information about friends..
  Requires the `user_presence_friends_read` scope.
  """
  lastStatusChangeAt: Time

  """Fetches the latest created Poll for the user."""
  latestPoll: Poll

  """The extensions this user has shared their identity with."""
  linkedExtensions: [Extension!]

  """The user's standard alphanumeric Twitch name."""
  login: String!

  """
  The user's profile image.
  Valid widths are 28, 50, 70, 150, 300, and 600.
  The image height will be the same as the given width.
  """
  logoURL(width: Int!): String @deprecated(reason: "Replaced by profileImageURL")

  """Lists a User's Uploaded Loyalty Badge."""
  loyaltyBadges: [LoyaltyBadge!]

  """
  Returns the max number of channel rooms that the current user is allowed to
  create for their channel.
  """
  maxAllowedChannelRooms: Int! @deprecated(reason: "The Rooms product has been sunset")

  """Returns a resolver to query different subsets of the moderation logs."""
  modLogs: ModLogs

  """Returns all channel roles' access permissions to moderator logs."""
  modLogsAccess: [ModLogsAccess!]

  """Returns a channel role's access permission to moderator logs."""
  modLogsRoleAccess(role: ChannelUserRole!): ModLogsAccess

  """A user's settings related to the moderation view page."""
  modViewSettings: ModViewSettings

  """Returns a paginated list of channel moderators."""
  mods(first: Int = 10, after: Cursor): ModConnection

  """A user's event notification settings."""
  notificationSettings: [EventNotificationSetting!]

  """
  A user's notifications.
  This is only returned if the request is authenticated by the same user whose onsite notifications are requested.
  `language` is a letter code for the language the requesting user speaks (ex. "en").
  """
  notifications(first: Int = 10, after: Cursor, language: String, displayType: OnsiteNotificationDisplayType, capabilities: [OnsiteNotificationsCapability!]): OnsiteNotificationConnection

  """OAuth applications developed by the current user."""
  oauthApps(after: Cursor): OAuthAppConnection

  """
  A URL to the image that is displayed when the user is not broadcasting nor hosting another user's broadcast.
  """
  offlineImageURL: String

  """Information about the current user's onboarding state."""
  onboarding: Onboarding @deprecated(reason: "This feature has been sunset.")

  """List of invites to join an organization."""
  organizationInvites(first: Int = 10, after: Cursor): OrganizationInviteUserConnection

  """
  Returns a list of developer organizations.
  Returns null if the user doesn't belong to any organizations.
  """
  organizations: [Organization!]

  """
  A list of open friend requests sent by this user. Friend requests to non-strangers are always placed in front of
  friend requests to strangers; `sort` affects how the two components are ordered within themselves. Only accessible
  if the user is authenticated with the `user_presence_friends_read` scope.
  """
  outgoingFriendRequests(first: Int = 10, after: Cursor, sort: FriendSort = DESC): OutgoingFriendRequestConnection

  """
  A list of teams owned by the user.
  Only resolves for the current user.
  """
  ownedTeams: [Team]

  """
  panels is a list of `Panel` objects with information related to this channel.
  """
  panels(hideExtensions: Boolean = false): [Panel]!

  """
  Fetch participating challenges for the user based on a variety of sorting options.
  By default returns 10 challenges, sorted by end time.
  """
  participatingChallenges(first: Int = 10, after: Cursor, sort: ChannelChallengeSort = END_TIME, direction: SortOrder = ASC, status: [ChannelChallengeStatus!]): ChannelChallengeConnection

  """
  Non-partnered users can submit a partnership application via createPartnershipApplication mutation.
  PartnershipApplication includes the status of the most recently submitted application.
  """
  partnershipApplication: PartnershipApplication

  """Whether or not the user is able to be paid."""
  payableStatus: PayableStatus

  """
  Metrics that are relevant to incentive-based contracts for some partnered
  streamers. This API returns a year-to-date, rolling list of the past 12
  months and includes the current (in-progress) month.
  """
  paymentIncentiveMetrics: [PaymentIncentiveMetricsRollup!]

  """
  Holds configuration necessary to start payment method management. Only the
  authenticated user can access their own configs.
  This is the second step of the payment method management flow.
  (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
  """
  paymentMethodConfigs: PaymentProviderConfigs

  """
  List of payment methods that will be used to pay for Twitch subscriptions that renew in the future
  This is the first step of the payment method management flow.
  (User.paymentMethods -> User.paymentMethodConfigs -> Mutation.setDefaultPaymentMethod).
  """
  paymentMethods: [PaymentMethod!]

  """
  Get user's list of payment transactions. This currently aggregates subscriptions related transactions but plans
  to also aggregate other product types such as Bits. The ultimate goal is to record, aggregate, and provide the
  payment history of Twitch users in a convenient way.
  """
  paymentTransactions(first: Int = 50, after: Cursor, criteria: PaymentTransactionConnectionCriteriaInput!): PaymentTransactionConnection

  """Payout Information."""
  payout: Payout

  """Accrued balance since last payout."""
  payoutBalance: PayoutBalance

  """A user's invite into a payout program."""
  payoutInvite: PayoutInvite

  """List of payout plans a user has when enrolled in any payout programs."""
  payoutPlans: [PayoutPlan!]

  """Get the permitted terms of a user."""
  permittedTerms: [ChannelPermittedTerm!]!

  """
  The user's phone number. Format is always in E.164 format.
  This is only returned if the request is authenticated by the same user whose phone is requested.
  """
  phoneNumber: String

  """
  Fetch polls for the user based on a variety of sorting options.
  By default returns 15 polls, sorted by start time.
  """
  polls(first: Int = 15, after: Cursor, sort: PollSort = START_TIME, direction: SortOrder = DESC, status: [PollStatus!]): PollConnection

  """
  Options and preferences for how the user participates in Predictions Events.
  Users can only view their own Predictions Settings.
  """
  predictionsSettings: UserPredictionSettings

  """
  The amount of preroll free time in seconds that a user has earned on their channel.
  """
  prerollFreeTimeSeconds: Int

  """
  The hex string for the user's primary creator color.
  Example: "FFFFFF".
  """
  primaryColorHex: String

  """
  The primary team this user belongs to. A user may belong to more than one team at the same time but must select a single
  team as the primary. If the user doesn't have a primary team this will be null.
  """
  primaryTeam: Team

  """Always returns null, will be removed soon."""
  primePayoutDetails: PrimePayoutDetails @deprecated(reason: "Use primePayoutHistory, this will be removed soon")

  """The prime payout details over a period of time for the user."""
  primePayoutHistory: [PrimePayoutDetail!]

  """The Twitch Prime settings data for the user."""
  primeSettings: PrimeSettings

  """
  A URL to the user's profile image.
  Valid widths are 28, 50, 70, 96, 150, 300, and 600.
  The image height will be the same as the given width.
  """
  profileImageURL(width: Int!): String

  """
  The URL to viewing this user's profile.
  This is typically https://twitch.tv/<login> .
  """
  profileURL: String!

  """The number of views this user's profile has received since creation."""
  profileViewCount: Int

  """The program agreement for a user enrolled in a payout program."""
  programAgreement: ProgramAgreement

  """
  A user's pulse feed.
  This is only returned if the request is authenticated by the same user whose email is requested.
  """
  pulseFeed: Feed

  """PurchaseOrder returns a user's purchase order."""
  purchaseOrder(id: ID!): PurchaseOrder

  """Quests associated with a user."""
  quests: Quests

  """Twitch Radio for the user."""
  radio: Radio

  """Twitch Radio account information."""
  radioAccount: RadioAccount @deprecated(reason: "Use user.radio.account instead.")

  """Always returns null."""
  raid: Raid @deprecated(reason: "this feature has been moved")

  """
  Preferences for raid behavior, including whether
  raids are enabled and from whom can raids orignate.
  Users can only view their own raid settings.
  """
  raidSettings: RaidSettings

  """An array of recent raids by the broadcaster."""
  recentRaids: [Raid!]

  """The feedback a user has given about recommended content."""
  recommendationFeedback(limit: Int = 5, after: Cursor, type: String!): RecommendationFeedbackConnection

  """
  Recommendations for the user. Recommendations can be retrieved only if the request
  is authenticated and only for the authenticated user.
  """
  recommendations: Recommendations

  """The recommended prefix which is generated based on user name."""
  recommendedEmoticonPrefix: String!

  """This user's relationship with another user."""
  relationship(targetUserID: ID): UserRelationship

  """User's declared country of residence."""
  residence: UserResidence

  """Info on rewarded video for a user (eligibility)."""
  rewardedVideo: RewardedVideo

  """The roles this user fulfills on Twitch."""
  roles: UserRoles

  """
  Search through a paginated list of public and private videos for this user.
  """
  searchVideos(first: Int = 10, after: Cursor, search: VideoConnectionSearchParams): VideoConnection

  """
  A list of streamer onboarding content IDs that that the user has been shown, and when it was first shown.
  """
  seenCreatorOnboardingContent: [CreatorOnboardingContent!]

  """The badge this user has selected for global use on Twitch."""
  selectedBadge: Badge

  """The authenticated user's relationship with this user."""
  self: UserSelfConnection

  """
  Loads the extension installation data for the queried userID's channel that is relevant to the calling user.
  This includes the extension configuration data & auth tokens for the extension-channel-user combination.
  """
  selfInstalledExtensions(isMobile: Boolean = false): [ExtensionInstallationSelfEdge!]

  """The settings this user has on Twitch."""
  settings: UserSettings

  """
  The squad stream that this user is currently a member of, or null if the user is not a member of
  any squad stream.
  """
  squadStream: SquadStream

  """
  squadStreamSettings are the user's rules and settings for the squad stream feature.
  Some fields only resolve for the authenticated user. See schema definition for more detail.
  """
  squadStreamSettings: SquadStreamSettings

  """
  The relationship between the authenticated user and the single sign-on (SSO)
  apps they have linked to their Twitch account.
  """
  ssoLinks(app: String): [SSOLink!] @deprecated(reason: "Service has been shut down")

  """
  The user's live stream.
  Null if the user is not currently broadcasting.
  """
  stream: Stream

  """A list of the start and end times of stream sessions."""
  streamSessions(first: Int, lastStartedAt: Time): [StreamSession!]

  """
  A list stream sessions that started and ended during the specified interval.
  """
  streamSessionsByInterval(startAt: Time!, endAt: Time!): [StreamSession!]

  """
  A list of stream summaries. Stream summaries provide analytics information
  for a streaming session. Last started time is for querying sessions from a previous time stamp.
  """
  streamSummaries(first: Int, lastStartedAt: Time): [StreamSummary!]

  """Stucco packs displayed in the user's dashboard stucco settings."""
  stuccoPacksBroadcaster: [StuccoPack]

  """
  stuccos available in the library in the user's dashboard stucco settings.
  """
  stuccos: [Stucco]

  """
  A list of channels to which the user is subscribed.
  Only resolves for the authenticated user.
  """
  subscribedChannels(first: Int = 10, after: Cursor, live: Boolean): SubscribedChannelConnection

  """
  The subscription score of the user. Returns both a breakdown of subscriptions and points by tier.
  Authenticated to the current user. Will be nil if the user is not a partner or affiliate.
  """
  subscriberScore: SubscriberScore

  """
  A paginated list of user's all active subscriptions.
  Only resolves for the current user. Returns a forbidden error if requested for another user.
  """
  subscriptionBenefits(first: Int = 10, after: Cursor, criteria: SubscriptionBenefitCriteriaInput!): SubscriptionBenefitConnection

  """
  A list of subscription products available for purchase on the user's page.
  """
  subscriptionProducts: [SubscriptionProduct]

  """
  A list of subscription products available for purchase on the user's page, including handleable errors.
  """
  subscriptionProductsResult: SubscriptionProductsResult!

  """
  Subscription preferences for the current user.
  Only resolves for the current user. Returns an error if request for another user.
  """
  subscriptionSettings: UserSubscriptionSettings

  """
  Subtoken information associated with the user.
  Includes balance of tokens which can be used to redeem Subscriptions.
  """
  subscriptionToken: SubscriptionToken

  """Analytics of the frequency of tags used in discovery."""
  tagAnalytics: [TagAnalytic!]

  """
  Tags are used as a discovery and search mechanism for channels.
  The tag data is from Graffiti directly. Graffiti is not designed to handle huge traffic.
  Please use Stream.tags instead if know the stream is live and you can accept a 5 min delay in the data.
  For example, you should use Stream.tags for the channel page and the browse page, but use User.tags for the dashboard.
  """
  tags: [Tag!]

  """
  A list of UserTeamMemberships which includes all the teams the user is a member of.
  This includes the primary team.
  Only resolves for the current user.
  """
  teamMemberships: [UserTeamMembership]

  """
  Retrieves all the statistics within the start and end time broken down by granularity.
  Default endAt time will be the current time (now).
  Granularity defaults to 5 minutes.
  """
  timeseriesStats(startAt: Time!, endAt: Time, timeZone: String!, granularity: Granularity = FIVE_MINUTE): TimeseriesStats

  """
  Tournament associated with the user. This is used with the Bits custom cheering experience.
  """
  tournament: Tournament @deprecated

  """The user's relationship with Twitch."""
  twitch: UserTwitchConnection

  """Get unacknowledged subscription events."""
  unacknowledgedSubscriptionEvents(platform: String!): [UnacknowledgedSubscriptionEvent!]

  """
  When the user last updated their account.
  Returns null when the user's account has never been updated.
  """
  updatedAt: Time

  """
  Verification request object for the user and an associated contact address.
  If no address is provided, the current email address associated with the user account will be used.
  """
  verificationRequest(address: String): VerificationRequest

  """
  Aggregated analytics for several video referral sources, for use in channel analytics.
  """
  videoPlayReferrals(start: Time!, end: Time!, filter: ReferralsFilter = ALL, dimension: ReferralsDimension!, first: Int = 15): VideoPlayReferrals

  """A paginated list of video shelves to display on the user's channel."""
  videoShelves(first: Int = 10, after: Cursor, options: ShelvesOptions): VideoShelfConnection

  """
  A paginated list of video shelves that are available to be displayed on the
  user's channel. Only accessible for authorized users (user & editors).
  """
  videoShelvesAvailable(first: Int = 10, after: Cursor, options: ShelvesAvailableOptions): VideoShelfConnection

  """A paginated list of videos for this user."""
  videos(first: Int = 10, after: Cursor, type: BroadcastType, types: [BroadcastType!], sort: VideoSort = TIME, options: VideoConnectionOptionsInput): VideoConnection

  """
  The viewable poll for a channel.
  Null if no viewable poll is present.
  """
  viewablePoll: Poll

  """
  A paginated list of viewed videos and their histories for this user.
  Only resolves for current user.
  """
  viewedVideos(first: Int = 10): ViewedVideosConnection

  """A paginated list of channel VIPs."""
  vips(first: Int = 10, after: Cursor): VIPConnection

  """
  A user's balances in their Twitch Wallet in different FIAT currencies
  If this isn't the `currentUser` this will return null.
  """
  walletBalances(walletType: WalletType, bestGuessCountryCode: String): WalletBalances

  """
  A list of restrictions that prevent a user from hosting Watch Parties. A
  user can only host Watch Parties if there are no restrictions.
  """
  watchPartiesRestrictions: [WatchPartiesRestriction!]

  """A Watch Party if the User is currently broadcasting one."""
  watchParty(accessToken: String, decorated: Boolean = false): WatchPartyResult

  """
  Settings related to the Whispers (private user-to-user messaging) feature.
  Only resolves for the authenticated user.
  """
  whisperSettings: WhisperSettings

  """
  A paginated list of whisper threads for the current user, sorted by recent first.
  """
  whisperThreads(first: Int = 10, after: Cursor): WhisperThreadConnection

  """Withholding Tax Detail is the withholding tax rates for the creator."""
  withholdingTaxDetail: WithholdingTaxDetail
}

"""
Groups users account health information around security of their account.
"""
type UserAccountHealth {
  """Is the user required to reset their password."""
  isPasswordResetRequired: Boolean!

  """Is the users email address verified."""
  isVerifiedEmail: Boolean!

  """Current status of the users password."""
  passwordStatus: PasswordStatus!

  """
  The list of Two factor Methods the user has registered with.
  Empty list means the user does not have two factor.
  """
  twoFactorMethods: [TwoFactorMethod!]!
}

"""The relationship between the user and Amazon."""
type UserAmazonConnection {
  """The Amazon associates store linked to this user."""
  associatesStore: AssociatesStore
}

"""The edge between a User and a Blizzard connection."""
type UserBlizzardConnectionLink {
  """Returns battletag if available. Can be string or nil."""
  battleTag: String
}

"""Exactly one of the identifiers must be specified."""
input UserByAttribute {
  """
  The human-readable identifier for a clip.
  When specified, returns the broadcaster of the clip.
  """
  broadcasterOfClipSlug: String

  """The user's login."""
  login: String

  """
  The identifier for a video collection.
  When specified, returns the owner of the collection.
  """
  ownsCollectionID: ID

  """
  The identifier for a video.
  When specified, returns the owner of the video.
  """
  ownsVideoID: ID
}

"""Filtering criteria for paginated user clips results."""
input UserClipsInput {
  """The ID of the broadcaster to filter results by."""
  broadcasterID: ID

  """The ID of the curator to filter results by."""
  curatorID: ID

  """
  DEPRECATED: `filter` should no longer be used. Prefer `period` and `sort` instead.
  A filter which restricts results.
  """
  filter: ClipsFilter

  """The name of the game to filter results by."""
  gameName: String

  """The time period to restrict clips based on creation time."""
  period: ClipsPeriod = LAST_WEEK

  """The sort order for the clips results."""
  sort: ClipsSort = VIEWS_DESC
}

"""
Enum that specifies which role the user is taking when querying for competitions.
"""
enum UserCompetitionRelationship {
  """Player in a competition."""
  PLAYER

  """Owner of a competition."""
  OWNER

  """Unknown competition role."""
  UNKNOWN
}

"""
Paginated list of Users, where the relationship between the source type and the User is
generic enough that no information needs to be encoded on the edge.
"""
type UserConnection {
  edges: [UserEdge!]
  pageInfo: PageInfo!

  """The total number of users."""
  totalCount: Int
}

"""
The connection between a user and the directories they have selected to broadcast in.
"""
type UserDirectoryConnection {
  """The directories selected by this user."""
  nodes: [Directory]!
}

"""
When resolving a User, the underlying service may claim that
no user actually exists for the inputs (i.e. banned, deleted, or
there's no record of an account with that login/ID).
"""
type UserDoesNotExist {
  """Key that was used to resolve the user, could be an ID or login."""
  key: String!
}

"""A list of Drops awarded to the user. // deprecated."""
type UserDropAwardConnection {
  """The Drops awarded to the user."""
  nodes: [DropAward]! @deprecated

  """The number of drop awards a user has received."""
  totalCount: Int @deprecated
}

"""A list of Drops awarded to the user via Drops2.0."""
type UserDropReward {
  """The DropBenefit that a user is entitled to."""
  benefit: DropBenefit!

  """The game that awarded the Drop."""
  game: Game @deprecated(reason: "use benefit.Game")

  """The assigned ID of the awarded reward."""
  id: ID! @deprecated(reason: "use benefit.id")

  """The image URL of the Benefit. Images are 80x80 pixels."""
  imageURL: String! @deprecated(reason: "use benefit.imageAssetURL")

  """
  Flag if the user is connected to the game in order to receive the Reward.
  """
  isConnected: Boolean!

  """
  Specifies if this reward is considered for a game that is available on iOS.
  """
  isIosAvailable: Boolean! @deprecated(reason: "use benefit.isIosAvailable")

  """The timestamp when the Benefit was last awarded to the user."""
  lastAwardedAt: Time!

  """The developer-provided name of the awarded Benefit."""
  name: String! @deprecated(reason: "use benefit.name")

  """
  Link where the user can connect their account necessary to receive the reward.
  """
  requiredAccountLink: String! @deprecated(reason: "use benefit.accountLinkURL")

  """The number of drop awards a user has received."""
  totalCount: Int!
}

"""
Generic edge between some type and a User, where there is no information that needs to
to be encoded on the edge.
"""
type UserEdge {
  cursor: Cursor
  node: User
}

"""An attempt to resolve a user has failed due to an error."""
type UserError {
  """Key that was used to resolve the user, could be an ID or login."""
  key: String!
}

"""The edge between a User and a Facebook connection."""
type UserFacebookConnectionLink {
  """The user's full name on Facebook. eg. "John Doe"."""
  fullName: String!
}

"""UserLeaderboard contains a leaderboard whose entries are Users."""
type UserLeaderboard {
  """id is the id of this leaderboard."""
  id: ID!

  """items is the list of users in the leaderboard ordered by their score."""
  items: UserLeaderboardItemConnection!

  """
  myPosition contains the item representing the authed user's position on this leaderboard.
  """
  myPosition: UserLeaderboardItem

  """
  SecondsRemaining is the number of seconds left before the leaderboard expires (or zero for all-time).
  """
  secondsRemaining: Int!
}

"""UserLeaderboardItem at a specific node in a leaderboard connection."""
type UserLeaderboardItem {
  """id the id of this leaderboard item."""
  id: ID!

  """rank the ordinal rank of this leaderboard item."""
  rank: Int!

  """score the numerical value by which this leaderboard is sorted."""
  score: Int!

  """user is the user that holds this position."""
  user: User
}

"""
UserLeaderboardItemConnection is used to show the various leaderboard items.
"""
type UserLeaderboardItemConnection {
  """edges ..."""
  edges: [UserLeaderboardItemEdge!]!

  """pageInfo ..."""
  pageInfo: PageInfo!
}

"""UserLeaderboardItemEdge describes an edge in a bits leaderboard."""
type UserLeaderboardItemEdge {
  """The cursor for this leaderboard edge."""
  cursor: Cursor!

  """The leaderboard entry at this edge."""
  node: UserLeaderboardItem
}

"""The available types of lookups for a user query."""
enum UserLookupType {
  """Retrieves only active users without TOS/DMCA violations."""
  ACTIVE

  """Includes suspended or deleted users in the results."""
  ALL
}

"""Restrictions on a user participating in a given Prediction Event."""
enum UserPredictionEventRestriction {
  """
  The user is restricted from participating because they have the ability to manage Predictions on this channel.
  """
  CAN_MANAGE_PREDICTIONS

  """
  The user is restricted from participating because their geographic location has a blanket ban on Prediction participation.
  """
  REGION_LOCKED

  """
  The user is restricted from participating because their geographic location
  has a ban on Predictions for the specific game/category being played.
  """
  CATEGORY_REGION_LOCKED
}

"""
Options and preferences for how the user participates in Predictions Events.
Users can only view their own Predictions Settings.
"""
type UserPredictionSettings {
  """Whether the user has accepted the latest Predictions Terms of Service."""
  hasAcceptedTOS: Boolean!

  """
  Whether the user is in a region that is restricted from participation in making predictions.
  """
  isInRestrictedRegion: Boolean

  """
  Whether the user has opted to display a temporary chat badge indicating their choices during Predictions Events.
  """
  isTemporaryChatBadgeEnabled: Boolean!
}

"""
Statistics concerning how a user has performed when making Predictions in a given channel.
"""
type UserPredictionStatistics {
  """
  The total number of events that this user has participated in on this channel.
  """
  eventsTotal: Int!

  """
  The number of events that this user has successfully predicted in this channel.
  """
  eventsWon: Int!

  """
  The most recent prediction made by this user on this channel. Null if they have not made a Prediction recently.
  """
  mostRecentPrediction: Prediction

  """
  The total number of points that this user has spent making predictions in this channel.
  """
  pointsUsed: Int!

  """
  The total number of points that this user has won from correct predictions in this channel.
  """
  pointsWon: Int!

  """
  The highest number of points that this user has won from a correct prediction in this channel.
  """
  pointsWonMax: Int!

  """The user's current win-streak in Events on this channel."""
  winStreak: Int!

  """
  The highest win-streak in Events on this channel the user has ever had.
  """
  winStreakMax: Int!
}

"""Subjective data on a User (user/channel) for the target user."""
type UserRelationship {
  """
  The time when a follower relationship between the user and the target user was established.
  """
  followedAt: Time

  """
  Statistics concerning how well the target user has performed in Prediction Events on the user's channel.
  """
  predictionStatistics: UserPredictionStatistics

  """
  The subscription benefit relationship between the user and the target user.
  Null if the user is not subscribed to the other user.
  """
  subscriptionBenefit: SubscriptionBenefit

  """Subscription tenure data for the user to the target user."""
  subscriptionTenure(tenureMethod: SubscriptionTenureMethod!): SubscriptionTenure
}

"""User's residence."""
type UserResidence {
  """Country in ISO alpha-2."""
  countryCode: String!

  """Postal code."""
  postalCode: String
}

"""The set of results that can occur when resolving a user query."""
union UserResult = User | UserDoesNotExist | UserError

"""The edge between a User and a Youtube Connection."""
type UserRiotConnectionLink {
  """The PUUID for the user's Riot account."""
  id: ID!
}

"""Groups site-wide user roles together."""
type UserRoles {
  """
  Whether or not the user is enrolled in the affiliate program.
  See https://affiliate.twitch.tv for more information.
  """
  isAffiliate: Boolean

  """Whether or not the user is allowed to approve extensions on Twitch."""
  isExtensionsApprover: Boolean @deprecated(reason: "This role is no longer surfaced through the API")

  """
  Whether or not the user is enrolled in the extensions developer program.
  See https://dev.twitch.tv/docs/extensions/onboarding for more information.
  """
  isExtensionsDeveloper: Boolean

  """Whether or not the user can moderate any broadcast chat."""
  isGlobalMod: Boolean

  """Whether or not the user is a partnered broadcaster with Twitch."""
  isPartner: Boolean

  """Whether or not the user is a site admininistrator."""
  isSiteAdmin: Boolean

  """Whether or not the user is a Twitch staff member."""
  isStaff: Boolean
}

"""
UserSelfBitsBadge contains the current user's badge tier in a channel and progress toward the next tier.
NOTE: should probably have been named CurrentUserBitsBadge.
"""
type UserSelfBitsBadge {
  """
  current is the highest bits chat badge the authenticated user has achieved in this channel.
  If a badge tier is disabled after being earned it will still appear here until the next tier is earned.
  If the user hasn't earned any bits badges yet this will be null.
  """
  current: Badge
  id: ID!

  """
  next is the next chat badge the authenticated user can earn in this channel.
  If this is null then there are no higher tiers to earn.
  """
  next: Badge

  """
  nextBits is the bits value of the next chat badge the authenticated user can earn in this channel.
  If this is null then there are no higher tiers to earn.
  """
  nextBits: Int

  """
  progress is the fraction of the way the user is toward the next badge tier [0.0-1.0).
  If `next` is null this will be zero.
  """
  progress: Float!

  """
  tierNotification represents a notification sent to a user when they have achieved
  a new bits badge in a channel. Used to send a special message.
  If no notification is pending this will be null.
  """
  tierNotification: BitsBadgeTierNotification

  """
  totalBits is the number of bits the authenticated user has used in this channel.
  """
  totalBits: Int!
}

"""Subjective data on another User (user/channel) for the current user."""
type UserSelfConnection {
  """
  The badges which are available for the authenticated user to select for use on another user's streams and videos.
  """
  availableBadges: [Badge]

  """
  Ban status of the authenticated user with respect to this user's channel.
  """
  banStatus: ChatRoomBanStatus

  """
  bitsBadge contains information about bits badge progression in a channel.
  This field can only be requested if an OAuth token is supplied with the request.
  """
  bitsBadge: UserSelfBitsBadge

  """
  The bits leaderboard entry shows the current user's entry in the
  channel's leaderboard. It does not show context entries around it.
  """
  bitsLeaderboardEntry: BitsLeaderboardEntry @deprecated(reason: "use user.self.bitsLeaderboardItem instead.")

  """
  The bits leaderboard item shows the current user's entry in the
  channel's leaderboard. It does not show context entries around it.
  """
  bitsLeaderboardItem: BitsLeaderboardItem

  """
  The bits leaderboard position shows the curreent users rank
  and the surrounding users in the current channel.
  """
  bitsLeaderboardPosition: BitsLeaderboard

  """Whether or not the authenticated user can follow this user."""
  canFollow: Boolean!

  """
  CanGift relationship between the authenticated user, another user, and a product.
  True is the authenticated user can gift the product to the other user.
  """
  canGift(product: String!): Boolean! @deprecated(reason: "Transitioning to SubscriptionProductSelfConnection instead")

  """
  CanGiftInChannel relationship between the authenticated user and a product.
  True is the authenticated user is allowed to send gifts in this channel.
  """
  canGiftInChannel(product: String!): Boolean! @deprecated(reason: "Transitioning to SubscriptionProductSelfConnection instead")

  """
  Checks if the authenticated user can subscribe to this channel via Prime.
  """
  canPrimeSubscribe: Boolean!

  """
  Whether the authenticated user has permission to redeem a subscription to this Channel.
  Return Values are.
  1) Null - The Channel to which the User is subscribed to is not supporting any subscription redemption.
  2) False - The User has already utilized their redemption to the channel offering subscription redemption.
  2) True - The User can use the subscription redemption offered by the channel.
  """
  canRedeemSubscription: Boolean

  """
  The list of celebration products available for the authenticated user to purchase in this channel.
  """
  celebrationProducts: [CelebrationProduct]

  """
  If the authenticated user cannot chat in this channel, a list of reasons.
  Null if the user can chat.
  """
  chatRestrictedReasons: [ChatRestrictedReason!]

  """
  Lists the chat badges that should be displayed by the user's display name in
  features on a particular user's channel (i.e. chat, feeds).
  Includes the following badges:
  - global authority (staff/admin/global mod)
  - channel authority (broadcaster/mod)
  - subscriber
  - channel selected (bits) or global selected (prime, turbo, ...).
  """
  displayBadges: [Badge]!

  """
  A follower relationship between the authenticated user and another user.
  Null if the relationship does not exist.
  """
  follower: FollowerEdge

  """
  The friendship-type relationship (friendship, incoming friend request, outgoing friend request) between the
  authenticated user and another user. Null if no friendship-type relationship exists.
  """
  friendship: FriendRelationship

  """True if the authenticated user has joined this channel."""
  isChannelMember: Boolean

  """
  Whether or not the authenticated user is editor of another user's channel.
  """
  isEditor: Boolean

  """
  Whether or not the authenticated user is a founder badge owner of another user's channel.
  """
  isFounder: Boolean

  """
  Whether or not the authenticated user is a moderator of another user's channel.
  """
  isModerator: Boolean

  """
  Whether or not the authenticated user is a VIP of another user's channel.
  """
  isVIP: Boolean

  """
  The timestamp of the last time the authenticated user sent a chat message in
  another user's channel within the last 30 minutes.
  Null if the authenticated user has not chatted in the channel in the last 30 minutes.
  """
  lastRecentChatMessageAt: Time

  """
  Information about the authenticated user's Prime subscription credit benefit.
  """
  primeSubCreditBenefit: PrimeSubCreditBenefit

  """
  The most recent resub token to use for sending a special message.
  If no notification is pending this will be null.
  """
  resubNotification: ResubNotification

  """
  Lists ritual tokens that can be requested or displayed to the user in another user's channel.
  """
  ritualTokens: [RitualToken!]

  """
  The badge the authenticated user selected for use on another user's streams and videos.
  """
  selectedBadge: Badge

  """Stucco packs that are available to viewers of a broadcaster."""
  stuccoPacksViewer: [StuccoPack]

  """
  The current subscriber badge that a user would have if subscribed & remaining locked subscriber badges with progress.
  """
  subscriberBadgeProgress(limit: Int = 5): [SubscriberBadgeProgress!]

  """
  The subscription benefit relationship between the authenticated user and another user.
  Null if the authenticated user is not subscribed to the other user.
  """
  subscriptionBenefit: SubscriptionBenefit

  """
  The number of gift subscriptions that the authenticated user has given to other users in this channel.
  """
  subscriptionGiftCount: Int

  """Subscription tenure data for the user to this channel."""
  subscriptionTenure(tenureMethod: SubscriptionTenureMethod!): SubscriptionTenure

  """
  Whether the authenticated user can send or receive Whispers to/from another user.
  """
  whisperPermissions: WhisperPermissions
}

"""Groups site-wide user settings together."""
type UserSettings {
  """
  Whether the user is whitelisted to host Prime Video watch parties. This
  takes precedence over user.watchPartiesRestrictions.
  """
  canHostWatchParties: Boolean!

  """
  The user's channel feed on/off switch.
  The channel feed is displayed if set to true and is
  hidden if set to false.
  """
  channelFeedEnabled: Boolean! @deprecated

  """The cheer settings for a user, configured in their partner dashboard."""
  cheer: CheerPartnerSettings

  """Whether or not the user has a second authentication method configured."""
  hasTwoFactorEnabled: Boolean

  """
  Whether or not the broadcaster is eligible for payout through Amazon retail revenue share.
  """
  isAmazonRetailRevShareEnabled: Boolean @deprecated(reason: "Game sales discontinued")

  """
  Whether or not the broadcaster is eligible for payout through twitch game commerce revenue share.
  """
  isCommerceRevShareEnabled: Boolean @deprecated(reason: "Game sales discontinued")

  """
  Whether or not the user has requested that their registration date be hidden in the viewer card.
  """
  isCreateDateHidden: Boolean

  """Whether or not the user has elected to be hidden from search results."""
  isDirectoryHidden: Boolean

  """Whether or not the email was successfully reverted."""
  isEmailRevertSuccess: Boolean

  """Whether the user's channel has rituals enabled."""
  isRitualsEnabled: Boolean!

  """Whether the user's channel is whitelisted into the rituals experiment."""
  isRitualsWhitelisted: Boolean! @deprecated(reason: "Rituals is whitelisted only for launch.")

  """
  The user's activity sharing setting.
  Activity is the part of a user's status that shows what they're currently playing, watching, or streaming.
  Requires the `user_presence_friends_read` scope.
  """
  isSharingActivity: Boolean!

  """Partner settings related to leaderboards."""
  leaderboard: LeaderboardSettings

  """The user's preferred language tag for displaying text content."""
  preferredLanguageTag: LanguageTag

  """
  The user's shared availability while online.
  A value of ONLINE (typically called "invisibility") additionally means that the user's activity will not be shared
  regardless of the isSharingActivity setting.
  Requires the `user_presence_friends_read` scope.
  """
  visibility: Visibility!
}

"""The edge between a User and a Steam connection."""
type UserSteamConnectionLink {
  """A Steam user ID."""
  id: ID!
}

"""UserSubscriptionSettings displays the users subscription settings."""
type UserSubscriptionSettings {
  """If the user only wants to receive gifts to channels they follow."""
  giftsToFollowedChannelsOnly: Boolean!

  """If the user wants to hide Badge Modifier."""
  isBadgeModifierHidden: Boolean!

  """If the user wants to hide their Founder Badges."""
  isFounderBadgesHidden: Boolean!

  """If the user wants to hide the number of gifts they've gifted."""
  isGiftCountHidden: Boolean!

  """
  If the user wants to hide their subscription tenure and status in the chat viewer card.
  """
  isSubscriptionStatusHidden: Boolean!
}

"""
UserTeamMembership represents a User's membership to a Twitch Team.
UserTeamMemberships are collections of teams that the User is a part of.
"""
type UserTeamMembership {
  """Whether the team is the primary team for the given User."""
  isPrimary: Boolean!

  """Whether the team is revenue revealed for the given User."""
  isRevenueRevealed: Boolean!

  """Whether the team is stats revealed for the given User."""
  isStatsRevealed: Boolean!

  """The Team the user is a member of."""
  team: Team!
}

"""The relationship between the user and Twitch."""
type UserTwitchConnection {
  """Returns the User's preferred team in Overwatch League."""
  overwatchLeagueTeamPreference: OverwatchLeagueTeamPreference
}

"""The edge between a User and a Twitter connection."""
type UserTwitterConnectionLink {
  """A Twitter username, without the "@" (eg. "Twitch")."""
  username: String!
}

"""The edge between a User and a Youtube Connection."""
type UserYoutubeConnectionLink {
  """The URL for the user's Youtube channel."""
  channelURL: String!
}

"""Error that occurred while validating with code."""
type ValidateVerificationCodeError {
  """Error code for error that occurred while validating with code."""
  code: ValidateVerificationCodeErrorCode
}

"""Error types for verification."""
enum ValidateVerificationCodeErrorCode {
  """Verification failed because provided code does not match."""
  INCORRECT_CODE

  """
  Validation code was incorrect and the code has been regenerated and resent due to too many failed attempts.
  """
  TOO_MANY_FAILED_ATTEMPTS

  """Verification failed due to being rate limited."""
  RATE_LIMITED

  """Verification failed due to some unknown, unclassified error."""
  UNKNOWN
}

"""
ValidateVerificationCodeInput is input required to verify a user contact method
in EVS by validating their verification code.
"""
input ValidateVerificationCodeInput {
  """
  Address that the user is verifying. This will most likely be an email address or phone number.
  """
  address: String!

  """Code used to validate if the verification request is valid."""
  code: String!

  """
  Key for the entity associated with the address. This is generally the Twitch ID of the user.
  """
  key: String!
}

"""
ValidateVerificationCodePayload is the VerificationRequest document returned from EVS on success.
"""
type ValidateVerificationCodePayload {
  """Mutation error based on user input."""
  error: ValidateVerificationCodeError

  """The updated verification request."""
  request: VerificationRequest
}

"""
Vendor consent is a union of different vendors supported based on privacy law.
"""
union VendorConsent = CCPAVendorConsent | GDPRVendorConsent | ROWVendorConsent

"""VendorConsentStatus is the consent status of each vendor."""
type VendorConsentStatus {
  """User consentStatus for this vendor."""
  consentStatus: ConsentStatus!

  """
  A flag that shows if the consent is given by the user or by consent service as default value.
  """
  hasUserSetConsent: Boolean!

  """
  A flag that shows if the vendor should be visible to the consent settings page.
  """
  isVisible: Boolean!

  """Vendor name."""
  name: VendorName!
}

"""
VendorConsentStatusInput is the input struct for vendor consent status.
"""
input VendorConsentStatusInput {
  """Consent status of this vendor."""
  consentStatus: ConsentStatus!

  """name of the vendor."""
  name: VendorName!
}

"""VendorName is the name of the cookie vendor."""
enum VendorName {
  """
  AMAZON is Amazon.
  DEPRECATED vendor.
  """
  AMAZON

  """
  TWITCH_AMAZON is a vendor replacement for Amazon.
  This should be the vendor used to get consent on Amazon.
  """
  TWITCH_AMAZON

  """BRANCH is Branch."""
  BRANCH

  """COMSCORE is ComScore."""
  COMSCORE

  """GOOGLE is Google."""
  GOOGLE

  """NIELSEN is Nielsen."""
  NIELSEN

  """SALESFORCE_DMP is Salesforce_DMP."""
  SALESFORCE_DMP

  """BEESWAX is Beeswax."""
  BEESWAX

  """BEESWAX is Truex."""
  TRUEX

  """THE_TRADE_DESK is The Trade Desk."""
  THE_TRADE_DESK

  """FLASHTALKING is Flashtalking."""
  FLASHTALKING

  """GAMESITE is Gamesite."""
  GAMESITE

  """KANTAR is Kantar."""
  KANTAR

  """SPOTX is Spotx."""
  SPOTX

  """SIZMEK is Sizmek."""
  SIZMEK

  """
  GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS is Google analytics developer Extensions.
  """
  GOOGLE_ANALYTICS_DEVELOPER_EXTENSIONS
}

"""
Represents a user's request to verify a given contact method, such as email address or phone number.
"""
type VerificationRequest {
  """
  Address that the user is verifying. This will most likely be an email address or phone number.
  """
  address: String!

  """
  Key for the entity associated with the address. This is generally the Twitch ID of the user.
  """
  key: String!

  """Time at which the verification request was last modified."""
  modified: Time!

  """Status of the verification request: pending, verified, or rejected."""
  status: VerificationStatus!
}

"""Status of a given verification request."""
enum VerificationStatus {
  """Unknown is used as a safe fallback status."""
  UNKNOWN

  """Pending indicates not yet successfully verified."""
  PENDING

  """Verified indicates successfully verified."""
  VERIFIED

  """
  Rejected indicates we were unable to send a verification request to the given
  address, for example if we received a hard bounce from SES.
  """
  REJECTED
}

"""
VerifyContactMethodInput is input required to verify a user contact method in EVS by their opaque ID.
"""
input VerifyContactMethodInput {
  """Used to validate the associated user contact info."""
  opaqueID: ID!
}

"""
VerifyContactMethodPayload is the VerificationRequest document returned from EVS on success.
"""
type VerifyContactMethodPayload {
  """The success/failure of the verification attempt."""
  isSuccess: Boolean!

  """The updated verification request."""
  request: VerificationRequest
}

"""Error returned during a invalid user request."""
type VerifyOneTimePasswordError {
  """Error code returned by the backend."""
  code: VerifyOneTimePasswordErrorCode!

  """The localized external error message."""
  message: String!
}

"""
The possible error enums returned while trying to verify a one time password.
"""
enum VerifyOneTimePasswordErrorCode {
  """The user needs to re-authenticate to perform this operation."""
  REAUTH_NEEDED

  """The one time password submitted is invalid."""
  INVALID_OTP

  """
  The user does not have two factor enabled and cannot verify a one time password.
  """
  NO_TWO_FACTOR

  """Something unexpected occured."""
  UNKNOWN_ERROR
}

"""The required input for a VerifyOneTimePasswordInput mutation."""
input VerifyOneTimePasswordInput {
  """The one time password that needs to be verified."""
  oneTimePassword: String!

  """The ID of the user attempting to verify a one time password."""
  userID: ID!
}

"""The result of a verifyOneTimePassword mutation."""
type VerifyOneTimePasswordPayload {
  """error code and localized error."""
  error: VerifyOneTimePasswordError
}

"""Error that occurred while validating with captcha token."""
type VerifyRewardedVideoEligibilityCaptchaError {
  """Error code for error that occurred while validating the captcha token."""
  code: VerifyRewardedVideoEligibilityCaptchaErrorCode!
}

"""Error types for captcha verification."""
enum VerifyRewardedVideoEligibilityCaptchaErrorCode {
  """The input provided by the user was rejected."""
  INVALID_PARAMETER

  """The service had an issue unrelated to your input."""
  INTERNAL_ERROR
}

"""Inputs for registering a Captcha for WATEB."""
input VerifyRewardedVideoEligibilityCaptchaInput {
  """Whether we authenticated with V1 or V2 Arkose endpoint."""
  arkoseEndpointVersion: ArkoseEndpointVersion!

  """The token response from Arkose to verify."""
  sessionToken: String!
}

"""The response from verifying a captcha with rewarded video systems."""
type VerifyRewardedVideoEligibilityCaptchaPayload {
  """The error (if one exists) returned from validating the captcha token."""
  error: VerifyRewardedVideoEligibilityCaptchaError
}

"""
IDs used to determine the context(s) by which content was determined for a given VerticalSubDirectory.
"""
union VerticalContentContext = Game | Tag

"""A container of content for a vertical grouped by shelves."""
type VerticalDirectory {
  """The vertical's unique Twitch identifier."""
  id: ID!

  """The vertical's backend name."""
  name: String

  """List of shelf groups containing content for this vertical."""
  shelfGroups: [VerticalShelfGroup!]

  """The human readable slug for the vertical directory, used in the URL."""
  slug: String

  """The subtitle for the shelf group."""
  subtitle: ShelfTitle!

  """The title for the shelf."""
  title: ShelfTitle!

  """Used in client tracking."""
  trackingID: ID!
}

"""An ordered list of content to render with metadata on the content."""
type VerticalShelf {
  """The ordered content for the shelf."""
  content: ShelfContentConnection!

  """The one or more contexts for which this shelf contains content for."""
  contentContext: [VerticalContentContext!]

  """A unique identifier for the shelf."""
  id: ID!

  """The subtitle for the shelf group."""
  subtitle: ShelfTitle

  """The title for the shelf."""
  title: ShelfTitle

  """Used in client tracking."""
  trackingID: ID!

  """The type of this shelf."""
  type: VerticalShelfType!
}

"""A grouping of one or more shelves."""
type VerticalShelfGroup {
  """
  The one or more contexts for which this shelf group contains content for.
  """
  contentContext: [VerticalContentContext!]

  """A unique identifer for this shelf group."""
  id: ID!

  """The ordered shelves for this shelf group."""
  shelves: [VerticalShelf!]

  """The subtitle for the shelf group."""
  subtitle: ShelfTitle

  """The title for the shelf group."""
  title: ShelfTitle

  """Used in client tracking."""
  trackingID: ID!
}

"""The types of vertical shelves supported."""
enum VerticalShelfType {
  """A list of categories to be selected."""
  CATEGORY_SELECTOR

  """Live matches."""
  LIVE_MATCHES

  """Live professionals."""
  LIVE_PROS

  """Replays."""
  REPLAYS

  """Collection."""
  COLLECTION
}

"""A container of content for a vertical by category, grouped by shelves."""
type VerticalSubDirectory {
  """
  The one or more contexts for which this directory contains content for.
  """
  contentContext: [VerticalContentContext!]

  """The vertical's unique Twitch identifier."""
  id: ID!

  """List of shelf groups containing content for this vertical category."""
  shelfGroups: [VerticalShelfGroup!]

  """The subtitle for the shelf group."""
  subtitle: ShelfTitle!

  """The title for the shelf."""
  title: ShelfTitle!

  """Used in client tracking."""
  trackingID: ID!
}

"""The content context of a subdirectory."""
input VerticalSubDirectoryContentContext {
  """The subdirectory content context category ids."""
  categoryIDs: [ID!]

  """The subdirectory content context tag ids."""
  tagIDs: [ID!]
}

type Video {
  """A link to an image which contains an animated preview of the video."""
  animatedPreviewURL: String

  """A list of bookmarks for this video."""
  bookmarks(first: Int, after: Cursor): VideoBookmarkConnection

  """The type of broadcast the video originated from."""
  broadcastType: BroadcastType

  """
  A paginated list of clips for this video.
  When criteria is not specified, the default values are used.
  """
  clips(first: Int = 10, after: Cursor, curatorIDs: [ID!], sort: SortOrder = ASC): ClipConnection

  """A paginated list of comments against this video."""
  comments(first: Int, after: Cursor, last: Int, Before: Cursor, contentOffsetSeconds: Int): VideoCommentConnection

  """A list of tags describing the video."""
  contentTags: [Tag!]

  """The time the video metadata record was created."""
  createdAt: Time

  """
  The user who created this video.
  This will be either the broadcaster or one of their editors.
  """
  creator: User

  """NOTE: named `deleteAt` in Vinyl."""
  deletedAt: Time

  """A description of the video, formatted in markdown."""
  description: String

  """
  Download information of the video. NOTE: Request this field only when a user is requesting a download
  since it will go through a process to generate a download URL on the backend.
  """
  download: VideoDownload

  """The length of the video."""
  duration: Duration @deprecated(reason: "Use length instead, as it's easier to parse.")

  """The game the video is depicting."""
  game: Game

  """The video's identifier."""
  id: ID!

  """Whether the video has been soft deleted."""
  isDeleted: Boolean!

  """Which language the video is in."""
  language: String

  """The length of the video, as an int, in seconds."""
  lengthSeconds: Int

  """A list of moments for this video."""
  moments(first: Int = 10, after: Cursor, sort: SortOrder = ASC, types: [VideoMomentType], momentRequestType: VideoMomentRequestType): VideoMomentConnection

  """
  Publicly available muted segment info, detailing which parts of the video
  have had audio removed.
  """
  muteInfo: VideoMuteInfo

  """
  For highlights, the number of seconds offset from the beginning of the past broadcast the highlight starts.
  For past broadcasts and uploads, this means nothing.
  """
  offsetSeconds: Int

  """The owner of the video."""
  owner: User

  """
  The playback access token that determines whether the user can watch the video.
  Fetched for both authed and unauthed users.
  """
  playbackAccessToken(params: PlaybackAccessTokenParams!): PlaybackAccessToken

  """
  The URL to the thumbnail which should be displayed for the video.
  If either `height` or `width` are not given, a templated value (i.e.
  `{height}`, `{width}`) will be present in the URL instead.
  """
  previewThumbnailURL(height: Int, width: Int): String!

  """
  The time when the archive/highlight/upload was first ever available to public,
  even if it is not currently public.
  """
  publishedAt: Time

  """The reactions associated with this video."""
  reactions: [Reaction]

  """The time the video was recorded."""
  recordedAt: Time

  """
  The reason a video is restricted if the given video is a restricted video.
  For a video that is not restricted, this field can be null.
  """
  resourceRestriction: ResourceRestriction

  """
  The reason a video is restricted if the given video is a restricted video.
  For a video that is not restricted, this field can be null.
  """
  restriction: VideoRestriction @deprecated(reason: "Restriction will be moved over to resourceRestriction instead")

  """Either PRIVATE or PUBLIC."""
  scope: VideoPrivacyScope

  """
  A link to a sprite sheet image made up of preview thumbnails when seeking the video timeline.
  """
  seekPreviewsURL: String

  """The authenticated user's relationship with this video."""
  self: VideoSelfEdge

  """
  When broadcastType is:
  - ARCHIVE: status goes from RECORDING to RECORDED.
  - HIGHLIGHT: status goes from UNPROCESSED to RECORDED.
  - UPLOAD: status goes from CREATED to UPLOADING, to PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong.
  - PREMIERE_UPLOAD: status goes from CREATED to UPLOADING, to
  PENDING_TRANSCODE, to RECORDED, or FAILED if anything goes wrong for this
  legacy broadcast type.
  - PAST_PREMIERE: status goes from RECORDING to RECORDED for this legacy broadcast type.
  """
  status: VideoStatus

  """
  The suggested details for creating an automated highlight from this video.
  """
  suggestedHighlight: VideoSuggestedHighlight

  """
  An array of tags describing the video. This field will be deprecated soon. Please use `Video.contentTag` instead.
  """
  tags: [String]

  """
  A list of thumbnail URLs for the video, ordered by descending priority.
  Owners can insert custom thumbnails into this list.
  If either `height` or `width` are not given, a templated value (i.e.
  `{height}`, `{width}`) will be present in the URL instead.
  """
  thumbnailURLs(height: Int, width: Int): [String]

  """The title of the video."""
  title: String

  """
  A paginated list of clips featuring this vod that is, by default, ordered by view count descending.
  When criteria is not specified, the default values are used.
  """
  topClips(first: Int = 10, after: Cursor, criteria: VideoTopClipsInput): ClipConnection

  """The most recent time the video data was updated."""
  updatedAt: Time

  """The numer of views this video has. Can be delayed by up to 15 minutes."""
  viewCount: Int

  """
  For a scheduled video, the time when the video will be made available to the
  public (the time when the scope will be automatically set to "public").
  For a video that is public or not scheduled, is null.
  """
  viewableAt: Time
}

"""A video bookmark."""
type VideoBookmark {
  """channel the VOD belongs to."""
  channel: User!

  """Time at which the bookmark was created."""
  createdAt: Time!

  """Description of the bookmark."""
  description: String!

  """ID of the bookmark."""
  id: ID!

  """Relative offset in the video."""
  positionSeconds: Int!

  """user who created the bookmark."""
  user: User!
}

"""A paginated list of video bookmarks."""
type VideoBookmarkConnection {
  """The elements of the paginated list."""
  edges: [VideoBookmarkEdge]!

  """Error of the get video bookmarks request."""
  error: VideoBookmarkConnectionError

  """Information about this page."""
  pageInfo: PageInfo!
}

"""
VideoBookmarkConnectionError is the error associated with a getVideoBookmarks.
"""
type VideoBookmarkConnectionError {
  """The associated error code."""
  code: VideoBookmarkConnectionErrorCode
}

"""
VideoBookmarkConnectionErrorCode are the possible errors that this query returns.
"""
enum VideoBookmarkConnectionErrorCode {
  """An unexpected internal server error occurred."""
  INTERNAL_SERVER_ERROR

  """The user is unauthorized to fetch bookmarks for the channel."""
  USER_UNAUTHORIZED
}

"""A video bookmark."""
type VideoBookmarkEdge {
  """Uniquely identifies this clip's position in a connection."""
  cursor: Cursor!

  """The bookmark."""
  node: VideoBookmark!
}

"""Comment on a video."""
type VideoComment {
  """Author of the comment."""
  commenter: User

  """Position of the video where this comment was added."""
  contentOffsetSeconds: Int!

  """The time the comment was created."""
  createdAt: Time!

  """The comments's unique identifier."""
  id: ID!

  """The message of the comment."""
  message: VideoCommentMessage

  """DEPRECATED. List of replies on this comment."""
  replies(first: Int, after: Cursor): VideoCommentConnection @deprecated

  """Where the comment originated."""
  source: VideoCommentSource!

  """Current state of the comment."""
  state: VideoCommentState!

  """The last time this comment was updated."""
  updatedAt: Time!

  """The video on which this comment was added."""
  video: Video
}

"""Paginated list of comments."""
type VideoCommentConnection {
  edges: [VideoCommentEdge]
  pageInfo: PageInfo!
}

"""Video comment edge with cursor and the comment node."""
type VideoCommentEdge {
  cursor: Cursor
  node: VideoComment
}

"""Represents the message of a comment."""
type VideoCommentMessage {
  """Parts of the message body with meta info."""
  fragments: [VideoCommentMessageFragment]

  """
  List of badges the comment author had selected for use at the time of the comment.
  """
  userBadges: [Badge]

  """Text color preferences of comment's author."""
  userColor: String
}

"""Represents a part of the message body with meta info."""
type VideoCommentMessageFragment {
  """Embedded emote info."""
  emote: EmbeddedEmote

  """User which was mentioned."""
  mention: User

  """Raw text of the comment."""
  text: String!
}

"""Where a video comment originated."""
enum VideoCommentSource {
  """The comment originated from the live broadcast."""
  CHAT

  """The comment was manually created by a commenter."""
  COMMENT

  """The comment source is unknown."""
  UNKNOWN
}

"""Represents the state of a video comment."""
enum VideoCommentState {
  """The comment is published."""
  PUBLISHED

  """The comment was manually unpublished by a mod or the channel owner."""
  UNPUBLISHED

  """The comment was automatically flagged for review (AutoMod)."""
  PENDING_REVIEW

  """The comment is possibly spam and has to be reviewed by a moderator."""
  PENDING_REVIEW_SPAM

  """The comment has been soft-deleted."""
  DELETED
}

"""A paginated list of videos, and its metadata."""
type VideoConnection {
  """The list of videos in this page."""
  edges: [VideoEdge]

  """Information about this page of videos."""
  pageInfo: PageInfo

  """The total number of videos in the larger collection."""
  totalCount: Int
}

"""
Optional input to filter videos.
Add any additional optional fields to this input.
"""
input VideoConnectionOptionsInput {
  """The IDs of any categories that should be included in the results."""
  gameIDs: [ID!]

  """
  Whether unpublished (private) videos should be returned. Will only be returned
  for the currently authenticated user. Defaults to false.
  """
  includePrivate: Boolean = false

  """The maximum length in seconds of any videos returned."""
  maxLengthSeconds: Int

  """The minimum length in seconds of any videos returned."""
  minLengthSeconds: Int

  """The ending creation date of any videos returned (not inclusive)."""
  searchRangeEndAt: Time

  """The starting creation date of any videos returned (not inclusive)."""
  searchRangeStartAt: Time
}

"""A Video Connection Search input to set params to include search term."""
input VideoConnectionSearchParams {
  """The search term to filter video results by."""
  term: String
}

"""Video download information."""
type VideoDownload {
  """Status of the download process."""
  status: VideoDownloadStatus!

  """Generated URL from which to download the video."""
  url: String!
}

"""List of possible video download statuses."""
enum VideoDownloadStatus {
  """The video download is created."""
  CREATED

  """The video download is submitted."""
  SUBMITTED

  """The video download is downloading."""
  DOWNLOADING

  """The video download is transmuxing."""
  TRANSMUXING

  """The video download failed to create."""
  FAILED

  """The video download is completed."""
  COMPLETE

  """The video download status is unknown."""
  UNKNOWN
}

"""An element in a paginated list of videos, and its metadata."""
type VideoEdge {
  cursor: Cursor
  node: Video
}

"""Video Ingest Session Metadata for the current or past broadcasts."""
type VideoIngestSession {
  """
  Stream session metadata related to broadcaster's backup ingest session.
  """
  backupIngestSession: BackupIngestSession

  """Bitrates of session by time. Recorded every 3 to 5 seconds."""
  bitrates(startedAt: Time, endedAt: Time): [StreamBitrate!]

  """Broadcaster of the stream."""
  broadcaster: User

  """Recorded framedrop events in stream session."""
  frameDrops: [IngestFrameDrop!]

  """Framerates of session by time. Recorded every 3 to 5 seconds."""
  framerates(startedAt: Time, endedAt: Time): [StreamFramerate!]

  """The ID of the stream ingest session."""
  id: ID!

  """Stream session metadata related to broadcaster's ingest session."""
  ingestSession: IngestSession!

  """Stream session metadata related to broadcaster's RTMP session."""
  rtmpSession: RTMPSession!

  """Recorded starvation events in stream session."""
  starvationEvents: [IngestStarvationEvent!]

  """Set of codes to indicate what is wrong with ingested stream."""
  streamHealth: IngestStreamHealth

  """Stream session metadata related to broadcaster's transcode session."""
  transcodeSessions: [TranscodeSession!]
}

"""
A video moment represents either a point in time, or a duration of time,
during which structured metadata is present.
"""
type VideoMoment {
  """channel the VOD belongs to."""
  channel: User!

  """Time at which the moment was created."""
  createdAt: Time!

  """
  The displayable context of this moment (translated, where applicable). For
  instance, the stream marker comment, game name for game change, or “Pack opening”
  for Hearthstone VCA. Can be null.
  """
  description: String

  """
  A union of the fields that are specific to individual moments, such as Game Mode
  inside Hearthstone VCA data.
  """
  details: VideoMomentDetails

  """
  The duration, in ms, that this moment is applicable, or zero if no duration.
  """
  durationMilliseconds: Int!

  """ID of the moment."""
  id: ID!

  """
  Moments that cover a time range can also contain moments for that time range.
  """
  moments: VideoMomentConnection

  """The time, in ms, after the start of the video when this moment occurs."""
  positionMilliseconds: Int!

  """
  The additional displayable context of this moment (translated, where applicable).
  Can be null.
  """
  subDescription: String

  """
  The url to the thumbnail for this moment.
  Can be null.
  """
  thumbnailURL: String

  """The underlying moment type."""
  type: VideoMomentType!

  """The id of the video this moment is contained in."""
  video: Video
}

"""A paginated list of video moments."""
type VideoMomentConnection {
  """The elements of the paginated list."""
  edges: [VideoMomentEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""
A union of the fields that are specific to individual moments, such as Game Mode
inside Hearthstone VCA data.
"""
union VideoMomentDetails = GameChangeMomentDetails | HearthstoneMomentDetails | OverwatchMomentDetails | PUBGMomentDetails

"""A video moment."""
type VideoMomentEdge {
  """Uniquely identifies this moment's position in the connection."""
  cursor: Cursor!

  """The moment."""
  node: VideoMoment!
}

"""
These request types allow the client to request the backend to do
some analysis and suggest markers that are relevant.
"""
enum VideoMomentRequestType {
  """Moments most likely to be highlighted. Shown to creators."""
  HIGHLIGHTER_SUGGESTIONS

  """Chapter markers shown in the video to viewers."""
  VIDEO_CHAPTER_MARKERS
}

"""Marker types present in momentum."""
enum VideoMomentType {
  """Creator/editor selected moment."""
  STREAM_MARKER

  """GAME_CHANGE is when the streamer changes the game during their stream."""
  GAME_CHANGE

  """Hearthstone video content analysis markers."""
  HEARTHSTONE_VCA

  """Overwatch video content analysis markers."""
  OVERWATCH_VCA

  """PUBG video content analysis markers."""
  PUBG_VCA

  """VCA generic VCA analysis markers."""
  VCA
}

"""Information about one contiguous muted portion of video."""
type VideoMutedSegment {
  """Duration in seconds of the mute. Standard length is 360 (6 mins)."""
  duration: Int!

  """
  Offset is how many seconds into the video the mute begins. 0 indicates the beginning of the video is muted.
  """
  offset: Int!
}

"""
A list of all sections of the video that are muted.
If pagination is required at any point in the future, put edges and pageInfo
in this type.
"""
type VideoMutedSegmentConnection {
  """No pagination functionality. All data returned in initial call."""
  nodes: [VideoMutedSegment!]
}

"""Details about automatic mutes applied to this video."""
type VideoMuteInfo {
  """List of segments muted."""
  mutedSegmentConnection: VideoMutedSegmentConnection

  """List of tracks that are flagged for copyrighted music."""
  tracks: [FlaggedTrack!]
}

type VideoOEmbed implements OEmbed {
  authorName: String
  authorURL: String
  cacheAge: Int
  height: Int!
  html: String!
  inputURL: String!
  providerName: String
  providerURL: String
  thumbnail: ThumbnailOEmbed
  title: String
  type: String!
  version: String!
  width: Int!
}

"""Options to include private videos."""
input VideoOptions {
  includePrivate: Boolean = false
}

"""The required configuration to activate a video overlay extension."""
input VideoOverlayActivationInput {
  """The slot name of where the component extension should be displayed."""
  slot: String!
}

"""
VideoOverlayView holds the view configuration of an extension if the videoOverlay anchor is supported.
"""
type VideoOverlayView implements ExtensionView {
  """
  Specifies whether or not the extension has the ability to link to external websites.
  """
  canLinkExternalContent: Boolean!

  """
  Relative path of the HTML file to load for this view, used by devsite to specify the layout of assets.
  """
  viewerPath: String!

  """The URL which should be loaded in for the extension."""
  viewerURL: String!
}

"""
VideoOverlayViewInput holds the view configuration of an extension if the videoOverlay anchor is supported.
"""
input VideoOverlayViewInput {
  """Relative path of the HTML file to load for this view."""
  viewerPath: String!
}

"""
Endpoints for different video referral sources, based on channel and time range.
"""
type VideoPlayReferrals {
  """The referral groups and respective counts."""
  items: [AggregatedReferrals!]

  """Sum of all referrals for a given date range."""
  total: Int!
}

enum VideoPrivacyScope {
  """The video is only viewable by the owner."""
  PRIVATE

  """The video is listed in search and anyone can view the video."""
  PUBLIC
}

"""
Restrictions for viewing of a video. Resolves if a video is restricted, null otherwise.
"""
type VideoRestriction {
  """The product "short name" a user needs to purchase to view the video."""
  productName: String!

  """The name of the product shown to users."""
  productTitle: String!

  """The reason a video is restricted."""
  reason: String!

  """The type of restriction the video has."""
  type: String!
}

"""The relationship between the authenticated user and a video."""
type VideoSelfEdge {
  """Can a user watch a restricted video."""
  isRestricted: Boolean!

  """User's viewing history against a video."""
  viewingHistory: VideoViewingHistory
}

"""
A video shelf contains items (clips, videos) from a user to display on their videos page.
"""
type VideoShelf {
  """
  The associated collection if the shelf items are from a specified collection.
  """
  collection: Collection

  """A description of what the video shelf contains."""
  description: String

  """
  The associated game with the shelf if the items are from a specified game.
  """
  game: Game

  """ID of the video shelf."""
  id: ID!

  """Videos/clips in the video shelf."""
  items: [VideoShelfItem!]

  """The title of the video shelf."""
  title: String!

  """The type of items the video shelf contains."""
  type: VideoShelfType!
}

"""A paginated list of video shelves with metadata."""
type VideoShelfConnection {
  """The list of video shelves available."""
  edges: [VideoShelfEdge!]

  """The max number of shelves configuration."""
  maxShelfCount: Int

  """Information about this page of video shelves."""
  pageInfo: PageInfo!

  """The total number of shelves available."""
  totalCount: Int!
}

"""A video shelf."""
type VideoShelfEdge {
  """Cursor represents the position of the current edge/node."""
  cursor: Cursor!

  """Uniquely identifies this video shelf's position in a connection."""
  node: VideoShelf
}

"""The item to render in a video shelf."""
union VideoShelfItem = Clip | Video

"""The type of item returned in the video shelf."""
enum VideoShelfType {
  """Broadcasts sorted by recency."""
  LATEST_BROADCASTS

  """Non broadcasts sorted by recency."""
  LATEST_NON_BROADCASTS

  """Clips created within 30 days sorted by views."""
  TOP_CLIPS

  """Videos under 30 minutes sorted by recency."""
  SHORT_VIDEOS

  """Videos over 30 minutes sorted by recency."""
  LONG_VIDEOS

  """Videos marked with a specified game sorted by recency."""
  GAME

  """Videos from a specified collection."""
  COLLECTION

  """All videos."""
  ALL_VIDEOS
}

"""Possible sort orders for lists of videos."""
enum VideoSort {
  """
  Sort the videos descending by time (publishedAt if available or createdAt).
  """
  TIME

  """
  Sort the videos ascending by time (publishedAt if available or createdAt).
  """
  TIME_ASC

  """Sort the videos descending by views."""
  VIEWS
}

enum VideoStatus {
  """The video is being recorded from a live broadcast."""
  RECORDING

  """The video needs to be processed."""
  UNPROCESSED

  """The upload job is ready to begin."""
  CREATED

  """The video is being uploaded."""
  UPLOADING

  """The video is being transcoded."""
  PENDING_TRANSCODE

  """The video is currently transcoding."""
  TRANSCODING

  """Something went wrong."""
  FAILED

  """The video is ready to watch."""
  RECORDED
}

"""
Video stream settings for ingesting a stream such as stream key, latency mode, or vod save preference.
Represents a user's channel setting when starting a streamm.
"""
type VideoStreamSettings {
  """
  A list of Twitch users who are authorized to stream on behalf of a broadcaster.
  """
  authorizedUsers: [User!]

  """A list of stream keys to be used for backup redundant stream."""
  backupStreamKeys: [StreamKeyResult!]!

  """
  The number of seconds delay for a stream. When this is set, a stream will be ingested with specified delay in seconds.
  """
  delaySeconds: Int!

  """
  The number of seconds to display the disconnect slate while the stream is unstable.
  """
  disconnectSlateDurationSeconds: Int!

  """
  When isBackupEnabled is true, streamers can stream a backup stream using the streamkey on backupStreamKeys.
  """
  isBackupEnabled: Boolean!

  """
  When isDelayEnabled is true, streamers can stream with specified delay seconds on delaySeconds.
  """
  isDelayEnabled: Boolean!

  """
  When isDisconnectSlateEnabled is true, streams will show a disconnect slate
  for the period specified on delaySeconds when a stream disconnects temporarily.
  """
  isDisconnectSlateEnabled: Boolean!

  """Whether or not a stream should be started as a low latency stream."""
  isLowLatency: Boolean!

  """
  Whether or not the broadcaster prefers to archive the vod for a stream.
  """
  shouldArchiveVODs: Boolean!

  """
  The RTMP stream key for the user's channel. This key is required to stream a video to Twitch.
  """
  streamKey: StreamKeyResult!
}

"""Details about creating an automated highlight from this video."""
type VideoSuggestedHighlight {
  """
  Boolean for whether this set of suggested segments were addressed and dismissed.
  """
  isDismissed: Boolean!

  """List of suggested video segments."""
  segments: [VideoSuggestedSegment]!

  """Status of the segments."""
  status: SegmentsStatusType
}

"""Information for one suggested video segment."""
type VideoSuggestedSegment {
  """Ending time of the suggested segment in milliseconds."""
  endMS: Int!

  """Starting time of the suggested segment in milliseconds."""
  startMS: Int!
}

"""Filtering criteria for paginated video top clips results."""
input VideoTopClipsInput {
  """The ID of the curator to filter results by."""
  curatorID: ID

  """The time period to restrict clips based on creation time."""
  period: ClipsPeriod = LAST_WEEK

  """The sort order for the clips results."""
  sort: ClipsSort = VIEWS_DESC
}

"""
Describes what type of content this originated from.
NOTE: There is already an enum named BroadcastType which should have been named VideoBroadcastType.
"""
enum VideoType {
  """The video type is live."""
  LIVE

  """The video is a vod."""
  VOD
}

"""
User's viewing history against a video. All fields are null if no viewing history is available.
"""
type VideoViewingHistory {
  """Position in seconds since the start of the video."""
  position: Int

  """When the viewing history was last updated."""
  updatedAt: Time
}

type ViewedNotificationsPayload {
  """
  The modified user which contains an updated OnsiteNotificationsSummary.
  """
  user: User
}

"""A paginated list of viewed videos, their histories, and metadata."""
type ViewedVideosConnection {
  """The list of videos and their viewing histories in this page."""
  edges: [ViewedVideosEdge]
}

"""An element in a paginated list of viewing histories, and its metadata."""
type ViewedVideosEdge {
  """Viewing history of user against the video."""
  history: VideoViewingHistory!

  """Video this viewing history belongs to."""
  node: Video!
}

"""Paginated list of VIP users of a channel."""
type VIPConnection {
  """The elements of the list."""
  edges: [VIPEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""Element in a list of VIP users of a channel."""
type VIPEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """Timestamp of when the VIP status was granted."""
  grantedAt: Time!

  """The user who has the VIP status."""
  node: User
}

"""
The user's shared availability while online.
A value of ONLINE (typically called invisibility) additionally means that the user's activity will not be shared
regardless of the isSharingActivity setting.
NOTE: Should have been named UserOnlineVisibility.
"""
enum Visibility {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

"""A visibility type for the user."""
enum VisibilityInput {
  """
  An ONLINE visibility (default) will cause the user's availability to be inherited from their sessions -- Online if
  they have at least one non-idle session, Away if they have only idle sessions, or Offline if they have no sessions.
  """
  ONLINE

  """
  An AWAY visibility will cause the user to appear as Away if they have any sessions, regardless of idleness, or
  Offline if they have no sessions.
  """
  AWAY

  """
  A BUSY visibility will cause the user to appear as Busy if they have any sessions, regardless of idleness, or
  Offline if they have no sessions.
  """
  BUSY

  """
  An OFFLINE visibility (also called "invisible") will cause the user to appear as Offline always. It will also
  implicitly turn off activity sharing.
  """
  OFFLINE
}

"""Input for Visit Stream Manager."""
input VisitStreamManagerInput {
  """The channel ID of the stream manager visited."""
  channelID: ID!
}

"""Payload returned from Visit Stream Manager call."""
type VisitStreamManagerPayload {
  """The channel ID of the stream manager visited."""
  channelID: ID

  """The success/failure of the client."""
  isSuccess: Boolean

  """The viewer ID trying to view the stream manager."""
  viewerID: ID
}

"""Vote in poll error."""
type VoteInAdPollError {
  """Code describing the error."""
  code: VoteInAdPollErrorCode!
}

"""Vote in poll error code."""
enum VoteInAdPollErrorCode {
  """
  User tried to vote in a poll that doesn't exist i.e. there is no poll running at all).
  """
  POLL_NOT_FOUND

  """User tried to vote in a poll that is not active."""
  POLL_NOT_ACTIVE

  """
  Request has a vote ID that is in progress or has already been submitted.
  """
  VOTE_ID_CONFLICT

  """
  Voter is trying to vote more times than the maximum number of times that the poll allows.
  """
  MAX_VOTE_LIMIT_ERROR

  """
  User is trying to vote for another choice in a poll that only allows one choice.
  """
  MULTI_CHOICE_VOTE_FORBIDDEN

  """Request is for a choice ID that invalid."""
  INVALID_CHOICE_ID

  """An unknown error occurred."""
  UNKNOWN
}

"""Inputs for voting on an ad poll."""
input VoteInAdPollInput {
  """The id of the choice the vote is casted on in the poll."""
  choiceID: ID!

  """The id of the poll that is being voted in."""
  pollID: ID!

  """The voter id of the voter."""
  userID: ID!

  """The unique id for this vote action."""
  voteID: ID!
}

"""Output from the vote on poll mutation."""
type VoteInAdPollPayload {
  """If present, there was an error with the request."""
  error: VoteInAdPollError

  """The voter objet returned by the vote operation."""
  vote: AdPollVote
}

"""
Inputs for voting on a poll by choice index.
Poll id and choice id are retrieved from the backend, before sending the vote.
"""
input VoteInPollByChoiceIndexInput {
  """The id of the channel the vote is being cast in."""
  channelID: ID!

  """
  Important: The ***ONE INDEXED*** (NOT ZERO INDEXED) position of the choice that is chosen in the poll.
  """
  choiceIndex: Int!

  """The tokens used for this vote."""
  tokens: PollVoteTokensInput

  """The user id of the voter."""
  userID: ID!

  """The unique id for this vote action."""
  voteID: ID!
}

"""Output from the vote on poll by choice index mutation."""
type VoteInPollByChoiceIndexPayload {
  """If present, there was an error with the request."""
  error: VoteInPollError

  """The voter objet returned by the vote operation."""
  voter: PollVoter
}

"""Vote in poll error."""
type VoteInPollError {
  """Code describing the error."""
  code: VoteInPollErrorCode!
}

"""Vote in poll error code."""
enum VoteInPollErrorCode {
  """
  User tried to vote in a poll that doesn't exist i.e. there is no poll running at all).
  """
  POLL_NOT_FOUND

  """User tried to vote in a poll that is not active."""
  POLL_NOT_ACTIVE

  """
  Request has a vote ID that is in progress or has already been submitted.
  """
  VOTE_ID_CONFLICT

  """
  User is trying to vote for another choice in a poll that only allows one choice.
  """
  MULTI_CHOICE_VOTE_FORBIDDEN

  """
  Request is for a channel ID that is invalid (e.g. banned channel, channel doesn't exist).
  """
  INVALID_CHANNEL_ID

  """
  Request is for a choice index that is invalid (e.g. there are 3 choices and the request is for index 10).
  """
  INVALID_CHOICE_INDEX

  """Request is for a choice ID that invalid."""
  INVALID_CHOICE_ID

  """
  Request is for an invalid bits amount (e.g. -100 bits, or request is not for a multiple of the Bits cost).
  """
  INVALID_BITS_AMOUNT

  """
  Request is for an invalid Community Points amount (e.g. -100 Points, or request is not for a multiple of the Points cost).
  """
  INVALID_COMMUNITY_POINTS_AMOUNT

  """
  User's bits balance is too low to perform request (e.g. they only have 10 bits and they request to spend 100).
  """
  INSUFFICIENT_BITS_BALANCE

  """
  Users's Community Points balance is too low to perform request (e.g. they only
  have 10 points and they request to spend 100).
  """
  INSUFFICIENT_COMMUNITY_POINTS_BALANCE

  """
  User has already used their base votes, so in order to continue voting, they must use tokens (bits or channel points).
  """
  TOKENS_REQUIRED

  """
  User is not allowed to vote in poll (e.g. they're banned in the channel).
  """
  USER_FORBIDDEN

  """User is not allowed to vote in their own poll with bits."""
  SELF_BITS_VOTE_NOT_ALLOWED

  """
  User cannot vote because they have hit a per-user or per-poll rate limit. The user can try again later.
  """
  RATE_LIMITED

  """An unknown error occurred."""
  UNKNOWN
}

"""Inputs for voting on a poll."""
input VoteInPollInput {
  """The id of the choice the vote is casted on in the poll."""
  choiceID: ID!

  """The id of the poll that is being voted in."""
  pollID: ID!

  """The tokens used for this vote."""
  tokens: PollVoteTokensInput

  """The user id of the voter."""
  userID: ID!

  """The unique id for this vote action."""
  voteID: ID!
}

"""Output from the vote on poll mutation."""
type VoteInPollPayload {
  """If present, there was an error with the request."""
  error: VoteInPollError

  """The voter object returned by the vote operation."""
  voter: PollVoter
}

"""
Twitch Wallet Balances in multiple FIAT currencies. Can be used to purchase
product on the Twitch Platform.
"""
type WalletBalances {
  """List of all Balances that a Twitch User has on their account."""
  allBalances: [Balance!]

  """Currencies that an Twitch User is currently eligible to use."""
  eligibleCurrencies: [Currency!]
}

"""
User's can have different wallet types based on legal and accounting
requirements.
"""
enum WalletType {
  """Only supports loading from FIAT currencies from gift card providers."""
  GIFT_CARD
}

type Watching implements Activity {
  """This activity's type, i.e. "WATCHING"."""
  type: ActivityType

  """The user whose stream is being watched."""
  user: User
}

"""The possible restrictions for a user trying to host Watch Parties."""
enum WatchPartiesRestriction {
  """A user cannot host Watch Parties in their current region."""
  REGION_NOT_SUPPORTED

  """Unknown restriction."""
  UNKNOWN
}

"""Contains all information for Prime Video Watch Parties."""
type WatchParty {
  """Enum representing the restrictions on this Watch Party."""
  contentRestriction: WatchPartyContentRestriction!

  """Option Watch Party decoration."""
  decoration: WatchPartyDecoration

  """The catalog item id played for this watch party."""
  gti: ID! @deprecated(reason: "Use decoration.item.id")

  """Unique ID of the watch party."""
  id: ID!

  """Progress of the current state, null for offline watch parties."""
  progress: WatchPartyProgress

  """Current state of the watch party."""
  state: WatchPartyState!

  """Current title of the watch party."""
  title: String!

  """CCVs for the watch party."""
  viewersCount: Int!
}

"""Restrictions on a piece of content."""
enum WatchPartyContentRestriction {
  """Default type."""
  UNKNOWN

  """Content is viewable by majority regions."""
  BROAD_AVAILABILITY

  """Content is viewable in a select number of regions."""
  LIMITED_AVAILABILITY
}

"""Decoration information for a Watch Party."""
type WatchPartyDecoration {
  """Fully decorated item for a watch party."""
  item: WatchPartyItem!

  """
  Authenticated: filled in only if the user is authorized to watch the content.
  """
  player: WatchPartyPlayer
}

"""Information to communicate to the user about an error state."""
type WatchPartyError {
  """Error code."""
  code: WatchPartyErrorCode!
}

"""Enum for user errors."""
enum WatchPartyErrorCode {
  """Used for invalid requests."""
  BAD_REQUEST

  """Used when the access token is expired."""
  FORBIDDEN

  """Used when the user's request is throttled."""
  REQUEST_THROTTLED

  """Used when the user is geo restricted."""
  GEO_RESTRICTED

  """Used when the error is unknown."""
  UNKNOWN
}

"""Contains all fields needed to render a watch party item."""
type WatchPartyItem {
  """String representing the age rating."""
  contentRating: String

  """
  Enum representing the restrictions on this item. When available, defer to
  the Watch Party content restriction.
  """
  contentRestriction: WatchPartyContentRestriction!

  """Additional details based on the item type."""
  details: WatchPartyItemDetails

  """List of genres."""
  genres: [String!]!

  """Whether or not this item has children content."""
  hasChildren: Boolean!

  """Unique GTI."""
  id: ID!

  """If the content is mature."""
  isMature: Boolean!

  """If this is a child, ID of the parent."""
  parentID: ID

  """Link to continue watching on PV."""
  primeVideoLink: String

  """Prime video rating."""
  primeVideoRating: PrimeVideoRating

  """Null if user is logged out, contains eligibility information."""
  self: WatchPartyItemSelfEdge

  """List of actors and actresses."""
  starring: [String!]!

  """Localized summary."""
  summary: String

  """Localized box art."""
  thumbnailURL: String!

  """Localized title."""
  title: String!

  """Video content type, i.e. episode or series."""
  type: WatchPartyItemType!

  """Publication year."""
  yearPublished: Int

  """Whether the content has parental control restrictions enabled."""
  isParentalControlRestricted: Boolean
}

"""Watch party items, returned in a query."""
type WatchPartyItemConnection {
  """One item per edge."""
  edges: [WatchPartyItemEdge!]!

  """Used for user authentication errors."""
  error: WatchPartyError

  """Amazon link."""
  homepageBrowseLink: String!

  """Pagination info."""
  pageInfo: PageInfo!
}

"""Additional information about content."""
union WatchPartyItemDetails = EpisodeDetails | MovieDetails | SeasonDetails | SeriesDetails

"""Represents a single item for a watch party."""
type WatchPartyItemEdge {
  """Cursor to continue querying from here."""
  cursor: Cursor!

  """Item information."""
  node: WatchPartyItem!
}

"""Contains information about viewer eligibility, likely to change."""
type WatchPartyItemEligibility {
  """Whether the viewer can watch this content."""
  canView: Boolean!

  """Localized string explaining why if canView is false."""
  reason: String
}

"""
Options for querying for catalog items. These fields are mutually exclusive
and parentID will take precedent if both are specified.
"""
input WatchPartyItemSearchOptions {
  """Parameter to query for a parent's children items."""
  parentID: ID

  """Search for content based on the input string."""
  searchQuery: String
}

"""Used for upselling Prime, populated from authentication or geotoken."""
type WatchPartyItemSelfEdge {
  """Info about whether or not the user can view this piece of content."""
  eligibility: WatchPartyItemEligibility!

  """True if the content is PV gated and we will upsell."""
  willShowPrimeUpsell: Boolean!
}

"""Content types for Prime Video."""
enum WatchPartyItemType {
  """Default type."""
  UNKNOWN

  """A leaf node episode in a series/season."""
  EPISODE

  """A leaf node movie."""
  MOVIE

  """Usually a collection of episodes."""
  SEASON

  """Usually a collection of seasons."""
  SERIES
}

"""
Contains information needed to initialize a PV player and play content.
"""
type WatchPartyPlayer {
  """Device Proxy URL to initialize the PV player."""
  deviceProxyBaseURL: String!

  """Parameters to initialize the PV player."""
  sdkInit: String!

  """Token to initialize the PV player."""
  token: String!
}

"""Tracks the current state."""
type WatchPartyProgress {
  """Total duration of the current state."""
  durationSeconds: Int!

  """Current position in seconds of the state."""
  positionSeconds: Int!

  """Wall clock time for the start of the current state."""
  start: Time!
}

"""Wrapper to allow passing back errors."""
type WatchPartyResult {
  """Used for user authentication errors."""
  error: WatchPartyError

  """Can be null if the channel is offline or for authentication errors."""
  session: WatchParty
}

"""Enum for state."""
enum WatchPartyState {
  """Default value."""
  UNKNOWN

  """Pre-play countdown."""
  HYPE_IN

  """In progress, video playback."""
  IN_PROGRESS

  """Offline."""
  OFFLINE
}

"""A message sent in a whisper thread."""
type WhisperMessage {
  """Content of the message."""
  content: MessageBody!

  """Time the message was deleted."""
  deletedAt: Time

  """Time the message was edited."""
  editedAt: Time

  """User that sent the message."""
  from: User!

  """UUID of the message."""
  id: ID!

  """Unique nonce."""
  nonce: String

  """Time the message was sent."""
  sentAt: Time!

  """The thread the message is a part of."""
  thread: WhisperThread!
}

"""Paginated list of messages in a thread."""
type WhisperMessageConnection {
  """The elements of the list."""
  edges: [WhisperMessageEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!
}

"""Element in a list of messages."""
type WhisperMessageEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The whisper message."""
  node: WhisperMessage!
}

"""
The ability for a Twitch user to send or receive Whispers to/from another Twitch user.
"""
type WhisperPermissions {
  """
  If send is NOT_PERMITTED, true if the reason is that the other Twitch user is considered a stranger.
  """
  isStrangerBlocked: Boolean!

  """Capability of the user to receive Whispers from the other Twitch user."""
  receive: WhisperPermissionType

  """Capability of the user to send Whispers to the other Twitch user."""
  send: WhisperPermissionType
}

"""An enumeration of the permissions for one user to Whisper another."""
enum WhisperPermissionType {
  """The sender is allowed to Whisper the recipient."""
  PERMITTED

  """The sender is not allowed to Whisper the recipient."""
  NOT_PERMITTED

  """Any sender is able to Whisper the recipient."""
  NOT_RESTRICTED

  """The sender is temporarily allowed to Whisper the recipient."""
  TEMPORARY
}

"""
Settings related to the Whispers (private user-to-user messaging) feature.
"""
type WhisperSettings {
  """
  If true, disallows strangers from initiating a whisper thread to this user.
  """
  isBlockingWhispersFromStrangers: Boolean!

  """
  If true, this user is disallowed from sending or receiving whisper messages.
  """
  isWhisperBanned: Boolean!
}

"""Spam classification data for a message."""
type WhisperSpamInfo {
  """Time user last marked the thread as not spam."""
  lastMarkedNotSpamAt: Time

  """Spam classification score."""
  likelihood: WhisperSpamLikelihood
}

enum WhisperSpamLikelihood {
  LOW
  MEDIUM
  HIGH
}

"""A conversation between two users."""
type WhisperThread {
  """ID of the whisper thread."""
  id: ID!

  """Whether the thread has been archived."""
  isArchived: Boolean!

  """Whether the user has muted the thread."""
  isMuted: Boolean!

  """
  The last message sent in this thread. Null if no messages in this thread.
  """
  lastMessage: WhisperMessage

  """List of messages in the thread."""
  messages(first: Int = 10, after: Cursor): WhisperMessageConnection

  """List of users in the thread."""
  participants: [User]!

  """Spam data about the thread."""
  spamInfo: WhisperSpamInfo

  """Number of whispers that have not been read by the user in the thread."""
  unreadMessagesCount: Int!

  """Last message read by the user in the thread."""
  userLastMessageRead: WhisperMessage @deprecated(reason: "Not used. Use lastMessage to get the last message. ")

  """
  Timestamp of when the other participant may message the user in the thread.
  """
  whitelistedUntil: Time
}

"""Paginated list of whisper threads."""
type WhisperThreadConnection {
  """The elements of the list."""
  edges: [WhisperThreadEdge!]!

  """Information about this page."""
  pageInfo: PageInfo!

  """Total number of whisper threads."""
  totalCount: Int!

  """
  Total number of whisper threads containing unread messages for the current user.
  """
  totalUnreadCount: Int
}

"""Element in a list of whisper threads."""
type WhisperThreadEdge {
  """Opaque cursor describing this edge's position in the paginated list."""
  cursor: Cursor!

  """The whisper thread."""
  node: WhisperThread!
}

"""Withholding Tax Detail is the withholding tax rates for the creator."""
type WithholdingTaxDetail {
  """Government royalty tax rate applied to user's earnings."""
  royaltyTaxRate: Float!

  """Government service tax rate applied to user's earnings."""
  serviceTaxRate: Float!
}

"""
Contains configuration used to setup checkout via Xsolla, a payment provider.
"""
type Xsolla {
  """
  Iframe URL to allow purchase checkout. This can be an empty string if the URL cannot be generated.
  """
  iframeURL: String! @deprecated(reason: "moving iframe URL generation client-side")

  """Indicates if the token is for Xsolla's sandbox environment."""
  isSandbox: Boolean!

  """
  Access token to allow purchase checkout. This can be an empty string if the token cannot be generated.
  """
  token: String!
}

type XsollaConfigs {
  """
  Iframe URL to allow payment method management or purchase checkout
  There are various cases in which this can be null. One example during
  subscription purchase checkout flow is if there is an issue with the
  Xsolla product mapping to the product in Twitch's system.
  """
  iframeURL: String! @deprecated(reason: "Moving iframe URL generation to Twilight")

  """
  Access token to allow purchase checkout. This can be an empty string if the token cannot be generated.
  """
  token: String!

  """Indicates if the token is for Xsolla's sandbox environment."""
  isSandbox: Boolean!
}

type ZuoraConfigs {
  """Twitch merchant account ID on Zuora."""
  externalAccountID: ID!

  """ID of the hosted page we will render."""
  hostedPageID: ID!

  """URL of the hosted page we will render."""
  hostedPageURL: String!

  """Used to encrypt sensitive information."""
  publicKey: String!

  """Need to pass generated signature to access Zuora payment pages."""
  signature: String!

  """
  In some cases, when you contact Zuora Support with an issue, the person helping you may ask you to provide the tenant ID.
  """
  tenantID: ID!

  """Zuora API uses token as part of authentication."""
  token: String!
}

